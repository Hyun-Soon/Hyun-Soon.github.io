<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-11-12T22:57:04+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hyuim’s blog</title><subtitle>Hyuim&apos;s personal blog.</subtitle><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><entry><title type="html">[DevLog] What The Golf 모작 개발일지 #08</title><link href="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf08/" rel="alternate" type="text/html" title="[DevLog] What The Golf 모작 개발일지 #08" /><published>2024-11-12T00:00:00+09:00</published><updated>2024-11-12T00:00:00+09:00</updated><id>http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf08</id><content type="html" xml:base="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf08/"><![CDATA[<h2 id="1-날짜-date">1. 날짜 (Date)</h2>

<p>2024/11/12</p>

<hr />

<h2 id="2-작업-목표-daily-goals">2. 작업 목표 (Daily Goals)</h2>

<ul>
  <li>Visual Studio Graphics Debugger 무한 로딩 원인 찾기</li>
  <li>Viewport의 MinDepth, MaxDepth / XMMatrixPerspectiveFovLH의 nearZ, farZ 개념 정리하기</li>
  <li>삼각형 렌더링 과정에서 겪었던 문제들 원인 찾기</li>
</ul>

<hr />

<h2 id="3-진행-사항-progress">3. 진행 사항 (Progress)</h2>

<ul>
  <li>목표 해결</li>
</ul>

<hr />

<h2 id="4-문제점-및-해결-방법-challenges--solutions">4. 문제점 및 해결 방법 (Challenges &amp; Solutions)</h2>

<ul>
  <li>Visual Studio Graphic Debugger 무한 로딩 이유
    <ul>
      <li>swapChain-&gt;Present() 함수를 한번만 실행해서, frame의 업데이트가 없어서 debugger가 새로운 프레임을 무한히 기다리며 무한 로딩이 걸리는 것 같다. swapChain-&gt;Present()를 무한 루프에 넣어서 실행했더니 해결됐다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Viewport</code>의 <code class="language-plaintext highlighter-rouge">MinDepth</code>, <code class="language-plaintext highlighter-rouge">MaxDepth</code>를 조절해서 삼각형을 범위 안에 넣어도 렌더링되지 않았던 이유
    <ul>
      <li>Viewport의 MinDepth, MaxDepth는 NDC로 정규화할 때의 깊이의 최솟값과 최댓값을 의미한다. 렌더링되는 z값의 범위를 조절하려면 <code class="language-plaintext highlighter-rouge">XMMatrixPerspectiveFovLH</code>의 <code class="language-plaintext highlighter-rouge">nearZ</code>, <code class="language-plaintext highlighter-rouge">farZ</code>을 바꿔줘야 한다.</li>
    </ul>
  </li>
  <li>vertex의 index 순서
    <ul>
      <li>vertex의 index 순서를 보는 방향 기준 왼손으로 감는 방향(시계 방향)이 아닌, 오른손으로 감는 방향(반시계 방향)으로 설정해줘서 렌더링되지 않았다(<code class="language-plaintext highlighter-rouge">D3D11_RASTERIZER_DESC</code>의 <code class="language-plaintext highlighter-rouge">CullMode</code>가 <code class="language-plaintext highlighter-rouge">D3D11_CULL_BACK</code>인 상황).</li>
    </ul>
  </li>
  <li>View 행렬 함수
    <ul>
      <li><code class="language-plaintext highlighter-rouge">XMMatrixLookAtLH()</code>와 <code class="language-plaintext highlighter-rouge">XMMatrixLookToLH()</code>로 View 행렬을 구성했을 때는 렌더링이 잘 되는데, <code class="language-plaintext highlighter-rouge">CreateLookAt()</code>함수로 View 행렬을 구성했을 때는 렌더링이 되지 않는다. Graphics Debugger를 실행했을 때, XMMatrix 함수들은 View 행렬이 단위행렬인 반면, CreateLookAt() 함수는 아예 DrawIndexed()조차 실행되지 않았다. XM 함수들은 DirectX::XMMatrix를 반환하고, CreateLookAt 함수는 DirectX::SimpleMath::Matrix를 반환한다. 검색결과 상호간에 변환이 자유롭게 되는 것 같은데 무엇이 문제인지 더 찾아봐야겠다. 왜 DrawIndexed()조차 실행되지 않았는지 생각해보자.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="5-다음-단계-next-steps">5. 다음 단계 (Next Steps)</h2>

<ul>
  <li>3D 에셋 찾아보기</li>
  <li>3D 에셋 렌더링하기</li>
</ul>

<hr />

<h2 id="6-회고-reflection">6. 회고 (Reflection)</h2>

<p>14시간 동안 공부하느라 고생했다. 아쉬운 점은, 천천히 코드를 살펴보면서 의미를 살폈으면 더 빠르게 해결할 수 있지 않았나 싶다. 답답할 땐 억지로 앉아 있지 말고 잠깐 산책이나 다녀오자.</p>

<hr />

<h2 id="7-메모-notes">7. 메모 (Notes)</h2>

<hr />]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="DevLog" /><category term="MyWhatTheGolf" /><category term="개발일지" /><category term="directX" /><category term="WinAPI" /><summary type="html"><![CDATA[What The Golf 모작 개발일지]]></summary></entry><entry><title type="html">[DevLog] What The Golf 모작 개발일지 #07</title><link href="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf07/" rel="alternate" type="text/html" title="[DevLog] What The Golf 모작 개발일지 #07" /><published>2024-11-11T00:00:00+09:00</published><updated>2024-11-11T00:00:00+09:00</updated><id>http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf07</id><content type="html" xml:base="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf07/"><![CDATA[<h2 id="1-날짜-date">1. 날짜 (Date)</h2>

<p>2024/11/11</p>

<hr />

<h2 id="2-작업-목표-daily-goals">2. 작업 목표 (Daily Goals)</h2>

<p>삼각형 렌더링</p>

<hr />

<h2 id="3-진행-사항-progress">3. 진행 사항 (Progress)</h2>

<p>삼각형 렌더링 성공</p>

<hr />

<h2 id="4-문제점-및-해결-방법-challenges--solutions">4. 문제점 및 해결 방법 (Challenges &amp; Solutions)</h2>

<ul>
  <li>View 행렬을 단위 행렬로 설정
    <ul>
      <li>MVP에서 View Matrix를 DirectX::SimpleMath::Matrix() 기본 생성자로 넣어놨음. 단위행렬이라 변환에 영향이 없어서 잘 보일 줄 알았는데, 렌더링 되지 않음. CreateLookAt() 함수를 사용하여 해결.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="5-다음-단계-next-steps">5. 다음 단계 (Next Steps)</h2>

<ul>
  <li>Visual Studio 2022 Graphics debugger 무한 로딩 원인 찾기</li>
  <li>vertex 위치가 y축 기준으로 반전되는 문제 원인 찾기(directX는 row-major, hlsl은 column-major이므로 shader에 matrix 넘길 때, transpose 해줘야 함. 이걸 안해서 생기는 문제인 것 같다)</li>
  <li>Viewport의 minDepth = 0.0f, maxDepth = 1.0f로 설정했는데, vertex의 위치가 0.0f에 가깝거나, 0.9f를 넘어가도 렌더링되지 않는 이유 찾기.</li>
  <li>3D object 찾아보기</li>
</ul>

<hr />

<h2 id="6-회고-reflection">6. 회고 (Reflection)</h2>

<p>앞으로 여러 오브젝트를 렌더링하게 될텐데, 각 오브젝트의 특징에 따라 Vertex 구조체와 Constant buffer에 담길 정보들이 달라져야 할 수도 있다. vertices, indices, texture, buffer 등을 오브젝트 클래스의 멤버로 놓고 각자 렌더링하는 방식이 좋을까? 더 효율적인 방법이 있을지 고민해보자. 분위기를 통일성 있게 렌더링하면 굳이 다르지 않아도 될 것 같기도 하다.</p>

<hr />

<h2 id="7-메모-notes">7. 메모 (Notes)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Matrix order</code>
    <ul>
      <li>DirectX : Row-Major</li>
      <li>HLSL : Column-Major</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Map과 Unmap</code> : DirectX3D 11에서 GPU 리소스를 CPU에서 수정하려면 일시적으로 해당 리소스를 맵핑해야 한다. 구조체 <code class="language-plaintext highlighter-rouge">D3D11_MAPPED_SUBRESOURCE</code>는 Map 함수 호출 시 얻은 CPU 메모리 포인터를 저장하여 데이터를 GPU 리소스에 쓸 수 있도록 한다. 아래의 코드에서, GPU의 constantBuffer(ID3D11Buffer 타입)를 CPU에서 접근할 수 있도록 잠금 상태로 설정한다. Map 함수가 성공적으로 실행되면 ms.pData는 CPU에서 직접 접근할 수 있는 메모리 위치를 가리키게 된다. 이후 memcpy를 통해 GPU의 constantBuffer 메모리로 데이터를 전송하고 Unmap으로 맵핑을 해제한다.
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">D3D11_MAPPED_SUBRESOURCE</span> <span class="n">ms</span><span class="p">;</span>
<span class="n">context</span><span class="o">-&gt;</span><span class="n">Map</span><span class="p">(</span><span class="n">constantBufferPtr</span><span class="p">,</span> <span class="p">...);</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">ms</span><span class="p">.</span><span class="n">pData</span><span class="p">,</span> <span class="p">...);</span>
<span class="n">context</span><span class="o">-&gt;</span><span class="n">Unmap</span><span class="p">(...);</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="DevLog" /><category term="MyWhatTheGolf" /><category term="개발일지" /><category term="directX" /><category term="WinAPI" /><summary type="html"><![CDATA[What The Golf 모작 개발일지]]></summary></entry><entry><title type="html">[DevLog] What The Golf 모작 개발일지 #06</title><link href="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf06/" rel="alternate" type="text/html" title="[DevLog] What The Golf 모작 개발일지 #06" /><published>2024-10-30T00:00:00+09:00</published><updated>2024-10-30T00:00:00+09:00</updated><id>http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf06</id><content type="html" xml:base="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf06/"><![CDATA[<h2 id="1-날짜-date">1. 날짜 (Date)</h2>

<p>2024/10/30</p>

<hr />

<h2 id="2-작업-목표-daily-goals">2. 작업 목표 (Daily Goals)</h2>

<p>삼각형 렌더링</p>

<hr />

<h2 id="3-진행-사항-progress">3. 진행 사항 (Progress)</h2>

<ul>
  <li>D3D11_INPUT_ELEMENT_DESC 생성</li>
  <li>Vertex Shader 구현</li>
</ul>

<hr />

<h2 id="4-문제점-및-해결-방법-challenges--solutions">4. 문제점 및 해결 방법 (Challenges &amp; Solutions)</h2>

<hr />

<h2 id="5-다음-단계-next-steps">5. 다음 단계 (Next Steps)</h2>

<ul>
  <li>Pixel Shader 구현</li>
</ul>

<hr />

<h2 id="6-회고-reflection">6. 회고 (Reflection)</h2>

<ul>
  <li>GPU 구조를 공부할 필요성을 느낀다.</li>
  <li>Shader 코드 짤 때, pipeline 흐름 생각하면서 짜면 실수가 줄어들 것 같다.</li>
</ul>

<hr />

<h2 id="7-메모-notes">7. 메모 (Notes)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SM</code> : Streaming Multiprocessor. CPU에 Core가 있다면, GPU에는 SM이 있다. SM은 병렬 처리를 수행하는 GPU의 핵심 연산 장치이다. 각 SM은 수백 개 이상의 작은 코어(CPU에서의 코어와 다름)를 가지고 있으며, 동시에 다수의 스레드를 처리하여 높은 연산 성능을 제공한다. GPU의 SM의 코어는 <code class="language-plaintext highlighter-rouge">CUDA Core</code> 또는 <code class="language-plaintext highlighter-rouge">ALU</code>라고 부르기도 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">SM의 주요 기능</code>
    <ol>
      <li>스레드 그룹화 및 동기화
 SM은 스레드를 <code class="language-plaintext highlighter-rouge">Warp</code>라는 작은 그룹(일반적으로 32개)으로 관리한다. 모든 스레드는 동시에 같은 명령어를 실행하며, 동일한 메모리 영역에 접근할 수 있어 높은 연산 효율을 낸다.</li>
      <li>병렬 연산 지원
 SM의 각 코어는 정수 연산, 부동소수점 연산 등을 담당한다. 병렬 처리로 인해 다수의 데이터 요소에 대한 계산을 동시에 수행할 수 있어, 특히 영상 처리나 신경망 훈련에 큰 성능 향상을 제공한다.</li>
      <li>레지스터 및 공유 메모리
 SM은 각 스레드가 사용하는 레지스터와 여러 스레드가 함께 사용하는 shared memory를 가지고 있다. 공유 메모리는 낮은 대기 시간으로 데이터에 접근할 수 있어 스레드 간 데이터 교환이 원활하다.</li>
      <li>SIMD(Single Instruction, Multiple Data)
 SM은 동일한 명령어를 여러 데이터에 적용하는 SIMD 방식을 채택해 높은 성능을 유지한다.</li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">CPU vs SM</code>
    <ul>
      <li>CPU Core : 낮은 지연 시간과 고속 처리를 위해 설계되었다. 복잡한 연산과 논리 제어를 빠르게 수행할 수 있도록 고성능 메모리 계층과 고급 제어 유닛을 갖추고 있다.</li>
      <li>GPU의 SM의 Core : GPU의 코어는 대규모 병렬 연산을 처리하는 데 최적화되어 있다. 개별 코어는 단순하지만 동시에 수많은 코어가 병렬로 작업을 수행해 고속 처리가 가능하다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">D3D11_INPUT_ELEMENT_DESC</code> : VertexShader에 들어오는 각 input의 구조를 설명하는 구조체.</li>
</ul>

<hr />]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="DevLog" /><category term="MyWhatTheGolf" /><category term="개발일지" /><category term="directX" /><category term="WinAPI" /><summary type="html"><![CDATA[What The Golf 모작 개발일지]]></summary></entry><entry><title type="html">[DevLog] What The Golf 모작 개발일지 #05</title><link href="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf05/" rel="alternate" type="text/html" title="[DevLog] What The Golf 모작 개발일지 #05" /><published>2024-10-29T00:00:00+09:00</published><updated>2024-10-29T00:00:00+09:00</updated><id>http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf05</id><content type="html" xml:base="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf05/"><![CDATA[<h2 id="1-날짜-date">1. 날짜 (Date)</h2>

<p>2024/10/29</p>

<hr />

<h2 id="2-작업-목표-daily-goals">2. 작업 목표 (Daily Goals)</h2>

<p>삼각형 렌더링</p>

<hr />

<h2 id="3-진행-사항-progress">3. 진행 사항 (Progress)</h2>

<ul>
  <li>Vertex Buffer, Index Buffer, 생성</li>
  <li>Vertex Constant Buffer, Pixel Constant Buffer 생성</li>
</ul>

<hr />

<h2 id="4-문제점-및-해결-방법-challenges--solutions">4. 문제점 및 해결 방법 (Challenges &amp; Solutions)</h2>

<hr />

<h2 id="5-다음-단계-next-steps">5. 다음 단계 (Next Steps)</h2>

<ul>
  <li>D3D11_INPUT_ELEMENT_DESC 설정</li>
  <li>vertex shader, pixel shader</li>
</ul>

<hr />

<h2 id="6-회고-reflection">6. 회고 (Reflection)</h2>

<p>확실히 직접 짜보는게 머리에 잘 남고 정리가 잘된다.</p>

<hr />

<h2 id="7-메모-notes">7. 메모 (Notes)</h2>

<ul>
  <li>GPU에 메모리를 할당하는 작업은 <code class="language-plaintext highlighter-rouge">D3D11Device</code>에서 수행한다.</li>
  <li>SUBRESOURCE를 만들 때 일관된 작업을 거쳐야 한다. 예를 들어 Buffer를 만들 때, <code class="language-plaintext highlighter-rouge">D3D11_BUFFER_DESC</code>과 <code class="language-plaintext highlighter-rouge">D3D11_SUBRESOURCE_DATA</code>가 필요하다. DESC로 SUBRESOURCE의 특징을 정의하고, DATA로 실제 데이터가 들어있는 주소를 넘겨준다.</li>
</ul>

<hr />]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="DevLog" /><category term="MyWhatTheGolf" /><category term="개발일지" /><category term="directX" /><category term="WinAPI" /><summary type="html"><![CDATA[What The Golf 모작 개발일지]]></summary></entry><entry><title type="html">\[DevLog\] What The Golf 모작 개발일지 \#04</title><link href="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf04/" rel="alternate" type="text/html" title="\[DevLog\] What The Golf 모작 개발일지 \#04" /><published>2024-10-25T00:00:00+09:00</published><updated>2024-10-25T00:00:00+09:00</updated><id>http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf04</id><content type="html" xml:base="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf04/"><![CDATA[<h2 id="1-날짜-date">1. 날짜 (Date)</h2>

<p>2024/10/25</p>

<hr />

<h2 id="2-작업-목표-daily-goals">2. 작업 목표 (Daily Goals)</h2>

<p>window, directx 클래스 분할</p>

<hr />

<h2 id="3-진행-사항-progress">3. 진행 사항 (Progress)</h2>

<p>임시로 클래스 분할</p>

<hr />

<h2 id="4-문제점-및-해결-방법-challenges--solutions">4. 문제점 및 해결 방법 (Challenges &amp; Solutions)</h2>

<p>directx로 게임을 처음 만들어봐서 그림이 잘 안그려진다. 진행하면서 수시로 리팩토링 해야 할 듯</p>

<hr />

<h2 id="5-다음-단계-next-steps">5. 다음 단계 (Next Steps)</h2>

<p>삼각형 렌더링</p>

<hr />

<h2 id="6-회고-reflection">6. 회고 (Reflection)</h2>

<ul>
  <li>window와 directx를 관리하는 클래스를 각각 만들었다. 나중에 window, device, context 등을 사용해서 게임을 렌더링해야 할텐데, 얘네를 관리하는 클래스에 각자 넣어놔야할지, MyWhatTheGolf 클래스에서 한번에 관리해야 할지 고민이 된다. 다른 게임 코드를 찾아봤는데 몇몇 프로젝트는 window를 전역변수로 해놨다. 일단은 전역변수 쓰지 말고 해보자.</li>
  <li>해상도 값도 웬만하면 MyWhatTheGolf 말고 WindowManager에서 바로 설정하고 싶은데, 나중에 MyWhatTheGolf 클래스에서 사용할 일이 있을 것 같아서 일단 냅두기로 했다.</li>
  <li>프로젝트 진행하면서 구조를 계속 생각해보자.</li>
</ul>

<hr />

<h2 id="7-메모-notes">7. 메모 (Notes)</h2>

<ul>
  <li><a href="https://docs.popekim.com/ko/coding-standards/cpp">Coding Standard</a></li>
</ul>

<hr />]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="DevLog" /><category term="MyWhatTheGolf" /><category term="개발일지" /><category term="directX" /><category term="WinAPI" /><summary type="html"><![CDATA[What The Golf 모작 개발일지]]></summary></entry><entry><title type="html">\[DevLog\] What The Golf 모작 개발일지 \#03</title><link href="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf03/" rel="alternate" type="text/html" title="\[DevLog\] What The Golf 모작 개발일지 \#03" /><published>2024-10-24T00:00:00+09:00</published><updated>2024-10-24T00:00:00+09:00</updated><id>http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf03</id><content type="html" xml:base="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf03/"><![CDATA[<h2 id="1-날짜-date">1. 날짜 (Date)</h2>

<p>2024/10/24</p>

<hr />

<h2 id="2-작업-목표-daily-goals">2. 작업 목표 (Daily Goals)</h2>

<ul>
  <li>DirectX 초기화하기</li>
  <li>Window, DirectX 초기화 코드 클래스로 분할하기</li>
</ul>

<hr />

<h2 id="3-진행-사항-progress">3. 진행 사항 (Progress)</h2>

<p>코드 분할 진행 중</p>

<hr />

<h2 id="4-문제점-및-해결-방법-challenges--solutions">4. 문제점 및 해결 방법 (Challenges &amp; Solutions)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Error LNK2019 unresolved external symbol _main referenced in function "int __cdecl invoke_main(void)" (?invoke_main@@YAHXZ)</code> : main 함수를 wWinMain 함수로 변경했을 때 발생했다. properties -&gt; Linker -&gt; System -&gt; SubSystem에서 Windows로 설정해줘서 해결했다.</li>
</ul>

<hr />

<h2 id="5-다음-단계-next-steps">5. 다음 단계 (Next Steps)</h2>

<ul>
  <li>Window, DirectX 초기화 코드 클래스로 분할하기</li>
  <li>삼각형 렌더링하기</li>
</ul>

<hr />

<h2 id="6-회고-reflection">6. 회고 (Reflection)</h2>

<ul>
  <li>객체 지향 프로그래밍 경험이 없다 보니, Initializer를 어떤 식으로 만드는 게 좋은지 감이 안온다. 인터페이스를 만들고 윈도우, directX intializer에서 이를 기반으로 만들자니 함수에 필요한 인자가 다르고 명시할 인터페이스 내용도 딱히 없다. 일단은 Initializer 객체 안에 window, directX intializer를 멤버 변수로 넣을 것 같다.</li>
  <li>디자인 패턴 공부의 필요성을 느낀다. Component 디자인 패턴을 조사해보자.</li>
</ul>

<hr />

<h2 id="7-메모-notes">7. 메모 (Notes)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SAL</code> : Standard Annotation Language. Microsoft가 Visual C++에서 코드 분석과 정적 코드 검사를 개선하기 위해 도입한 주석 시스템. 코드의 함수, 매개변수, 반환 값에 대한 의도를 명확히 하여, 잠재적인 버그를 미리 감지하고, 안정성을 향상시키는 데 기여한다.</li>
  <li><code class="language-plaintext highlighter-rouge">WINAPI</code> : 매크로로 정의되어 있으며, 실제로는 <code class="language-plaintext highlighter-rouge">__stdcall</code>이라는 호출 규약을 의미한다. __stdcall은 매개변수를 오른쪽에서 왼쪽으로 스택에 push하고, 함수가 반환될 때 호출자가 아니라 함수가 스택을 정리하는 방식이다. 윈도우 API 함수들은 이 규약을 따르기 때문에, 윈도우 API 함수와의 일관성을 유지하기 위해 프로그래머가 작성하는 콜백 함수에도 <code class="language-plaintext highlighter-rouge">WINAPI</code>를 사용하는 경우가 많다.</li>
</ul>

<hr />]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="DevLog" /><category term="MyWhatTheGolf" /><category term="개발일지" /><category term="directX" /><category term="WinAPI" /><summary type="html"><![CDATA[What The Golf 모작 개발일지]]></summary></entry><entry><title type="html">\[DevLog\] What The Golf 모작 개발일지 \#02</title><link href="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf02/" rel="alternate" type="text/html" title="\[DevLog\] What The Golf 모작 개발일지 \#02" /><published>2024-10-23T00:00:00+09:00</published><updated>2024-10-23T00:00:00+09:00</updated><id>http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf02</id><content type="html" xml:base="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf02/"><![CDATA[<h2 id="1-날짜-date">1. 날짜 (Date)</h2>

<p>2024/10/23</p>

<hr />

<h2 id="2-작업-목표-daily-goals">2. 작업 목표 (Daily Goals)</h2>

<p>DirectX 초기화</p>

<hr />

<h2 id="3-진행-사항-progress">3. 진행 사항 (Progress)</h2>

<ul>
  <li>dirverType 설정</li>
  <li>device, context, swapChain 생성</li>
  <li>viewport, rasterizer description 설정</li>
</ul>

<hr />

<h2 id="4-문제점-및-해결-방법-challenges--solutions">4. 문제점 및 해결 방법 (Challenges &amp; Solutions)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">LNK2019 unresolved external symbol D3D11CreateDevice</code> : 헤더 파일은 포함했지만 Direct3D 11 라이브러리가 링커에 제대로 연결되지 않았기 때문에 에러 발생. D3D11CreateDevice 함수는 d3d11.lib라는 라이브러리 파일에 정의되어 있다. 이를 링커에 추가해줘야 한다.
    <ol>
      <li>Project &gt; MyWhatTheGolf Properties &gt; Linker &gt; Input</li>
      <li>Additional Dependencies에 <code class="language-plaintext highlighter-rouge">d3d11.lib</code> 추가</li>
    </ol>
  </li>
</ul>

<hr />

<h2 id="5-다음-단계-next-steps">5. 다음 단계 (Next Steps)</h2>

<ul>
  <li>DirectX 초기화하기</li>
  <li>화면에 삼각형 렌더링하기</li>
</ul>

<hr />

<h2 id="6-회고-reflection">6. 회고 (Reflection)</h2>

<ul>
  <li>강의를 열심히 들어놔서 초반은 무난하게 진행되고 있다.</li>
</ul>

<hr />

<h2 id="7-메모-notes">7. 메모 (Notes)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">device</code> : GPU에 접근하고, DirectX 리소스(버퍼, 셰이더, 텍스처 등)를 생성하는 데 필요한 객체이다. 하드웨어와 관련된 작업을 설정하고, 이러한 리소스를 관리한다.</li>
  <li><code class="language-plaintext highlighter-rouge">deviceContext</code> : 그래픽 파이프라인의 상태를 설정하고, 렌더링 명령을 실행하는 데 사용된다. 즉, device가 생성한 리소스를 이용해 실제로 GPU에서 작업을 실행하는 역할을 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">COM</code> : Component Object Model. 마이크로소프트가 개발한 소프트웨어 기술로, 다양한 언어와 플랫폼 간의 재사용 가능한 객체를 만든다. 주로 Windows 시스템에서 소프트웨어 모듈 간의 통신을 담당하며, DirectX, Windows의 많은 API에서 핵심적인 기술로 사용된다. COM이 사용된 객체는 접두어 I를 붙이는 것이 관례이다. 예로 ID3D11Device가 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">COM</code>의 주요 개념과 특징
    <ol>
      <li>객체 지향 프로그래밍 모델
        <ul>
          <li>객체 지향을 기반으로 하며, 객체 간의 캡슐화와 상호 운용성을 지원한다. 이를 통해 다양한 애플리케이션이나 라이브러리가 독립적으로 개발된 객체들을 사용할 수 있다. COM 객체는 인터페이스를 통해 서로 상호작용한다. 이는 COM이 객체와 상호작용하는 유일한 방법이다.</li>
        </ul>
      </li>
      <li>언어와 플랫폼 간의 상호 운용성
        <ul>
          <li>COM은 여러 프로그래밍 언어(C, C++ 등)로 개발된 모듈들이 서로 호환될 수 있도록 설계되었다. 이를 위해 바이너리 수준에서 상호작용하며, 각기 다른 언어로 작성된 프로그램들이 함께 사용될 수 있다.</li>
        </ul>
      </li>
      <li>인터페이스 기반 설계
        <ul>
          <li>COM은 인터페이스 기반 설계되었으며, 객체는 직접 사용되지 않고 인터페이스를 통해 사용된다.</li>
          <li>인터페이스는 그 객체가 제공하는 기능의 집합을 나타내며, 구현에서 독립적이다. 즉, 클라이언트는 객체의 내부 구현을 알 필요 없이, 해당 인터페이스만 알면 객체를 사용할 수 있다.</li>
          <li>모든 COM 객체는 기본적으로 IUnknown 인터페이스를 구현해야 하며, 이를 통해 참조 카운트 및 인터페이스 쿼리를 관리한다.</li>
        </ul>
      </li>
      <li>참조 카운팅과 메모리 관리
        <ul>
          <li>COM은 참조 카운팅을 통해 메모리 관리를 자동화한다. 각 COM 객체는 자신을 참조하는 클라이언트의 수를 관리하며, 더 이상 참조하는 클라이언트가 없을 때 자동으로 메모리를 해제한다.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ComPtr</code> : DirectX와 같은 COM 기반 API에서 자주 사용되는 스마트 포인터로, Microsoft의 Windows Runtime C++ Template Library(WRL)에 포함되어 있다. ComPtr은 COM 객체의 참조 카운트 관리와 메모리 관리를 자동화하는 데 사용된다.</li>
  <li><code class="language-plaintext highlighter-rouge">ComPtr</code>의 주요 특징과 기능
    <ol>
      <li>참조 카운트 관리 자동화
        <ul>
          <li>COM 객체는 IUnknown::AddRef()와 IUnknown::Release()를 통해 참조 카운트를 관리한다. ComPtr을 사용하면 직접 AddRef나 Release를 호출할 필요 없이, 객체의 생명 주기를 자동으로 관리한다. 따라서 메모리 누수가 발생할 위험이 없다(스마트 포인터 기능).</li>
        </ul>
      </li>
      <li>메서드 호출을 위한 포인터 자동 변환
        <ul>
          <li>ComPtr은 내부적으로 관리하는 실제 포인터를 제공하는 <code class="language-plaintext highlighter-rouge">operator-&gt;()</code>와 <code class="language-plaintext highlighter-rouge">opreator*()</code>를 오버로딩하여, 일반 포인터처럼 COM 객체의 메서드를 호출할 수 있게 해준다.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">RenderTargetView</code> : RTV는 DirectX 11에서 렌더링할 때 화면에 출력할 수 있는 버퍼를 관리하는 중요한 개념이다. “GPU가 렌더링한 결과물을 출력할 대상”을 정의하는 인터페이스로, 주로 back buffer나 텍스처 같은 리소스에 그려진 데이터를 화면에 표시하거나 다른 후처리 단계에서 사용할 수 있게 해준다. DirectX에서 모든 렌더링은 특정 대상에 그려지며, 그 대상이 바로 render target이다. 일반적으로 render target은 swap chain의 back buffer이거나, 특정 texture2D일 수 있다. 즉 render target은 화면에 렌더링하거나 중간 결과물인 텍스처에 렌더링 하기 위해 사용될 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">Depth-Stencil Buffer</code> : 3D 그래픽스에서 렌더 타겟과 함께 사용하는 것이 depth-stencil buffer이다. 이는 픽셀의 깊이 정보를 저장하여, 깊이에 따른 가려짐 효과를 구현한다. 일반적으로 렌더 타겟과 스텐실 버퍼는 함께 바인딩된다.</li>
</ul>

<hr />]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="DevLog" /><category term="MyWhatTheGolf" /><category term="개발일지" /><category term="directX" /><category term="WinAPI" /><summary type="html"><![CDATA[What The Golf 모작 개발일지]]></summary></entry><entry><title type="html">\[DevLog\] What The Golf 모작 개발일지 \#01</title><link href="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf01/" rel="alternate" type="text/html" title="\[DevLog\] What The Golf 모작 개발일지 \#01" /><published>2024-10-22T00:00:00+09:00</published><updated>2024-10-22T00:00:00+09:00</updated><id>http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf01</id><content type="html" xml:base="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf01/"><![CDATA[<h2 id="1-날짜-date">1. 날짜 (Date)</h2>

<p>2024/10/22</p>

<hr />

<h2 id="2-작업-목표-daily-goals">2. 작업 목표 (Daily Goals)</h2>

<p>window 창 띄우기</p>

<hr />

<h2 id="3-진행-사항-progress">3. 진행 사항 (Progress)</h2>

<p>window 창 띄우기 성공</p>

<hr />

<h2 id="4-문제점-및-해결-방법-challenges--solutions">4. 문제점 및 해결 방법 (Challenges &amp; Solutions)</h2>

<hr />

<h2 id="5-다음-단계-next-steps">5. 다음 단계 (Next Steps)</h2>

<p>DirectX 초기화하기</p>

<hr />

<h2 id="6-회고-reflection">6. 회고 (Reflection)</h2>

<ul>
  <li>Windows 운영 체제의 동작 방식과 용어들이 생소하다. 틈틈이 보면서 익숙해져야겠다.</li>
  <li>HINSTANCE가 처음엔 PID인줄 알았는데 약간 다른 것 같다.</li>
</ul>

<hr />

<h2 id="7-메모-notes">7. 메모 (Notes)</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">WNDPROC</code> : “Window Procedure”의 약자로, 윈도우 창과 관련된 이벤트 메시지(입력, 윈도우 크기 조정, 페인팅 등)를 처리하는 콜백 함수. 운영체제가 다양한 메시지를 해당 창의 프로시저로 보내면, 프로시저는 그 메시지를 해석하여 적절한 동작을 수행한다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PID vs HINSTANCE</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">PID</code> : 각각의 실행 중인 프로세스에게 운영 체제가 배정하는 고유한 ID. 특정 프로세스를 관리하거나 추적하기 위해 사용된다(시그널, 종료, 모니터링 등).</li>
      <li><code class="language-plaintext highlighter-rouge">HINSTANCE</code> : Handle to an Instance. 애플리케이션의 현재 인스턴스에 대한 핸들을 의미하며, 실행되고 있는 코드가 적재된 메모리 주소를 가리킨다. 애플리케이션이 실행되면 운영체제는 instance handle을 제공한다. 이 핸들을 통해 애플리케이션의 resource(아이콘, 창 등)들을 관리할 수 있다.</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Handle</code> : Windows에서 handle은 운영체제에 의해 관리되는 resource 또는 object에 대한 abstract reference이다. 고유한 식별자로서, system resource의 자세한 구현을 몰라도 프로그램이 다양한 system resource와 상호작용할 수 있게 해준다. HINSTANCE, HWND 등이 있다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">SOLID 원칙</code>
    <ul>
      <li>S : Single Responsibility Principle, 하나의 클래스는 하나의 책임만 가져야 한다.</li>
      <li>O : Open/Closed Principle, 소프트웨어의 구성 요소는 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.</li>
      <li>L : Liskov Subsitution Principle, 자식 클래스는 부모 클래스에서 정의한 기능을 모두 충족해야 하며, 부모 클래스로 대체가능해야 한다.</li>
      <li>I : Interface Segregation Principle, 클라이언트가 필요하지 않은 기능에 의존하지 않도록 인터페이스를 작고 구체적으로 나눠야 한다.</li>
      <li>D : Dependency Inversion Principle, 구체적인 클래스에 의존하는 것이 아니라, 인터페이스나 추상 클래스에 의존함으로써 유연성을 높여야 한다.</li>
    </ul>
  </li>
</ul>

<hr />]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="DevLog" /><category term="MyWhatTheGolf" /><category term="개발일지" /><category term="directX" /><category term="WinAPI" /><summary type="html"><![CDATA[What The Golf 모작 개발일지]]></summary></entry><entry><title type="html">\[Graphics\] Shader(셰이더)란?</title><link href="http://localhost:4000/graphics/Shader/" rel="alternate" type="text/html" title="\[Graphics\] Shader(셰이더)란?" /><published>2024-07-16T00:00:00+09:00</published><updated>2024-07-16T00:00:00+09:00</updated><id>http://localhost:4000/graphics/Shader</id><content type="html" xml:base="http://localhost:4000/graphics/Shader/"><![CDATA[<p><br /></p>
<h1 id="0-shader란">0. Shader란?</h1>
<p><br />
컴퓨터 그래픽스 분야에서 <code class="language-plaintext highlighter-rouge">Shader</code>는 주로 GPU에서 렌더링 효과를 계산하는 데 사용되는 프로그램을 말한다.</p>

<p>우리의 모니터에 어떤 3D 모델을 띄운다고 하자. 이 3D 모델은 여러개의 삼각형으로 구성되어 있다. 이 모델을 렌더링하기 위해 각 삼각형의 꼭짓점(vertex)들을 원하는 위치로 이동, 회전한 후 그 위치에서의 빛의 세기, 각도 등을 계산한다. 이런 과정등을 통해 화면에서 각 픽셀의 색을 결정한 후 우리 화면에 렌더링한다. 이러한 그래픽스 파이프라인에서 각각의 계산을 수행하는 프로그램들을 Shader라고 한다.</p>

<p>아래는 Direct3D의 그래픽 파이프라인이다. Shader를 거치며 최종적인 픽셀의 색을 결정하는 과정을 확인할 수 있다. 가장 일반적으로 사용되는 Shader는 <code class="language-plaintext highlighter-rouge">Vertex Shader</code>와 <code class="language-plaintext highlighter-rouge">Pixel Shader</code>다.</p>

<p><img src="https://github.com/user-attachments/assets/9ab9a459-a062-4d78-a9c0-2ef8b1fb37b9" alt="image" /></p>

<p><a href="https://learn.microsoft.com/ko-kr/windows/uwp/graphics-concepts/graphics-pipeline">이미지 출처</a>
<br /></p>
<h1 id="1-vertex-shader">1. Vertex Shader</h1>
<p><br />
위에서는 vertex를 삼각형의 꼭짓점으로만 설명했지만, 실제로는 위치를 나타내는 x, y, z값 뿐만 아니라 색상(r, g, b), 텍스쳐, 조명 정보 등이 될 수도 있다.</p>

<p>Vertex Shader는 3D 모델의 각 vertex를 처리한다. 모델의 정점 데이터를 입력받아 이동, 변환, 꼭짓점 별 조명 등의 작업을 수행한 후 출력한다. 단, 기존의 정점을 지우거나 새로운 정점을 추가하는 등의 작업은 할 수 없다.</p>

<p><br /></p>
<h1 id="2-pixel-shader">2. Pixel Shader</h1>
<p><br />
Pixel Shader는 렌더링 될 각 픽셀들의 색을 계산한다. 텍스쳐로부터 색을 읽어오거나, 빛을 적용하는 것, bump mapping, 그림자, 반사광, 투명처리 등의 기능을 수행한다.</p>

<p>이 Shader는 각각의 픽셀들이 렌더링될 때마다 수행되기 때문에, 다른 픽셀들과 아무런 연관이 없다. 따라서 주변의 픽셀이나 그리는 도형에 대한 정보를 알 수 없기 때문에 스스로 매우 복잡한 효과를 만들어 낼 수는 없다.</p>

<p>Z-Buffer(z축 깊이 정보를 담은 버퍼)를 사용하기도 한다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Graphics" /><category term="Shader" /><category term="Graphics" /><summary type="html"><![CDATA[Shader를 알아보자.]]></summary></entry><entry><title type="html">\[C++\] 클래스의 복사를 막는 방법</title><link href="http://localhost:4000/cpp/PreventCopyingClass.md/" rel="alternate" type="text/html" title="\[C++\] 클래스의 복사를 막는 방법" /><published>2024-07-11T00:00:00+09:00</published><updated>2024-07-11T00:00:00+09:00</updated><id>http://localhost:4000/cpp/PreventCopyingClass.md</id><content type="html" xml:base="http://localhost:4000/cpp/PreventCopyingClass.md/"><![CDATA[<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TempClass</span> <span class="p">{};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">TempClass</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">TempClass</span> <span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// copy constructor</span>
	<span class="n">TempClass</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// copy assignment operator</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">copy constructor</code>와 <code class="language-plaintext highlighter-rouge">copy assignment operator</code>가 선언되어있지 않은 클래스 <code class="language-plaintext highlighter-rouge">TempClass</code>가 있다. main문에서 TempClass의 copy constructor와 copy assignment operator를 호출하고 있기 때문에, 컴파일러는 이를 알아서 정의해 버린다. 따라서 구현하지 않는다고 해서 클래스의 복사를 막을 수는 없다. 그렇다면 어떻게 복사를 막을까?</p>

<p>이들을 private으로 정의하는 방법을 먼저 떠올릴 수 있을 것이다. 클래스 밖에서 TempClass를 복사하려고 할 때 private으로 되어 있으면 호출이 불가능하다. 그러나 여전히 클래스의 멤버 함수나 friend 함수가 호출할 수 있는 위험이 있다. 이런 위험까지 방지하려면 private에 선언만 해놓으면 된다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TempClass</span>
<span class="p">{</span>
	<span class="nl">private:</span>
		<span class="n">TempClass</span><span class="p">(</span><span class="k">const</span> <span class="n">TempClass</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
		<span class="n">TempClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TempClass</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>copy constructor와 copy assignment operator가 선언이 되어 있기 때문에 컴파일러가 이들을 생성하지는 않지만, 구현부가 없기 때문에 링크 과정에서 에러가 발생할 것이다.</p>

<p class="notice--primary">🔔 <strong>링크 과정에서 에러가 발생하는 이유</strong><br />
컴파일러는 코드를 어셈블리어로 바꿔주는 역할을 한다. 이 때, 컴파일러가 굳이 다른 소스 파일의 구현까지 자세히 알 필요는 없기 때문에 컴파일 과정에서는 문제가 발생하지 않는다. 하지만 object file들을 연결하며 하나의 프로그램을 만드는 링크 과정에서는 실제의 동작을 알아야 하기 때문에 구현이 없는 경우 에러가 발생한다.</p>

<p>에러 시점을 링크 과정이 아닌 컴파일 과정으로 앞당기고 싶다면 부모 클래스를 활용해야 한다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Uncopyable</span>
<span class="p">{</span>
	<span class="nl">protected:</span>
		<span class="n">Uncopyable</span><span class="p">()</span> <span class="p">{}</span>
		<span class="o">~</span><span class="n">Uncopyable</span><span class="p">()</span> <span class="p">{}</span>

	<span class="k">private</span><span class="o">:</span>
		<span class="n">Uncopyable</span><span class="p">(</span><span class="k">const</span> <span class="n">Uncopyable</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
		<span class="n">Uncopyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Uncopyable</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">TempClass</span> <span class="o">:</span> <span class="k">private</span> <span class="n">Uncopyable</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</code></pre></div></div>

<p>위 코드에서 Uncopyable 클래스를 TempClass에서 상속 받는다. copy constructor, copy assignment operator가 없는 TempClass에 대해 컴파일러가 이들을 생성할 때, 부모 클래스의 것들과 호환이 되도록 생성하려고 할 것이다. 하지만 부모클래스에서 이들이 private으로 선언되어 있기 때문에 TempClass에서는 접근할 방법이 없고, 결국 컴파일러가 에러를 뱉게 된다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Cpp" /><category term="Cpp" /><summary type="html"><![CDATA[컴파일러가 자동으로 생성하는 복사 생성자, 복사 할당 연산자를 제한하는 방법을 알아보자]]></summary></entry></feed>
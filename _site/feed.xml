<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-10-20T15:25:00+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hyuim’s blog</title><subtitle>Hyuim&apos;s personal blog.</subtitle><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><entry><title type="html">ft_printf</title><link href="http://localhost:4000/42seoul/ft_printf/" rel="alternate" type="text/html" title="ft_printf" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-20T00:00:00+09:00</updated><id>http://localhost:4000/42seoul/ft_printf</id><content type="html" xml:base="http://localhost:4000/42seoul/ft_printf/"><![CDATA[<h1 id="0-과제-설명">0. 과제 설명</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printf 함수를 구현한다.
</code></pre></div></div>

<p><br />
<br /></p>
<h1 id="1--가변-인자variable-argument">1.  가변 인자(variable argument)</h1>
<p>가변 인자는 말 그대로 개수가 변할 수 있는 인자이다.<br />
함수 printf를 사용하는 경우를 생각해보자.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%s %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"this is an example."</span><span class="p">,</span> <span class="mi">123</span><span class="p">);</span>
	<span class="n">printf</span> <span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">456</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 코드에서 첫 번째 printf에 <code class="language-plaintext highlighter-rouge">"%s %s\n"</code>, <code class="language-plaintext highlighter-rouge">"this is an example"</code>, <code class="language-plaintext highlighter-rouge">123</code> 3개의 인자가 들어갔다. 하지만 두 번째 printf에는 <code class="language-plaintext highlighter-rouge">"%d\n"</code>, <code class="language-plaintext highlighter-rouge">456</code> 2개의 인자가 들어갔다.
printf 함수는 첫 번째 인자 문자열에 주어지는 <code class="language-plaintext highlighter-rouge">%</code>의 수에 따라 추가적인 인자가 필요하므로, printf 함수를 만들 때 사용자가 몇 개의 인자를 넣을 것인지 미리 알 수 없다.
이렇게 상황에 따라 함수가 받는 인자의 수를 조절하고 싶을 때 가변 인자를 사용할 수 있다.
<br /></p>
<h2 id="1-1-가변-인자-사용법">1-1. 가변 인자 사용법</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
</span></code></pre></div></div>
<p><br />
가변 인자에 관한 함수와 구조체는 stdarg.h 헤더에 들어 있다.<br />
가변 인자를 갖는 함수의 프로토 타입은 다음과 같다.
<br /></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_args</span><span class="p">,</span> <span class="p">...);</span>
</code></pre></div></div>
<p><br />
가변 인자는 몇 개가 될지 모르므로 <code class="language-plaintext highlighter-rouge">...</code>으로 표시한다. <br />
<u>최소 1개의 고정 인수(위의 경우 num_args)가 필요하다는 점에 유의하자.</u>
이 고정 인수는 뒤에 올 가변 인자의 개수를 알려주는 역할을 한다.</p>

<h2 id="1-2-매크로">1-2. 매크로</h2>
<p>stdarg.h에는  가변 인수를 사용하기 위한 다양한 매크로가 존재한다.</p>

<h3 id="1-2-1-va_list">1-2-1. va_list</h3>
<p>va_list는 가변 인수들의 정보를 담아 놓기 위한 타입이다. 길이가 변할 수 있는 인수들을 저장해야 하기 때문에 va_list 또한 저장 공간의 크기를 유동적으로 늘리고 줄일 수 있는 가변 공간이다.</p>

<div class="notice--warning">
  <p>⚠️ 클러스터 Mac(Intel Mac)에서는 va_list 자료형 자체로 포인터지만, M1 Mac에서는 포인터가 아닌 일반 자료형이다. 따라서 va_list를 통해 가변 인자 값에 접근하는 방식에 있어서 차이가 발생한다.</p>
</div>

<h3 id="1-2-2-va_start">1-2-2. va_start</h3>
<p>va_start는 va_list를 사용하기 전에 초기화하는 역할을 한다. 왜 va_list를 초기화해야 할까?<br />
va_list가 가리키고 있는 주소를 마지막 고정 인자 다음의 첫 번째 가변 인자의 주소로 설정해야 하기 때문이다(va_list는 포인터 임을 잊지 말자).<br />
따라서 va_start는 <code class="language-plaintext highlighter-rouge">va_list</code>, <code class="language-plaintext highlighter-rouge">마지막 고정인자</code> 2개의 인자를 필요로 한다.
<br /></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// ap의 주소를 고정 인자 n 다음, 즉 첫 번째 가변 인자의 주소로 옮긴다.</span>
<span class="p">}</span>
</code></pre></div></div>
<p><br /></p>
<h3 id="1-2-3-va_arg">1-2-3. va_arg</h3>
<p>va_list가 현재 가리키고 있는 인자를 반환하고, va_list의 주소를 다음 인자로 이동시킨다.
첫 번째 인자로 va_list, 두 번째 인자로 현재 인자의 type을 입력받는다.
<br /></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">//ap에서 int 타입의 인자를 반환한다.</span>
<span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<div class="notice--primary">
  <p>🔔 va_arg로 <code class="language-plaintext highlighter-rouge">char</code>타입 인자를 반환받는 경우, 아래와 같이 char형이 아닌 int 자료형을 두 번째 인자로 넣어줘야 한다. CPU는 메모리를 4bytes씩 접근하는데, char는 1byte만을 차지하기 때문에, 3bytes의 남는 공간이 생긴다. 하지만 1byte만 char형을 넣어놓고 바로 이어서 4bytes인 int형을 넣어 놓는다면, 메모리가 char형을 읽고 다음 4bytes 위치의 메모리에 접근했을 때 int 변수의 시작 주소가 아닌 중간 주소에 접근하는 꼴이 되므로 효율적인 메모리 접근이 불가능하다. 따라서 CPU의 메모리 접근 크기보다 작은 char형은 실질적인 내용은 1byte 밖에 없지만 4bytes의 공간을 차지하도록 할당한다.</p>

  <table>
    <thead>
      <tr>
        <th style="text-align: center">char</th>
        <th style="text-align: center">empty</th>
        <th style="text-align: center">empty</th>
        <th style="text-align: center">empty</th>
        <th style="text-align: center">int</th>
        <th style="text-align: center">int</th>
        <th style="text-align: center">int</th>
        <th style="text-align: center">int</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="text-align: center">메모리 접근</td>
        <td style="text-align: center">————</td>
        <td style="text-align: center">————</td>
        <td style="text-align: center">————</td>
        <td style="text-align: center">메모리 접근</td>
        <td style="text-align: center">————</td>
        <td style="text-align: center">————</td>
        <td style="text-align: center">————</td>
      </tr>
    </tbody>
  </table>

  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div>  </div>
</div>
<p><br /></p>
<h3 id="1-2-4-va_end">1-2-4. va_end</h3>
<p>가변 인자를 모두 사용하고 난 후 실행하는 함수로, ap의 값을 <code class="language-plaintext highlighter-rouge">NULL</code>로 변경한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
</code></pre></div></div>
<p><br /></p>
<h2 id="1-2-예시-코드">1-2. 예시 코드</h2>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"ft_printf.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">ft_printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bytes</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="n">read_format</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span> 
	<span class="c1">// read_format : format을 해석하고, 이에 맞게 출력 후 출력한 글자 byte 수를 리턴해주는 함수</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="42Seoul" /><category term="printf" /><category term="42Seoul" /><category term="ft_printf" /><summary type="html"><![CDATA[printf를 구현해보자.]]></summary></entry><entry><title type="html">Libft</title><link href="http://localhost:4000/42seoul/Libft/" rel="alternate" type="text/html" title="Libft" /><published>2023-10-19T00:00:00+09:00</published><updated>2023-10-19T00:00:00+09:00</updated><id>http://localhost:4000/42seoul/Libft</id><content type="html" xml:base="http://localhost:4000/42seoul/Libft/"><![CDATA[<h1 id="0-과제-설명">0. 과제 설명</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>libc에 있는 함수 및 앞으로의 문제를 푸는 데 유용한 함수들을 구현하고 library로 만든다.
</code></pre></div></div>

<p><br />
<br /></p>

<h1 id="1-library">1. Library</h1>

<h2 id="1-1-library란">1-1. Library란?</h2>

<p><strong>라이브러리</strong>는 주로 소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임이다.
비휘발성 자원의 예로는 미리 작성된 코드, 함수, 클래스, 자료형 등이 있다.<br />
라이브러리는 재사용이 필요한 기능의 반복적인 코드 작성을 피하고, 언제든지 필요한 곳에서 호출하여 사용하기 위한 목적을 가지고 만들어진다.<br />
새로운 소스 파일들과 빠르게 링크될 수 있도록 보통 컴파일된 형태인 <code class="language-plaintext highlighter-rouge">object file</code>로 존재하며 미리 컴파일 되어 있기 때문에 컴파일 시간도 단축된다.
<br /></p>
<h2 id="1-2-library의-종류">1-2. Library의 종류</h2>

<p>라이브러리는 크게 <strong>정적 라이브러리</strong>와 <strong>동적 라이브러리</strong> 두 종류로 사용된다.<br />
두 라이브러리의 가장 큰 차이점은 실행파일에 링킹되는 시점이다.</p>

<ul>
  <li>
    <p><strong>정적 라이브러리</strong>(Static Library) (.a / .lib)</p>

    <p>정적으로 만들어진 라이브러리는 링크 단계에서 실행 파일에 포함된다.
  즉, 라이브러리의 동작 코드가 실행 파일에 들어있기 때문에 별도의 추가 작업 없이 실행 파일에서
  바로 라이브러리의 함수들을 사용할 수 있다.
  하지만 실행 파일에서 사용하지 않는 코드가 라이브러리에 많이 담겨 있을수록, 실행 파일의 불필요한 볼륨이
  커지기 때문에 메모리의 공간 활용 효율이 떨어지는 등의 문제가 생긴다.
<br /></p>
  </li>
  <li>
    <p><strong>동적 라이브러리</strong>(Dynamic Library) (.so / .dll)</p>

    <p>컴파일 타임에 링킹되는 정적 라이브러리와 다르게 동적 라이브러리는 런타임에 연결된다.
  정적 라이브러리와의 가장 큰 차이점은, 라이브러리를 사용할 때 각각의 프로세스마다 메모리에 라이브러리 전체 내용을 할당하는 것이 아닌, 필요한 내용만 할당하여 사용할 수 있다는 점이다.
  이러한 특징이 생기는 이유는 obj 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을 복사하지 않고, 해당 모듈의 주소만을 가지고 있다가 런타임에 실행 파일과 라이브러리가 메모리에 위치될 때 해당 모듈의 주소로 가서 필요한 것만 들고 오는 방식이기 때문이다. 런타임에 운영체제에 의하여 이러한 작업이 수행된다.
<br /></p>
  </li>
  <li>
    <p><strong>정적 라이브러리와 동적 라이브러리의 차이점</strong></p>

    <p>정적 라이브러리는 실행할 때 라이브러리의 내용을 모두 메모리에 로드하는 반면, 동적 라이브러리는 메모리에 이미 존재하는 경우 로드되는 시간과 공간을 아낄 수 있다. 하지만 매번 라이브러리의 주소에 접근해야 하기 때문에 오버헤드가 존재해 수행 시간은 정적 라이브러리보다 느리다.</p>
  </li>
</ul>

<p><br /></p>
<h2 id="1-3-라이브러리-만들기">1-3. 라이브러리 만들기</h2>

<p>명령어 ar을 사용한다.<br />
컴파일된 <em>.o 파일들을 묶어서 library (</em>.a)로 만든다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">option</th>
      <th style="text-align: center">meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">-r</td>
      <td style="text-align: center">지정한 파일을 archive 파일에 추가, 만약 기존 파일이면 치환한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">-c</td>
      <td style="text-align: center">archive가 생성 되어질 때 기본적으로 표준 에러로 기록되어지는 진단 메세지의 출력을 제한한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">-u</td>
      <td style="text-align: center">오브젝트 파일의 타임스탬프를 비교해 새로운 파일일 경우에만 치환한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">-v</td>
      <td style="text-align: center">자세한 내용을 보여주는 verbose 모드로, 파일 크기나 갱신 시각 등의 상세 정보를 출력한다.</td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>
<h1 id="2-필요-개념">2. 필요 개념</h1>

<ul>
  <li>
    <p><strong>void pointer로 입력받은 인자를 unsigned char 포인터로 캐스팅해서 접근하는 이유</strong></p>

    <p>void pointer에 어떤 포인터가 들어올지 모르기 때문에 1바이트씩 접근해야 안전하다. 포인터는 주소값이기 때문에 부호를 쓰지 않는다. 따라서 char가 아닌 unsigned char를 쓰는 것이 관례이다.
<br /></p>
  </li>
  <li>
    <p><strong>const int*와 int* const의 차이</strong></p>

    <p>const int<em>( = int const *)는 const int형을 가리키는 포인터로, 포인터 값은 변경 가능하지만 내부의 int값은 const로 선언되어 변경이 불가능하다. 반면 int</em> const는 const 포인터가 int형을 가리키고 있으므로 포인터의 값은 변경 불가능하지만 내부의 int값은 변경이 가능하다.
<br /></p>
  </li>
  <li>
    <p><strong>mem vs str functions</strong></p>

    <p>str함수는 “문자열을 검사하기 위한” 함수. 즉, ‘\0’ 또는 size를 통해서 종료 시점을 결정한다.<br />
  반면 mem 함수는 모든 배열에 대해 사용할 수 있어야 하기 때문에 size만을 통해서 종료 시점을 결정한다.</p>

    <p>함수 내부에서 unsigned char로 캐스팅 해주는 이유 : unsigned char는 변수 안의 모든 값이 부호비트나 패딩비트같이 어떠한 용도로 사용되는 값이 없고, 우리가 전달하고자 하는 값으로 모두 차있기 때문에 비트 해석이 왜곡될 걱정이 없다.</p>

    <p>*패딩비트 : 가장 큰 자료형의 크기를 따르기 때문에 생기는 사용하지 않는 비트
<br /></p>
  </li>
  <li>
    <p><strong>size_t</strong></p>

    <p>size_t는 typedef를 이용하여 정의한 하나의 별칭(alias)으로 ‘이론상 가장 큰 사이즈를 담을 수 있는 unsigned 데이터 타입’으로 정의된다.<br />
  즉, 32bit에서는 unsigned int, 64bit에서는 unsigned long long이 된다.
<br /></p>
  </li>
  <li>
    <p><strong>함수 포인터</strong></p>

    <p>포인터는 다른 변수의 주소를 저장하는 변수다. 이와 유사하게 함수 포인터는 함수의 주소를 저장하는 변수다.</p>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>식별자 foo는 함수의 이름이다. 변수와 마찬가지로 함수는 메모리의 할당된 주소에 있다.</p>

<p>() 연산자를 통해 함수를 호출하면, 호출되는 함수의 주소로 점프하여 실행한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">foo</span><span class="p">();</span> <span class="c1">//foo 함수의 주소(ex.0x002717f0)로 점프한다.</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>함수 foo를 printf로 출력하면 0x002717f0가 출력된다.
<br />
함수 포인터는 함수의 주소를 저장했다가, 해당 주소의 함수를 호출하는 데 사용하는 포인터를 말한다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>반환형식 (* 식별자) (파라미터형 목록)
</code></pre></div></div>

<p>위와 같은 형식으로 사용한다.</p>

<p><br /></p>
<ul>
  <li><strong>함수 포인터 사용법</strong></li>
</ul>

<p>반환값과 매개변수가 없는 경우</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">print_hello</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Hello, world!</span><span class="se">\\</span><span class="s">n"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)();</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">print_hello</span><span class="p">;</span>
	<span class="n">fp</span><span class="p">()</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-&gt;</span> <span class="err">실행결과</span> <span class="o">:</span> <span class="n">Hello</span><span class="p">,</span> <span class="n">world</span><span class="o">!</span>
</code></pre></div></div>

<p>반환값과 매개변수가 있는 경우</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span> <span class="n">fp</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">sub</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span> <span class="n">fp</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

	<span class="o">-&gt;</span> <span class="err">실행결과</span> <span class="o">:</span><span class="mi">8</span>
			   <span class="mi">2</span>
</code></pre></div></div>
<p><br /></p>
<ul>
  <li><strong>함수 포인터 배열 사용하기</strong></li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;}</span>
<span class="kt">int</span> <span class="nf">sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;}</span>
<span class="kt">int</span> <span class="nf">mul</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;}</span>
<span class="kt">int</span> <span class="nf">div</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">[</span><span class="mi">4</span><span class="p">])(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">//함수 포인터 배열 선언</span>
	
	<span class="n">fp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
	<span class="n">fp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub</span><span class="p">;</span>
	<span class="n">fp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mul</span><span class="p">;</span>
	<span class="n">fp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">div</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span> <span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-&gt;</span> <span class="err">실행결과</span> <span class="o">:</span> <span class="mi">30</span>
			<span class="mi">10</span>
			<span class="mi">200</span>
			<span class="mi">2</span>
</code></pre></div></div>
<p><br /></p>
<ul>
  <li><strong>typedef로 함수 포인터 간소화 하기</strong></li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">PtrFunc</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>

<span class="n">PtrFunc</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
</code></pre></div></div>
<p><br /></p>
<ul>
  <li>
    <p><strong>메모리 해제(free)</strong></p>

    <p>동적 메모리를 할당하면 힙(heap) 메모리의 공간을 할당받는다. 이 공간은 프로그램이 종료될 때까지 보존된다. 따라서 메모리를 할당만 하고 해제를 해주지 않으면 메모리 사용량만 계속 증가하게 된다. 즉 프로그램이 필요하지 않은 메모리를 계속 점유하고 있는 현상을 “메모리 누수(memory leak)”라고 한다. 즉 동적 할당으로 힙 메모리에 공간을 생성해놓은 뒤 회수하지 않으면 프로그램이 실행되는 동안은 그 공간은 계속해서 살아있게 되고 이는 메모리의 낭비를 초래하여 성능 부하를 이르킬 수 있다. 고로 사용하지 않는 메모리는 free함수를 사용하여 꼭 회수해줘야 한다.</p>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>
    <p><strong>2의 보수법</strong></p>

    <p>C언어는 2진 보수 방식을 사용한다.<br />
  첫번째 비트가 0일 때는 양수라는 의미로 2진수를 읽듯이 읽으면 된다. 첫번째 비트가 1일 때는 음수라는 의미로 2진 보수를 역(1을 빼고 1진 보수법 적용)으로 취한 값이 절댓값이 된다.<br />
  예를 들어 8비트의 메모리에 10010001 값이 들어 있다면 첫번째 비트가 1이므로 음수를 의미한다. 절댓값을 계산해보면 10010001 → 10010000 → 01101111로 1 + 2 + 4 + 8 + 32 + 64 = 111이다. 즉 10010001은 -111이다.<br />
  2진 보수 방식에서 8비트(1바이트)로 표현할 때 01111111이 가장 큰 정수이고, 10000000이 가장 작은 정수이다.
<br /></p>
  </li>
  <li>
    <p>큰 자료형 → 작은 자료형 형 변환시 뒤쪽(오른쪽) 비트부터 자른다.
<br /></p>
  </li>
</ul>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="42Seoul" /><category term="42Seoul" /><category term="Libft" /><category term="Archive" /><category term="Library" /><summary type="html"><![CDATA[표준 C 라이브러리(libc)에 있는 함수 및 앞으로 과제를 하면서 유용한 함수들을 구현하고 library로 만든다.]]></summary></entry><entry><title type="html">Makefile 문법 및 예시</title><link href="http://localhost:4000/42seoul/Makefile/" rel="alternate" type="text/html" title="Makefile 문법 및 예시" /><published>2023-10-19T00:00:00+09:00</published><updated>2023-10-19T00:00:00+09:00</updated><id>http://localhost:4000/42seoul/Makefile</id><content type="html" xml:base="http://localhost:4000/42seoul/Makefile/"><![CDATA[<h1 id="0-들어가며">0. 들어가며</h1>
<hr />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>빌드를 쉽게 해주는 make와 Makefile에 대해 알아보자.
</code></pre></div></div>

<p><br />
<br /></p>
<h1 id="1-make란">1. make란?</h1>
<hr />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"의존성 관리”와 “증분 빌드” 기능을 갖춘 빌드 도구.
</code></pre></div></div>

<h2 id="1-1-의존성-관리">1-1. 의존성 관리</h2>

<p>빌드 과정에서 의존성에 따른 빌드 순서는 무척 중요하다.<br />
컴파일, 즉 <code class="language-plaintext highlighter-rouge">a.c</code>로 <code class="language-plaintext highlighter-rouge">a.o</code>를 만들고, <code class="language-plaintext highlighter-rouge">a.o</code>로 <code class="language-plaintext highlighter-rouge">a.out</code>을 만드는 상황을 가정하자.<br />
여기서 <code class="language-plaintext highlighter-rouge">a.out</code>은 <code class="language-plaintext highlighter-rouge">a.o</code>에, <code class="language-plaintext highlighter-rouge">a.o</code>는 <code class="language-plaintext highlighter-rouge">a.c</code>에 의존성이 있다고 할 수 있다.</p>

<div class="notice--primary">
  <p>🔔 <code class="language-plaintext highlighter-rouge">.o</code>파일은 컴파일 과정에서 생성되는 오브젝트 파일입니다.</p>
</div>

<p>이번엔 더 복잡한 상황을 생각해 보자.<br />
만약 프로그램 <code class="language-plaintext highlighter-rouge">exec.out</code>을 만들기 위해 <code class="language-plaintext highlighter-rouge">file1.o</code>, <code class="language-plaintext highlighter-rouge">file2.o</code>, <code class="language-plaintext highlighter-rouge">file3.o</code>가 필요하고 각각은 <code class="language-plaintext highlighter-rouge">file1.c</code>, <code class="language-plaintext highlighter-rouge">file2.c</code>, <code class="language-plaintext highlighter-rouge">file3.c</code>가 필요하다면 의존성 관계는 위의 케이스보다 복잡해진다.</p>

<p>실제로 필요한 프로그램을 코딩할 때는 필요한 소스 파일이 한 두개가 아니고, 이 많은 소스 파일들의 의존성을 직접 파악하기란 쉽지 않다.</p>

<p>실행파일을 만들기 위해 순서를 잘 지키면서 과정을 따라가야 한다. make는 규칙을 정의하면 그 규칙에서 적절한 작업 순서를 찾아서, 그 순서대로 작업을 수행한다. 이것을 <strong>의존성 관리</strong>라고 한다.
<br /></p>
<h2 id="1-2-증분-빌드">1-2. 증분 빌드</h2>

<p>만약 의존성을 파악하지 않고 모든 파일을 다시 컴파일 한다면, 변경된 내용이 없는 <code class="language-plaintext highlighter-rouge">.c</code>파일도 모두 다시 <code class="language-plaintext highlighter-rouge">.o</code> 파일로 만들어야 하므로 컴파일에 불필요한 비용이 든다.</p>

<p>소스 파일에 변경된 내용이 있다면, 변경사항이 있는 소스파일만 <code class="language-plaintext highlighter-rouge">.o</code>파일을 새로 만들어 링킹하는 것이 효율적이다.</p>

<p>즉, 의존성 그래프에서 변경사항을 추적해서 변경이 필요한 것들만 다시 만들면 된다. 하지만 이 과정을 직접 하는 것은 두통을 유발할 수 있다. make는 규칙을 잘 정의하면 무언가가 변경되었을 때, 변경이 필요한 것들만 다시 만들어준다. 이것을 <strong>증분 빌드</strong>라고 한다.</p>

<p><br />
<br /></p>
<h1 id="2-makefile이란">2. Makefile이란?</h1>
<hr />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux상에서 반복적으로 발생하는 컴파일을 쉽게하기 위해서 사용하는 make 프로그램의 설정 파일이다.  
make가 규칙을 정의하면 변경이 필요한 것만 만들어 주는 프로그램이라면, Makefile은 그 규칙을 정의하는 파일이다. &lt;br&gt; ## 2-1. 규칙
</code></pre></div></div>

<p>1-1에서의 예시와 같이 <code class="language-plaintext highlighter-rouge">a.c</code> → <code class="language-plaintext highlighter-rouge">a.o</code> → <code class="language-plaintext highlighter-rouge">a.out</code>의 경우를 생각해 보자.</p>

<p>여기서 <code class="language-plaintext highlighter-rouge">a.c</code>는 사람이 직접 만들 파일이므로 <code class="language-plaintext highlighter-rouge">a.c</code>를 만드는 규칙은 필요하지 않다. 따라서 아래의 두 가지 규칙만을 필요로 한다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">a.c</code> → <code class="language-plaintext highlighter-rouge">a.o</code>
    <ul>
      <li>의존성 : a.c</li>
      <li>만드는 법 : cc -c a.c</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">a.o</code> → <code class="language-plaintext highlighter-rouge">a.out</code>
    <ul>
      <li>의존성 : a.o</li>
      <li>만드는 법 : cc a.o -o a.out</li>
    </ul>
  </li>
</ol>

<p>이를 Makefile 문법으로 나타내면 다음과 같다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">a.o</span><span class="o">:</span> <span class="nf">a.c</span>
	cc <span class="nt">-c</span> a.c

<span class="nl">a.out</span><span class="o">:</span> <span class="nf">a.o</span>
	cc a.o <span class="nt">-o</span> a.out
</code></pre></div></div>

<p><br />
위 코드 블럭의 첫 번째 경우, <code class="language-plaintext highlighter-rouge">a.o</code>는 <code class="language-plaintext highlighter-rouge">target</code>, <code class="language-plaintext highlighter-rouge">a.c</code>는 <code class="language-plaintext highlighter-rouge">dependency</code>, <code class="language-plaintext highlighter-rouge">cc -c a.c</code>는 <code class="language-plaintext highlighter-rouge">command</code>라고 부른다.
<code class="language-plaintext highlighter-rouge">target</code>은 <code class="language-plaintext highlighter-rouge">command</code>가 수행되어서 나온 결과 파일을 의미한다.</p>

<p>우선 <code class="language-plaintext highlighter-rouge">(target1) (target2) …: (dependency1) (dependency2) …</code> 처럼 의존 관계를 정의하고, 다음 줄부터 탭으로 들여쓰기 해서 한 줄씩 차례대로 쓰면 된다.
<br /></p>
<h2 id="2-1-변수">2-1. 변수</h2>

<p><u>파일의 이름을 직접 사용하는 것은 좋지 않다.</u><br />
예를 들어 특정 파일의 이름을 여러번 쓴다면, 파일 이름이 바뀌거나 의존성에 변화가 생길 때마다 그 파일 이름을 쓴 모든 곳을 수정해야 한다. 그 중 한 곳이라도 수정하는 것을 잊으면 makefile을 통해 컴파일을 할 때 문제가 생긴다. 이런 문제를 피하기 위해 변수를 사용할 수 있다.</p>

<p>변수는 <code class="language-plaintext highlighter-rouge">변수명 = 값</code> 으로 정의하고, <code class="language-plaintext highlighter-rouge">$(변수명)</code>으로 사용할 수 있다.
변수 하나에 여러 파일을 할당하고 싶으면 <code class="language-plaintext highlighter-rouge">\</code>로 구분하여 할당 가능하다.
아래 예시 코드의 <code class="language-plaintext highlighter-rouge">CFLAGS</code>처럼 플래그도 할당 가능하다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#변수 정의
</span><span class="nv">CC</span> <span class="o">=</span> cc
<span class="nv">SRCS</span> <span class="o">=</span> file1.c <span class="se">\</span>
		file2.c <span class="se">\</span>
		file3.c
		
<span class="nv">OBJS</span> <span class="o">=</span> file1.o <span class="se">\</span>
		file2.o <span class="se">\</span>
		file3.o
		
<span class="nv">TARGET</span> <span class="o">=</span> a.out

<span class="nv">CFLAGS</span> <span class="o">=</span> <span class="nt">-Wall</span> <span class="nt">-Wextra</span> <span class="nt">-Werror</span>

<span class="c">#변수 사용
</span><span class="nl">$(OBJS)</span><span class="o">:</span> <span class="nf">$(SRCS)</span>
	<span class="p">$(</span>CC<span class="p">)</span> <span class="p">$(</span>CFLAGS<span class="p">)</span> <span class="nt">-c</span> <span class="p">$(</span>SRCS<span class="p">)</span>
<span class="nl">$(TARGET)</span><span class="o">:</span> <span class="nf">$(OBJS)</span>
	<span class="p">$(</span>CC<span class="p">)</span> <span class="p">$(</span>OBJS<span class="p">)</span> <span class="nt">-o</span> <span class="p">$(</span>TARGET<span class="p">)</span>
</code></pre></div></div>

<p>이렇게 변수를 정의해두면 파일명이나 컴파일러가 바뀌어도, 그 파일명이나 컴파일러가 쓰인 모든 곳을 바꿀 필요 없이 변수를 정의한 곳만 바꾸면 된다.
<br /></p>
<h2 id="2-2-자동-변수-패턴-규칙">2-2. 자동 변수, 패턴 규칙</h2>

<p>위처럼 모든 파일마다 규칙을 만들어야 한다면 Makefile을 쓰더라도 길이가 매우 길어질 것이다.
보다 간편한 작성을 위해 make는 자동 변수와 패턴 규칙을 제공한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">자동 변수(Automatic Variables)</code>는 Makefile 안에서 사용할 수 있는, 그때그때 자동으로 만들어지는 변수이다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><strong>자동 변수</strong></th>
      <th style="text-align: center"><strong>의미</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">$@</td>
      <td style="text-align: center">만들려는 파일(target) 이름</td>
    </tr>
    <tr>
      <td style="text-align: center">$&lt;</td>
      <td style="text-align: center">의존성 중 첫번째</td>
    </tr>
    <tr>
      <td style="text-align: center">$^</td>
      <td style="text-align: center">모든 의존성</td>
    </tr>
    <tr>
      <td style="text-align: center">$?</td>
      <td style="text-align: center">현재의 target 파일보다 최근에 갱신된 의존성들</td>
    </tr>
  </tbody>
</table>

<p><br /></p>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#예시
</span><span class="nl">a.o</span><span class="o">:</span> <span class="nf">a.c</span>
	cc <span class="nt">-c</span> <span class="nv">$&lt;</span>
<span class="nl">a.out</span><span class="o">:</span> <span class="nf">a.o</span>
	cc <span class="nv">$^</span> <span class="nt">-o</span> <span class="nv">$@</span>
</code></pre></div></div>
<p><br /></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">패턴 규칙(pattern rule)</code>은 반복되는 패턴을 하나의 규칙으로 단순화시킬 때 사용된다. 패턴 규칙에서는 <code class="language-plaintext highlighter-rouge">wildcard %</code>가 사용된다. <code class="language-plaintext highlighter-rouge">%</code>는 어떠한 것과도 매치될 수 있다(shell에서의 *).</li>
</ul>

<p>이런 자동 변수와 패턴을 결합하면 여러 파일에 대한 규칙을 간단하게 정의할 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">TARGET</span> <span class="o">=</span> a.out

<span class="nl">%.o</span><span class="o">:</span> <span class="nf">%.c            //%.o가 a.o라면 %.c도 a.c가 된다. //모든 .c 파일 → .o 파일</span>
	cc <span class="nt">-c</span> <span class="nv">$&lt;</span>
	
<span class="nl">$(TARGET)</span><span class="o">:</span> <span class="nf">a.o</span>
	cc <span class="nv">$^</span> <span class="nt">-o</span> <span class="nv">$@</span>
</code></pre></div></div>
<p><br /></p>
<h2 id="2-3-내장-변수-내장-규칙">2-3. 내장 변수, 내장 규칙</h2>

<p>GNU Make에는 많은 변수와 규칙이 내장되어있다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">내장 변수</th>
      <th style="text-align: center">의미</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">CC</td>
      <td style="text-align: center">C 컴파일러. default : cc</td>
    </tr>
    <tr>
      <td style="text-align: center">CFLAGS</td>
      <td style="text-align: center">C 컴파일러 플래그</td>
    </tr>
    <tr>
      <td style="text-align: center">CXX</td>
      <td style="text-align: center">C++ 컴파일러. default : c++</td>
    </tr>
    <tr>
      <td style="text-align: center">CXXFLAGS</td>
      <td style="text-align: center">C++ 컴파일러 플래그</td>
    </tr>
    <tr>
      <td style="text-align: center">LDFLAGS</td>
      <td style="text-align: center">링커 플래그</td>
    </tr>
    <tr>
      <td style="text-align: center">CPPFLAGS</td>
      <td style="text-align: center">C 전처리기 플래그. C와 C++에 모두 사용</td>
    </tr>
  </tbody>
</table>

<p><br />
이런 내장 규칙을 활용해서 Makefile의 길이를 쉽게 줄일 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">%.o</span><span class="o">:</span> <span class="nf">%.c</span>
	<span class="p">$(</span>CC<span class="p">)</span> <span class="p">$(</span>TARGET_ARCH<span class="p">)</span> <span class="p">$(</span>CPPFLAGS<span class="p">)</span> <span class="p">$(</span>CFLAGS<span class="p">)</span> <span class="nt">-o</span> <span class="nv">$@</span> <span class="nt">-c</span> <span class="nv">$&lt;</span>
<span class="nl">%.o</span><span class="o">:</span> <span class="nf">%.cpp</span>
	<span class="p">$(</span>CXX<span class="p">)</span> <span class="p">$(</span>TARGET_ARCH<span class="p">)</span> <span class="p">$(</span>CPPFLAGS<span class="p">)</span> <span class="p">$(</span>CXXFLAGS<span class="p">)</span> <span class="nt">-o</span> <span class="nv">$@</span> <span class="nt">-c</span> <span class="nv">$&lt;</span>
<span class="nl">%</span><span class="o">:</span> <span class="nf">%.o</span>
	<span class="p">$(</span>CC<span class="p">)</span> <span class="p">$(</span>TARGET_ARCH<span class="p">)</span> <span class="p">$(</span>LOADLIBES<span class="p">)</span> <span class="p">$(</span>LDLIBS<span class="p">)</span> <span class="p">$(</span>LDFLAGS<span class="p">)</span> <span class="nt">-o</span> <span class="nv">$@</span> <span class="nv">$^</span>
</code></pre></div></div>
<p><br /></p>
<h2 id="2-4-phony-규칙">2-4. .PHONY 규칙</h2>

<p>자주 쓰는 명령어를 make에 등록해서 쓸 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">clean</span><span class="o">:</span>
	<span class="nb">rm</span> <span class="nt">-f</span> <span class="k">*</span>.o
</code></pre></div></div>

<p>하지만 위의 경우, clean이라는 파일이 있으면 make clean이 아무것도 실행하지 않는다.
의존성이 없기 때문에 항상 clean 파일이 최신 상태(변경된 의존성 파일이 없는 경우)라고 생각하기 때문이다.</p>

<p>이런 문제를 해결하기 위해 clean을 가짜를 의미하는 .PHONY 타겟으로 지정할 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">clean</span><span class="o">:</span>
	<span class="nb">rm</span> <span class="nt">-f</span> <span class="k">*</span>.o
	
<span class="nl">.PHONY</span><span class="o">:</span> <span class="nf">clean</span>
</code></pre></div></div>

<p>이렇게 clean을 .PHONY 타겟으로 지정하면 clean이라는 파일이 있어도 make clean이 의도대로 동작한다.
<br /></p>
<h2 id="2-5-매크로-치환macro-substitution">2-5. 매크로 치환(Macro substitution)</h2>

<p>필요에 의해 매크로의 내용을 조금 바꾸어야 할 때가 있다. 매크로 내용의 일부만 바꾸기 위해서는 $(MACRO_NAME:OLD=NEW)와 같은 형식을 이용하면 된다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">MY_NAME</span> <span class="o">=</span> HyunsoonIm
<span class="nv">NEW_NAME</span> <span class="o">=</span> <span class="p">$(</span>MY_NAME:Im<span class="o">=</span>Kim<span class="p">)</span>
</code></pre></div></div>

<p>위의 예제에서는 <code class="language-plaintext highlighter-rouge">Im</code>이란 부분이 <code class="language-plaintext highlighter-rouge">Kim</code>으로 바뀌게 된다. 즉 <code class="language-plaintext highlighter-rouge">YOUR_NAME</code>이란 매크로의 값은 <code class="language-plaintext highlighter-rouge">HyunsoonKim</code>이 된다.</p>

<p>매크로 치환을 활용하면 오브젝트 파일들을 쉽게 정의할 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">SRCS</span> <span class="o">=</span> main.c <span class="se">\</span>
		read.c <span class="se">\</span>
		write.c 
		
<span class="nv">OBJS</span> <span class="o">=</span> <span class="p">$(</span>OBJS:.o<span class="o">=</span>.c<span class="p">)</span>
</code></pre></div></div>

<div class="notice--warning">
  <p>⚠ <code class="language-plaintext highlighter-rouge">OBJS : .o = .c</code>처럼 가독성을 위해 띄어쓰지 말 것.<br />
띄어쓰면 makefile이 인식하지 못한다.</p>
</div>

<p>위 예제의 OBJS에는 SRCS에서 .c가 .o로 바뀐 이름들이 할당된다. 즉 아래와 같다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">OBJS</span> <span class="o">=</span> main.o read.o write.o
</code></pre></div></div>
<p><br /></p>
<h2 id="2-6-addprefix접두어-붙이기">2-6. addprefix(접두어 붙이기)</h2>

<p>목적에 맞게 폴더를 나눠서 작업을 하거나, 소스 파일들을 어떤 폴더에 옮겨야 하는 상황일 때, makefile이 소스 파일의 위치를 인지할 수 있도록 변수 앞에 경로를 붙여줘야 한다.</p>

<p>변수의 앞에 문자를 붙일 때, addprefix를 사용하면 간편하게 작업할 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#예를 들어 main.c, read.c, write.c가 my_files 폴더에 있는 경우,
</span>
<span class="nv">SRCS</span> <span class="o">=</span> main.c <span class="se">\</span>
	read.c <span class="se">\</span>
	write.c

<span class="nv">PATH_PREFIX</span> <span class="o">=</span> ./my_files/

<span class="nv">SRCS_WITH_PATH</span> <span class="o">=</span> <span class="p">$(</span>addprefix <span class="p">$(</span>PATH_PREFIX<span class="p">)</span>, <span class="p">$(</span>SRCS<span class="p">))</span>
</code></pre></div></div>
<p><br />
위 코드는 다음과 같은 의미를 갖는다.</p>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">SRCS_WITH_PATH</span> <span class="o">=</span> ./my_files/main.c <span class="se">\</span>
				./my_files/read.c <span class="se">\</span>
				./my_files/write.c
</code></pre></div></div>
<p><br /></p>
<h2 id="2-7-예시">2-7. 예시</h2>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 디렉토리 구조 : ./headers, ./libft, ./srcs
# headers : pipex.h 헤더파일이 있는 디렉토리
# libft : libft.a 아카이브 파일이 있는 디렉토리
# srcs : main.c, init.c 등 소스파일이 있는 디렉토리
</span>
<span class="nv">SRCS_NAME</span> <span class="o">=</span>	main.c <span class="se">\</span>
		init.c <span class="se">\</span>
		parse.c <span class="se">\</span>
		exec.c <span class="se">\</span>
		redirect.c

<span class="nv">OBJS</span> <span class="o">=</span> <span class="p">$(</span>SRCS:.c<span class="o">=</span>.o<span class="p">)</span>
<span class="nv">PREFIX</span> <span class="o">=</span> ./srcs/
<span class="nv">SRCS</span> <span class="o">=</span> <span class="p">$(</span>addprefix <span class="p">$(</span>PREFIX<span class="p">)</span>, <span class="p">$(</span>SRCS_NAME<span class="p">))</span>
<span class="nv">CC</span> <span class="o">=</span> cc
<span class="nv">CFLAGS</span> <span class="o">=</span> <span class="nt">-Wall</span> <span class="nt">-Wextra</span> <span class="nt">-Werror</span> <span class="nt">-c</span>
<span class="nv">HEADER</span> <span class="o">=</span> ./headers
<span class="nv">NAME</span> <span class="o">=</span> pipex

<span class="nv">LIBFT</span> <span class="o">=</span> ft

<span class="nl">all </span><span class="o">:</span> <span class="nf">$(NAME)</span>


<span class="nl">$(NAME) </span><span class="o">:</span> <span class="nf">$(OBJS)</span>
	<span class="nb">cd </span>libft<span class="p">;</span> make<span class="p">;</span> <span class="nb">cd</span> ..
	<span class="p">$(</span>CC<span class="p">)</span> <span class="p">$(</span>OBJS<span class="p">)</span> <span class="nt">-Llibft</span> <span class="nt">-l</span><span class="p">$(</span>LIBFT<span class="p">)</span> <span class="nt">-o</span> <span class="p">$(</span>NAME<span class="p">)</span> <span class="nt">-I</span> <span class="p">$(</span>HEADER<span class="p">)</span>

<span class="nl">%.o </span><span class="o">:</span> <span class="nf">%.c</span>
	<span class="p">$(</span>CC<span class="p">)</span> <span class="p">$(</span>CFLAGS<span class="p">)</span> <span class="nv">$&lt;</span> <span class="nt">-o</span> <span class="nv">$@</span> <span class="nt">-I</span> <span class="p">$(</span>HEADER<span class="p">)</span>

<span class="nl">clean </span><span class="o">:</span>
	<span class="nb">cd </span>libft<span class="p">;</span> make clean<span class="p">;</span> <span class="nb">cd</span> ..
	<span class="nb">rm</span> <span class="nt">-f</span> <span class="p">$(</span>OBJS<span class="p">)</span>

<span class="nl">fclean </span><span class="o">:</span> <span class="nf">clean</span>
	<span class="nb">cd </span>libft<span class="p">;</span> make fclean<span class="p">;</span> <span class="nb">cd</span> ..
	<span class="nb">rm</span> <span class="nt">-f</span> <span class="p">$(</span>NAME<span class="p">)</span>

<span class="nl">re </span><span class="o">:</span> <span class="nf">fclean all</span>


<span class="nl">.PHONY </span><span class="o">:</span> <span class="nf">clean fclean re</span>
</code></pre></div></div>

<p><br /></p>
<h3 id="reference">📬 <strong>Reference</strong></h3>

<ul>
  <li><a href="http://doc.kldp.org/KoreanDoc/html/GNU-Make/GNU-Make.html#toc3">GNU Make 강좌</a></li>
  <li><a href="https://80000coding.oopy.io/6172b586-8056-4cb1-8c4f-2179009aef3f#6172b586-8056-4cb1-8c4f-2179009aef3f">Makefile, make 기초</a></li>
</ul>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="42Seoul" /><category term="42Seoul" /><category term="Linux" /><category term="Make" /><category term="Makefile" /><summary type="html"><![CDATA[리눅스에서 빌드를 편하게 해주는 Makefile에 대해 알아보자.]]></summary></entry><entry><title type="html">Markdown 사용법</title><link href="http://localhost:4000/etc/Markdown/" rel="alternate" type="text/html" title="Markdown 사용법" /><published>2023-10-18T00:00:00+09:00</published><updated>2023-10-18T00:00:00+09:00</updated><id>http://localhost:4000/etc/Markdown</id><content type="html" xml:base="http://localhost:4000/etc/Markdown/"><![CDATA[<h1 id="0-들어가며">0. 들어가며</h1>
<hr />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Github를 구경하다 보면 .md 파일을 자주 만나게 된다.  
이런 파일들은 Markdown 문법으로 작성된 파일이다.  
본 게시글도 Markdown으로 작성되었다.
</code></pre></div></div>

<p><br />
<br /></p>

<h1 id="1-markdown이란">1. Markdown이란?</h1>
<hr />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Markdown은 일반 텍스트 기반의 경량 마크업 언어이다.
마크업 언어란 태그 등을 이용해 문서나 데이터의 구조 등을 명시하는 언어를 말한다.
Markdown은 일반 텍스트로 서식이 있는 문서를 작성하는 데 사용되며,
일반 마크업 언어에 비해 문법이 쉽고 간단한 것이 특징이다.
</code></pre></div></div>

<p><br />
<br /></p>

<h1 id="2-markdown-문법">2. Markdown 문법</h1>
<hr />

<h2 id="2-1-제목header">2-1. 제목(Header)</h2>
<hr />

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	# 제목 1
	## 제목 2
	### 제목 3
	#### 제목 4
	##### 제목 5
	###### 제목 6
</code></pre></div></div>
<p><br /></p>

<h1 id="제목-1">제목 1</h1>
<h2 id="제목-2">제목 2</h2>
<h3 id="제목-3">제목 3</h3>
<h4 id="제목-4">제목 4</h4>
<h5 id="제목-5">제목 5</h5>
<h6 id="제목-6">제목 6</h6>

<p><br /></p>
<h2 id="2-2-강조emphasis">2-2. 강조(Emphasis)</h2>
<hr />
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>이텔릭체는 <span class="ge">*별표(asterisks)*</span> 또는 _언더바(underscore)_를 사용한다.
볼드체는 <span class="gs">**별표(asterisks)**</span> 또는 __언더바(underscore)__를 사용한다.
이텔릭체와 볼드체는 혼용 가능하다. <span class="gs">**_예를 들면_**</span> 또는 __<span class="ge">*이렇게*__</span>
취소선은 ~~물결표시(tilde)~~를 사용한다.
밑줄은 <span class="nt">&lt;u&gt;</span>abc<span class="nt">&lt;/u&gt;</span>를 사용한다.
</code></pre></div></div>
<p><br /></p>

<p>이텔릭체는 <em>별표(asterisks)</em> 또는 _언더바(underscore)_를 사용한다.<br />
볼드체는 <strong>별표(asterisks)</strong> 또는 <strong>언더바(underscore)__를 사용한다.<br />
이텔릭체와 볼드체는 혼용 가능하다. **<em>예를 들면</em>** 또는 __<em>이렇게</em></strong><br />
취소선은 <del>물결표시(tilde)</del>를 사용한다.<br />
밑줄은 <u>abc</u>를 사용한다.</p>

<p><br /></p>
<h2 id="2-3-목록lists">2-3. 목록(Lists)</h2>
<hr />
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">	1.</span> first
<span class="p">	2.</span> second
<span class="p">		-</span> second.first
<span class="p">		-</span> second.second
<span class="p">	3.</span> third<span class="sb">

	1. first
		- dash
		* asterisks
		+ plus

	- dash
	* asterisks
	+ plus
</span></code></pre></div></div>

<p><br /></p>

<ol>
  <li>first</li>
  <li>second
    <ul>
      <li>second.first</li>
      <li>second.second</li>
    </ul>
  </li>
  <li>
    <p>third</p>
  </li>
  <li>first
    <ul>
      <li>dash</li>
      <li>asterisks</li>
      <li>plus</li>
    </ul>
  </li>
</ol>

<ul>
  <li>dash</li>
  <li>asterisks</li>
  <li>plus</li>
</ul>

<p><br /></p>
<h2 id="2-4-링크links">2-4. 링크(Links)</h2>
<hr />
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nv">GOOGLE</span><span class="p">](</span><span class="sx">https://google.com</span><span class="p">)</span>

<span class="p">[</span><span class="nv">Naver</span><span class="p">](</span><span class="sx">https://naver.com</span> <span class="nn">"링크 설명"</span><span class="p">)</span>  

<span class="p">[</span><span class="nv">상대적 참조</span><span class="p">](</span><span class="sx">../users/hyuim</span><span class="p">)</span>

<span class="p">[</span><span class="nv">Hyuim's Blog</span><span class="p">][</span><span class="ss">My Blog Link</span><span class="p">]</span>

문서 안에서 [참조 링크]를 사용할 수도 있다.

아래와 같이 일반 URL이나 꺾쇠 안의 URL은 자동으로 링크로 인식한다.
구글 홈페이지 : https://google.com
네이버 홈페이지 : <span class="nv">&lt;https://naver.com&gt;</span>

<span class="p">[</span><span class="ss">참조 링크</span><span class="p">]:</span> <span class="sx">https://google.com</span> <span class="nn">"구글로 이동하기"</span>
<span class="p">[</span><span class="ss">Hyuim's Blog</span><span class="p">]:</span> <span class="sx">https://hyun-soon.github.io/</span>
</code></pre></div></div>
<p><br /></p>

<p><a href="https://google.com">GOOGLE</a></p>

<p><a href="https://naver.com" title="링크 설명">Naver</a></p>

<p><a href="../users/hyuim">상대적 참조</a></p>

<p>[Hyuim’s Blog][My Blog Link]</p>

<p>문서 안에서 <a href="https://google.com" title="구글로 이동하기">참조 링크</a>를 사용할 수도 있다.</p>

<p>아래와 같이 일반 URL이나 꺾쇠 안의 URL은 자동으로 링크로 인식한다.</p>

<p>구글 홈페이지 : https://google.com</p>

<p>네이버 홈페이지 : <a href="https://naver.com">https://naver.com</a></p>

<p><br /></p>
<h2 id="2-5-이미지images">2-5. 이미지(Images)</h2>
<hr />
<p>링크와 비슷하지만 <u>앞에 ! 가 붙는다</u>.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>![image name](https://cdn.pixabay.com/photo/2019/12/22/17/13/french-bulldog-4713013_1280.jpg)
</code></pre></div></div>
<p><br /></p>

<p><img src="https://cdn.pixabay.com/photo/2019/12/22/17/13/french-bulldog-4713013_1280.jpg" alt="image name" /></p>

<p><br /></p>
<h2 id="2-6-코드블록code-block">2-6. 코드블록(Code block)</h2>
<hr />
<p>코드를 <strong>```</strong>로 감싼다.<br />
<strong>```</strong> 옆에 언어 종류를 적어주면 해당 언어의 문법에 따라 강조 효과를 줄 수 있다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	```c++
		#include &lt;iostream&gt;
	
		using namespace std;
	
		int main()
		{
			cout &lt;&lt; "abc\n";
			return (0);
		}
	```
</code></pre></div></div>
<p><br /></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
	<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

	<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"abc</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>
<h2 id="2-7-표table">2-7. 표(Table)</h2>
<hr />
<p>헤더 셀을 구분할 때 3개 이상의 <code class="language-plaintext highlighter-rouge">-</code> 가 필요하다.<br />
헤더 셀을 구분하면서 <code class="language-plaintext highlighter-rouge">:</code> 으로 열을 나눌 수 있다.<br />
가장 좌측과 우측에 있는 <code class="language-plaintext highlighter-rouge">|</code> 는 생략 가능하다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| Col1 | Col2 | Col3 |
| --- |: --- |: --- |
| a | b | c |
| d | e | f |
| g | h | i |

Col1 | Col2 | Col3
--- |: --- |: ---
a | b | c
d | e | f
g | h | i
</code></pre></div></div>
<p><br /></p>

<table>
  <thead>
    <tr>
      <th>Col1</th>
      <th>Col2</th>
      <th>Col3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>a</td>
      <td>b</td>
      <td>c</td>
    </tr>
    <tr>
      <td>d</td>
      <td>e</td>
      <td>f</td>
    </tr>
    <tr>
      <td>g</td>
      <td>h</td>
      <td>i</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>Col1</th>
      <th>Col2</th>
      <th>Col3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>a</td>
      <td>b</td>
      <td>c</td>
    </tr>
    <tr>
      <td>d</td>
      <td>e</td>
      <td>f</td>
    </tr>
    <tr>
      <td>g</td>
      <td>h</td>
      <td>i</td>
    </tr>
  </tbody>
</table>

<p><br /></p>
<h2 id="2-8-인용문block-quote">2-8. 인용문(Block Quote)</h2>
<hr />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>인용문 예시
&gt; 이렇게 인용문을 사용할 수 있습니다.

중첩된 인용문
&gt; 중첩된 인용문도
&gt;&gt; 이렇게 하면
&gt;&gt; 사용할 수
&gt;&gt;&gt; 있습니다.
&gt;&gt;&gt; example1
&gt;&gt;&gt; example2
&gt;&gt;&gt; example3
</code></pre></div></div>
<p><br /></p>

<p>인용문 예시</p>

<blockquote>
  <p>이렇게 인용문을 사용할 수 있습니다.</p>
</blockquote>

<p>중첩된 인용문</p>

<blockquote>
  <p>중첩된 인용문도</p>
  <blockquote>
    <p>이렇게 하면
사용할 수</p>
    <blockquote>
      <p>있습니다.<br />
example1<br />
example2<br />
example3</p>
    </blockquote>
  </blockquote>
</blockquote>

<p><br /></p>
<h2 id="2-9-수평선horizontal-rule">2-9. 수평선(Horizontal Rule)</h2>
<hr />
<p>다음의 기호들을 3개씩 사용하면 수평선을 만들 수 있다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
(Hyphens)

***
(Asterisks)

___
(Underscores)
</code></pre></div></div>
<p><br /></p>

<hr />
<p>(Hyphens)</p>

<hr />
<p>(Asterisks)</p>

<hr />
<p>(Underscores)</p>

<p><br /></p>
<h2 id="2-10-줄바꿈line-breaks">2-10. 줄바꿈(Line Breaks)</h2>
<hr />
<p>일반 줄바꿈이 동작하지 않는다면, 2번의 띄어쓰기를 줄바꿈으로 사용할 수 있다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>가나다라  &lt;!--2칸의 공백--&gt;
마바사
</code></pre></div></div>
<p><br /></p>

<p>가나다라  <!--2칸의 공백--><br />
마바사</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Etc" /><category term="Etc" /><category term="Markdown" /><summary type="html"><![CDATA[Markdown 사용법을 알아보자.]]></summary></entry></feed>
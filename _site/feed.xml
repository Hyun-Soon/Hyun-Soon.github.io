<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-10-29T21:32:47+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hyuim’s blog</title><subtitle>Hyuim&apos;s personal blog.</subtitle><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><entry><title type="html">[DevLog] What The Golf 모작 개발일지 #05</title><link href="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf05/" rel="alternate" type="text/html" title="[DevLog] What The Golf 모작 개발일지 #05" /><published>2024-10-29T00:00:00+09:00</published><updated>2024-10-29T00:00:00+09:00</updated><id>http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf05</id><content type="html" xml:base="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf05/"><![CDATA[<h2 id="1-날짜-date">1. 날짜 (Date)</h2>

<p>2024/10/29</p>

<hr />

<h2 id="2-작업-목표-daily-goals">2. 작업 목표 (Daily Goals)</h2>

<p>삼각형 렌더링</p>

<hr />

<h2 id="3-진행-사항-progress">3. 진행 사항 (Progress)</h2>

<ul>
  <li>Vertex Buffer, Index Buffer, 생성</li>
  <li>Vertex Constant Buffer, Pixel Constant Buffer 생성</li>
</ul>

<hr />

<h2 id="4-문제점-및-해결-방법-challenges--solutions">4. 문제점 및 해결 방법 (Challenges &amp; Solutions)</h2>

<hr />

<h2 id="5-다음-단계-next-steps">5. 다음 단계 (Next Steps)</h2>

<ul>
  <li>D3D11_INPUT_ELEMENT_DESC 설정</li>
  <li>vertex shader, pixel shader</li>
</ul>

<hr />

<h2 id="6-회고-reflection">6. 회고 (Reflection)</h2>

<p>확실히 직접 짜보는게 머리에 잘 남고 정리가 잘된다.</p>

<hr />

<h2 id="7-메모-notes">7. 메모 (Notes)</h2>

<ul>
  <li>GPU에 메모리를 할당하는 작업은 <code class="language-plaintext highlighter-rouge">D3D11Device</code>에서 수행한다.</li>
  <li>SUBRESOURCE를 만들 때 일관된 작업을 거쳐야 한다. 예를 들어 Buffer를 만들 때, <code class="language-plaintext highlighter-rouge">D3D11_BUFFER_DESC</code>과 <code class="language-plaintext highlighter-rouge">D3D11_SUBRESOURCE_DATA</code>가 필요하다. DESC로 SUBRESOURCE의 특징을 정의하고, DATA로 실제 데이터가 들어있는 주소를 넘겨준다.</li>
</ul>

<hr />]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="DevLog" /><category term="MyWhatTheGolf" /><category term="개발일지" /><category term="directX" /><category term="WinAPI" /><summary type="html"><![CDATA[What The Golf 모작 개발일지]]></summary></entry><entry><title type="html">\[DevLog\] What The Golf 모작 개발일지 \#04</title><link href="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf04/" rel="alternate" type="text/html" title="\[DevLog\] What The Golf 모작 개발일지 \#04" /><published>2024-10-25T00:00:00+09:00</published><updated>2024-10-25T00:00:00+09:00</updated><id>http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf04</id><content type="html" xml:base="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf04/"><![CDATA[<h2 id="1-날짜-date">1. 날짜 (Date)</h2>

<p>2024/10/25</p>

<hr />

<h2 id="2-작업-목표-daily-goals">2. 작업 목표 (Daily Goals)</h2>

<p>window, directx 클래스 분할</p>

<hr />

<h2 id="3-진행-사항-progress">3. 진행 사항 (Progress)</h2>

<p>임시로 클래스 분할</p>

<hr />

<h2 id="4-문제점-및-해결-방법-challenges--solutions">4. 문제점 및 해결 방법 (Challenges &amp; Solutions)</h2>

<p>directx로 게임을 처음 만들어봐서 그림이 잘 안그려진다. 진행하면서 수시로 리팩토링 해야 할 듯</p>

<hr />

<h2 id="5-다음-단계-next-steps">5. 다음 단계 (Next Steps)</h2>

<p>삼각형 렌더링</p>

<hr />

<h2 id="6-회고-reflection">6. 회고 (Reflection)</h2>

<ul>
  <li>window와 directx를 관리하는 클래스를 각각 만들었다. 나중에 window, device, context 등을 사용해서 게임을 렌더링해야 할텐데, 얘네를 관리하는 클래스에 각자 넣어놔야할지, MyWhatTheGolf 클래스에서 한번에 관리해야 할지 고민이 된다. 다른 게임 코드를 찾아봤는데 몇몇 프로젝트는 window를 전역변수로 해놨다. 일단은 전역변수 쓰지 말고 해보자.</li>
  <li>해상도 값도 웬만하면 MyWhatTheGolf 말고 WindowManager에서 바로 설정하고 싶은데, 나중에 MyWhatTheGolf 클래스에서 사용할 일이 있을 것 같아서 일단 냅두기로 했다.</li>
  <li>프로젝트 진행하면서 구조를 계속 생각해보자.</li>
</ul>

<hr />

<h2 id="7-메모-notes">7. 메모 (Notes)</h2>

<ul>
  <li><a href="https://docs.popekim.com/ko/coding-standards/cpp">Coding Standard</a></li>
</ul>

<hr />]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="DevLog" /><category term="MyWhatTheGolf" /><category term="개발일지" /><category term="directX" /><category term="WinAPI" /><summary type="html"><![CDATA[What The Golf 모작 개발일지]]></summary></entry><entry><title type="html">\[DevLog\] What The Golf 모작 개발일지 \#03</title><link href="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf03/" rel="alternate" type="text/html" title="\[DevLog\] What The Golf 모작 개발일지 \#03" /><published>2024-10-24T00:00:00+09:00</published><updated>2024-10-24T00:00:00+09:00</updated><id>http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf03</id><content type="html" xml:base="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf03/"><![CDATA[<h2 id="1-날짜-date">1. 날짜 (Date)</h2>

<p>2024/10/24</p>

<hr />

<h2 id="2-작업-목표-daily-goals">2. 작업 목표 (Daily Goals)</h2>

<ul>
  <li>DirectX 초기화하기</li>
  <li>Window, DirectX 초기화 코드 클래스로 분할하기</li>
</ul>

<hr />

<h2 id="3-진행-사항-progress">3. 진행 사항 (Progress)</h2>

<p>코드 분할 진행 중</p>

<hr />

<h2 id="4-문제점-및-해결-방법-challenges--solutions">4. 문제점 및 해결 방법 (Challenges &amp; Solutions)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Error LNK2019 unresolved external symbol _main referenced in function "int __cdecl invoke_main(void)" (?invoke_main@@YAHXZ)</code> : main 함수를 wWinMain 함수로 변경했을 때 발생했다. properties -&gt; Linker -&gt; System -&gt; SubSystem에서 Windows로 설정해줘서 해결했다.</li>
</ul>

<hr />

<h2 id="5-다음-단계-next-steps">5. 다음 단계 (Next Steps)</h2>

<ul>
  <li>Window, DirectX 초기화 코드 클래스로 분할하기</li>
  <li>삼각형 렌더링하기</li>
</ul>

<hr />

<h2 id="6-회고-reflection">6. 회고 (Reflection)</h2>

<ul>
  <li>객체 지향 프로그래밍 경험이 없다 보니, Initializer를 어떤 식으로 만드는 게 좋은지 감이 안온다. 인터페이스를 만들고 윈도우, directX intializer에서 이를 기반으로 만들자니 함수에 필요한 인자가 다르고 명시할 인터페이스 내용도 딱히 없다. 일단은 Initializer 객체 안에 window, directX intializer를 멤버 변수로 넣을 것 같다.</li>
  <li>디자인 패턴 공부의 필요성을 느낀다. Component 디자인 패턴을 조사해보자.</li>
</ul>

<hr />

<h2 id="7-메모-notes">7. 메모 (Notes)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SAL</code> : Standard Annotation Language. Microsoft가 Visual C++에서 코드 분석과 정적 코드 검사를 개선하기 위해 도입한 주석 시스템. 코드의 함수, 매개변수, 반환 값에 대한 의도를 명확히 하여, 잠재적인 버그를 미리 감지하고, 안정성을 향상시키는 데 기여한다.</li>
  <li><code class="language-plaintext highlighter-rouge">WINAPI</code> : 매크로로 정의되어 있으며, 실제로는 <code class="language-plaintext highlighter-rouge">__stdcall</code>이라는 호출 규약을 의미한다. __stdcall은 매개변수를 오른쪽에서 왼쪽으로 스택에 push하고, 함수가 반환될 때 호출자가 아니라 함수가 스택을 정리하는 방식이다. 윈도우 API 함수들은 이 규약을 따르기 때문에, 윈도우 API 함수와의 일관성을 유지하기 위해 프로그래머가 작성하는 콜백 함수에도 <code class="language-plaintext highlighter-rouge">WINAPI</code>를 사용하는 경우가 많다.</li>
</ul>

<hr />]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="DevLog" /><category term="MyWhatTheGolf" /><category term="개발일지" /><category term="directX" /><category term="WinAPI" /><summary type="html"><![CDATA[What The Golf 모작 개발일지]]></summary></entry><entry><title type="html">\[DevLog\] What The Golf 모작 개발일지 \#02</title><link href="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf02/" rel="alternate" type="text/html" title="\[DevLog\] What The Golf 모작 개발일지 \#02" /><published>2024-10-23T00:00:00+09:00</published><updated>2024-10-23T00:00:00+09:00</updated><id>http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf02</id><content type="html" xml:base="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf02/"><![CDATA[<h2 id="1-날짜-date">1. 날짜 (Date)</h2>

<p>2024/10/23</p>

<hr />

<h2 id="2-작업-목표-daily-goals">2. 작업 목표 (Daily Goals)</h2>

<p>DirectX 초기화</p>

<hr />

<h2 id="3-진행-사항-progress">3. 진행 사항 (Progress)</h2>

<ul>
  <li>dirverType 설정</li>
  <li>device, context, swapChain 생성</li>
  <li>viewport, rasterizer description 설정</li>
</ul>

<hr />

<h2 id="4-문제점-및-해결-방법-challenges--solutions">4. 문제점 및 해결 방법 (Challenges &amp; Solutions)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">LNK2019 unresolved external symbol D3D11CreateDevice</code> : 헤더 파일은 포함했지만 Direct3D 11 라이브러리가 링커에 제대로 연결되지 않았기 때문에 에러 발생. D3D11CreateDevice 함수는 d3d11.lib라는 라이브러리 파일에 정의되어 있다. 이를 링커에 추가해줘야 한다.
    <ol>
      <li>Project &gt; MyWhatTheGolf Properties &gt; Linker &gt; Input</li>
      <li>Additional Dependencies에 <code class="language-plaintext highlighter-rouge">d3d11.lib</code> 추가</li>
    </ol>
  </li>
</ul>

<hr />

<h2 id="5-다음-단계-next-steps">5. 다음 단계 (Next Steps)</h2>

<ul>
  <li>DirectX 초기화하기</li>
  <li>화면에 삼각형 렌더링하기</li>
</ul>

<hr />

<h2 id="6-회고-reflection">6. 회고 (Reflection)</h2>

<ul>
  <li>강의를 열심히 들어놔서 초반은 무난하게 진행되고 있다.</li>
</ul>

<hr />

<h2 id="7-메모-notes">7. 메모 (Notes)</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">device</code> : GPU에 접근하고, DirectX 리소스(버퍼, 셰이더, 텍스처 등)를 생성하는 데 필요한 객체이다. 하드웨어와 관련된 작업을 설정하고, 이러한 리소스를 관리한다.</li>
  <li><code class="language-plaintext highlighter-rouge">deviceContext</code> : 그래픽 파이프라인의 상태를 설정하고, 렌더링 명령을 실행하는 데 사용된다. 즉, device가 생성한 리소스를 이용해 실제로 GPU에서 작업을 실행하는 역할을 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">COM</code> : Component Object Model. 마이크로소프트가 개발한 소프트웨어 기술로, 다양한 언어와 플랫폼 간의 재사용 가능한 객체를 만든다. 주로 Windows 시스템에서 소프트웨어 모듈 간의 통신을 담당하며, DirectX, Windows의 많은 API에서 핵심적인 기술로 사용된다. COM이 사용된 객체는 접두어 I를 붙이는 것이 관례이다. 예로 ID3D11Device가 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">COM</code>의 주요 개념과 특징
    <ol>
      <li>객체 지향 프로그래밍 모델
        <ul>
          <li>객체 지향을 기반으로 하며, 객체 간의 캡슐화와 상호 운용성을 지원한다. 이를 통해 다양한 애플리케이션이나 라이브러리가 독립적으로 개발된 객체들을 사용할 수 있다. COM 객체는 인터페이스를 통해 서로 상호작용한다. 이는 COM이 객체와 상호작용하는 유일한 방법이다.</li>
        </ul>
      </li>
      <li>언어와 플랫폼 간의 상호 운용성
        <ul>
          <li>COM은 여러 프로그래밍 언어(C, C++ 등)로 개발된 모듈들이 서로 호환될 수 있도록 설계되었다. 이를 위해 바이너리 수준에서 상호작용하며, 각기 다른 언어로 작성된 프로그램들이 함께 사용될 수 있다.</li>
        </ul>
      </li>
      <li>인터페이스 기반 설계
        <ul>
          <li>COM은 인터페이스 기반 설계되었으며, 객체는 직접 사용되지 않고 인터페이스를 통해 사용된다.</li>
          <li>인터페이스는 그 객체가 제공하는 기능의 집합을 나타내며, 구현에서 독립적이다. 즉, 클라이언트는 객체의 내부 구현을 알 필요 없이, 해당 인터페이스만 알면 객체를 사용할 수 있다.</li>
          <li>모든 COM 객체는 기본적으로 IUnknown 인터페이스를 구현해야 하며, 이를 통해 참조 카운트 및 인터페이스 쿼리를 관리한다.</li>
        </ul>
      </li>
      <li>참조 카운팅과 메모리 관리
        <ul>
          <li>COM은 참조 카운팅을 통해 메모리 관리를 자동화한다. 각 COM 객체는 자신을 참조하는 클라이언트의 수를 관리하며, 더 이상 참조하는 클라이언트가 없을 때 자동으로 메모리를 해제한다.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ComPtr</code> : DirectX와 같은 COM 기반 API에서 자주 사용되는 스마트 포인터로, Microsoft의 Windows Runtime C++ Template Library(WRL)에 포함되어 있다. ComPtr은 COM 객체의 참조 카운트 관리와 메모리 관리를 자동화하는 데 사용된다.</li>
  <li><code class="language-plaintext highlighter-rouge">ComPtr</code>의 주요 특징과 기능
    <ol>
      <li>참조 카운트 관리 자동화
        <ul>
          <li>COM 객체는 IUnknown::AddRef()와 IUnknown::Release()를 통해 참조 카운트를 관리한다. ComPtr을 사용하면 직접 AddRef나 Release를 호출할 필요 없이, 객체의 생명 주기를 자동으로 관리한다. 따라서 메모리 누수가 발생할 위험이 없다(스마트 포인터 기능).</li>
        </ul>
      </li>
      <li>메서드 호출을 위한 포인터 자동 변환
        <ul>
          <li>ComPtr은 내부적으로 관리하는 실제 포인터를 제공하는 <code class="language-plaintext highlighter-rouge">operator-&gt;()</code>와 <code class="language-plaintext highlighter-rouge">opreator*()</code>를 오버로딩하여, 일반 포인터처럼 COM 객체의 메서드를 호출할 수 있게 해준다.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">RenderTargetView</code> : RTV는 DirectX 11에서 렌더링할 때 화면에 출력할 수 있는 버퍼를 관리하는 중요한 개념이다. “GPU가 렌더링한 결과물을 출력할 대상”을 정의하는 인터페이스로, 주로 back buffer나 텍스처 같은 리소스에 그려진 데이터를 화면에 표시하거나 다른 후처리 단계에서 사용할 수 있게 해준다. DirectX에서 모든 렌더링은 특정 대상에 그려지며, 그 대상이 바로 render target이다. 일반적으로 render target은 swap chain의 back buffer이거나, 특정 texture2D일 수 있다. 즉 render target은 화면에 렌더링하거나 중간 결과물인 텍스처에 렌더링 하기 위해 사용될 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">Depth-Stencil Buffer</code> : 3D 그래픽스에서 렌더 타겟과 함께 사용하는 것이 depth-stencil buffer이다. 이는 픽셀의 깊이 정보를 저장하여, 깊이에 따른 가려짐 효과를 구현한다. 일반적으로 렌더 타겟과 스텐실 버퍼는 함께 바인딩된다.</li>
</ul>

<hr />]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="DevLog" /><category term="MyWhatTheGolf" /><category term="개발일지" /><category term="directX" /><category term="WinAPI" /><summary type="html"><![CDATA[What The Golf 모작 개발일지]]></summary></entry><entry><title type="html">\[DevLog\] What The Golf 모작 개발일지 \#01</title><link href="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf01/" rel="alternate" type="text/html" title="\[DevLog\] What The Golf 모작 개발일지 \#01" /><published>2024-10-22T00:00:00+09:00</published><updated>2024-10-22T00:00:00+09:00</updated><id>http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf01</id><content type="html" xml:base="http://localhost:4000/devlog/mywhatthegolf/MyWhatTheGolf01/"><![CDATA[<h2 id="1-날짜-date">1. 날짜 (Date)</h2>

<p>2024/10/22</p>

<hr />

<h2 id="2-작업-목표-daily-goals">2. 작업 목표 (Daily Goals)</h2>

<p>window 창 띄우기</p>

<hr />

<h2 id="3-진행-사항-progress">3. 진행 사항 (Progress)</h2>

<p>window 창 띄우기 성공</p>

<hr />

<h2 id="4-문제점-및-해결-방법-challenges--solutions">4. 문제점 및 해결 방법 (Challenges &amp; Solutions)</h2>

<hr />

<h2 id="5-다음-단계-next-steps">5. 다음 단계 (Next Steps)</h2>

<p>DirectX 초기화하기</p>

<hr />

<h2 id="6-회고-reflection">6. 회고 (Reflection)</h2>

<ul>
  <li>Windows 운영 체제의 동작 방식과 용어들이 생소하다. 틈틈이 보면서 익숙해져야겠다.</li>
  <li>HINSTANCE가 처음엔 PID인줄 알았는데 약간 다른 것 같다.</li>
</ul>

<hr />

<h2 id="7-메모-notes">7. 메모 (Notes)</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">WNDPROC</code> : “Window Procedure”의 약자로, 윈도우 창과 관련된 이벤트 메시지(입력, 윈도우 크기 조정, 페인팅 등)를 처리하는 콜백 함수. 운영체제가 다양한 메시지를 해당 창의 프로시저로 보내면, 프로시저는 그 메시지를 해석하여 적절한 동작을 수행한다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PID vs HINSTANCE</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">PID</code> : 각각의 실행 중인 프로세스에게 운영 체제가 배정하는 고유한 ID. 특정 프로세스를 관리하거나 추적하기 위해 사용된다(시그널, 종료, 모니터링 등).</li>
      <li><code class="language-plaintext highlighter-rouge">HINSTANCE</code> : Handle to an Instance. 애플리케이션의 현재 인스턴스에 대한 핸들을 의미하며, 실행되고 있는 코드가 적재된 메모리 주소를 가리킨다. 애플리케이션이 실행되면 운영체제는 instance handle을 제공한다. 이 핸들을 통해 애플리케이션의 resource(아이콘, 창 등)들을 관리할 수 있다.</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Handle</code> : Windows에서 handle은 운영체제에 의해 관리되는 resource 또는 object에 대한 abstract reference이다. 고유한 식별자로서, system resource의 자세한 구현을 몰라도 프로그램이 다양한 system resource와 상호작용할 수 있게 해준다. HINSTANCE, HWND 등이 있다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">SOLID 원칙</code>
    <ul>
      <li>S : Single Responsibility Principle, 하나의 클래스는 하나의 책임만 가져야 한다.</li>
      <li>O : Open/Closed Principle, 소프트웨어의 구성 요소는 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.</li>
      <li>L : Liskov Subsitution Principle, 자식 클래스는 부모 클래스에서 정의한 기능을 모두 충족해야 하며, 부모 클래스로 대체가능해야 한다.</li>
      <li>I : Interface Segregation Principle, 클라이언트가 필요하지 않은 기능에 의존하지 않도록 인터페이스를 작고 구체적으로 나눠야 한다.</li>
      <li>D : Dependency Inversion Principle, 구체적인 클래스에 의존하는 것이 아니라, 인터페이스나 추상 클래스에 의존함으로써 유연성을 높여야 한다.</li>
    </ul>
  </li>
</ul>

<hr />]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="DevLog" /><category term="MyWhatTheGolf" /><category term="개발일지" /><category term="directX" /><category term="WinAPI" /><summary type="html"><![CDATA[What The Golf 모작 개발일지]]></summary></entry><entry><title type="html">\[Graphics\] Shader(셰이더)란?</title><link href="http://localhost:4000/graphics/Shader/" rel="alternate" type="text/html" title="\[Graphics\] Shader(셰이더)란?" /><published>2024-07-16T00:00:00+09:00</published><updated>2024-07-16T00:00:00+09:00</updated><id>http://localhost:4000/graphics/Shader</id><content type="html" xml:base="http://localhost:4000/graphics/Shader/"><![CDATA[<p><br /></p>
<h1 id="0-shader란">0. Shader란?</h1>
<p><br />
컴퓨터 그래픽스 분야에서 <code class="language-plaintext highlighter-rouge">Shader</code>는 주로 GPU에서 렌더링 효과를 계산하는 데 사용되는 프로그램을 말한다.</p>

<p>우리의 모니터에 어떤 3D 모델을 띄운다고 하자. 이 3D 모델은 여러개의 삼각형으로 구성되어 있다. 이 모델을 렌더링하기 위해 각 삼각형의 꼭짓점(vertex)들을 원하는 위치로 이동, 회전한 후 그 위치에서의 빛의 세기, 각도 등을 계산한다. 이런 과정등을 통해 화면에서 각 픽셀의 색을 결정한 후 우리 화면에 렌더링한다. 이러한 그래픽스 파이프라인에서 각각의 계산을 수행하는 프로그램들을 Shader라고 한다.</p>

<p>아래는 Direct3D의 그래픽 파이프라인이다. Shader를 거치며 최종적인 픽셀의 색을 결정하는 과정을 확인할 수 있다. 가장 일반적으로 사용되는 Shader는 <code class="language-plaintext highlighter-rouge">Vertex Shader</code>와 <code class="language-plaintext highlighter-rouge">Pixel Shader</code>다.</p>

<p><img src="https://github.com/user-attachments/assets/9ab9a459-a062-4d78-a9c0-2ef8b1fb37b9" alt="image" /></p>

<p><a href="https://learn.microsoft.com/ko-kr/windows/uwp/graphics-concepts/graphics-pipeline">이미지 출처</a>
<br /></p>
<h1 id="1-vertex-shader">1. Vertex Shader</h1>
<p><br />
위에서는 vertex를 삼각형의 꼭짓점으로만 설명했지만, 실제로는 위치를 나타내는 x, y, z값 뿐만 아니라 색상(r, g, b), 텍스쳐, 조명 정보 등이 될 수도 있다.</p>

<p>Vertex Shader는 3D 모델의 각 vertex를 처리한다. 모델의 정점 데이터를 입력받아 이동, 변환, 꼭짓점 별 조명 등의 작업을 수행한 후 출력한다. 단, 기존의 정점을 지우거나 새로운 정점을 추가하는 등의 작업은 할 수 없다.</p>

<p><br /></p>
<h1 id="2-pixel-shader">2. Pixel Shader</h1>
<p><br />
Pixel Shader는 렌더링 될 각 픽셀들의 색을 계산한다. 텍스쳐로부터 색을 읽어오거나, 빛을 적용하는 것, bump mapping, 그림자, 반사광, 투명처리 등의 기능을 수행한다.</p>

<p>이 Shader는 각각의 픽셀들이 렌더링될 때마다 수행되기 때문에, 다른 픽셀들과 아무런 연관이 없다. 따라서 주변의 픽셀이나 그리는 도형에 대한 정보를 알 수 없기 때문에 스스로 매우 복잡한 효과를 만들어 낼 수는 없다.</p>

<p>Z-Buffer(z축 깊이 정보를 담은 버퍼)를 사용하기도 한다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Graphics" /><category term="Shader" /><category term="Graphics" /><summary type="html"><![CDATA[Shader를 알아보자.]]></summary></entry><entry><title type="html">\[C++\] 클래스의 복사를 막는 방법</title><link href="http://localhost:4000/cpp/PreventCopyingClass.md/" rel="alternate" type="text/html" title="\[C++\] 클래스의 복사를 막는 방법" /><published>2024-07-11T00:00:00+09:00</published><updated>2024-07-11T00:00:00+09:00</updated><id>http://localhost:4000/cpp/PreventCopyingClass.md</id><content type="html" xml:base="http://localhost:4000/cpp/PreventCopyingClass.md/"><![CDATA[<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TempClass</span> <span class="p">{};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">TempClass</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">TempClass</span> <span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// copy constructor</span>
	<span class="n">TempClass</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// copy assignment operator</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">copy constructor</code>와 <code class="language-plaintext highlighter-rouge">copy assignment operator</code>가 선언되어있지 않은 클래스 <code class="language-plaintext highlighter-rouge">TempClass</code>가 있다. main문에서 TempClass의 copy constructor와 copy assignment operator를 호출하고 있기 때문에, 컴파일러는 이를 알아서 정의해 버린다. 따라서 구현하지 않는다고 해서 클래스의 복사를 막을 수는 없다. 그렇다면 어떻게 복사를 막을까?</p>

<p>이들을 private으로 정의하는 방법을 먼저 떠올릴 수 있을 것이다. 클래스 밖에서 TempClass를 복사하려고 할 때 private으로 되어 있으면 호출이 불가능하다. 그러나 여전히 클래스의 멤버 함수나 friend 함수가 호출할 수 있는 위험이 있다. 이런 위험까지 방지하려면 private에 선언만 해놓으면 된다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TempClass</span>
<span class="p">{</span>
	<span class="nl">private:</span>
		<span class="n">TempClass</span><span class="p">(</span><span class="k">const</span> <span class="n">TempClass</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
		<span class="n">TempClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TempClass</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>copy constructor와 copy assignment operator가 선언이 되어 있기 때문에 컴파일러가 이들을 생성하지는 않지만, 구현부가 없기 때문에 링크 과정에서 에러가 발생할 것이다.</p>

<p class="notice--primary">🔔 <strong>링크 과정에서 에러가 발생하는 이유</strong><br />
컴파일러는 코드를 어셈블리어로 바꿔주는 역할을 한다. 이 때, 컴파일러가 굳이 다른 소스 파일의 구현까지 자세히 알 필요는 없기 때문에 컴파일 과정에서는 문제가 발생하지 않는다. 하지만 object file들을 연결하며 하나의 프로그램을 만드는 링크 과정에서는 실제의 동작을 알아야 하기 때문에 구현이 없는 경우 에러가 발생한다.</p>

<p>에러 시점을 링크 과정이 아닌 컴파일 과정으로 앞당기고 싶다면 부모 클래스를 활용해야 한다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Uncopyable</span>
<span class="p">{</span>
	<span class="nl">protected:</span>
		<span class="n">Uncopyable</span><span class="p">()</span> <span class="p">{}</span>
		<span class="o">~</span><span class="n">Uncopyable</span><span class="p">()</span> <span class="p">{}</span>

	<span class="k">private</span><span class="o">:</span>
		<span class="n">Uncopyable</span><span class="p">(</span><span class="k">const</span> <span class="n">Uncopyable</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
		<span class="n">Uncopyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Uncopyable</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">TempClass</span> <span class="o">:</span> <span class="k">private</span> <span class="n">Uncopyable</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</code></pre></div></div>

<p>위 코드에서 Uncopyable 클래스를 TempClass에서 상속 받는다. copy constructor, copy assignment operator가 없는 TempClass에 대해 컴파일러가 이들을 생성할 때, 부모 클래스의 것들과 호환이 되도록 생성하려고 할 것이다. 하지만 부모클래스에서 이들이 private으로 선언되어 있기 때문에 TempClass에서는 접근할 방법이 없고, 결국 컴파일러가 에러를 뱉게 된다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Cpp" /><category term="Cpp" /><summary type="html"><![CDATA[컴파일러가 자동으로 생성하는 복사 생성자, 복사 할당 연산자를 제한하는 방법을 알아보자]]></summary></entry><entry><title type="html">\[Graphics\] Baycentric coordinate(무게 중심 좌표계)</title><link href="http://localhost:4000/graphics/BaycentricCoordinate/" rel="alternate" type="text/html" title="\[Graphics\] Baycentric coordinate(무게 중심 좌표계)" /><published>2024-07-10T00:00:00+09:00</published><updated>2024-07-10T00:00:00+09:00</updated><id>http://localhost:4000/graphics/BaycentricCoordinate</id><content type="html" xml:base="http://localhost:4000/graphics/BaycentricCoordinate/"><![CDATA[<p><br /></p>
<h1 id="1-linear-interpolation선형-보간법">1. Linear Interpolation(선형 보간법)</h1>
<p><br />
선형 보간법(Linear Interpolation)은 양 끝점의 위치가 주어졌을 때 그 사이의 한 위치를 계산하는 방법이다.</p>

<p><img src="https://github.com/Hyun-Soon/Hyun-Soon.github.io/assets/66724166/04b8273d-0b22-499a-8e63-d23c18bc9aba" alt="line" /></p>

<p><a href="https://ko.wikipedia.org/wiki/%EC%84%A0%ED%98%95_%EB%B3%B4%EA%B0%84%EB%B2%95">이미지 출처</a></p>

<p>2차원 공간 상의 점 \(p1(x_1, y_1), p2(x_2, y_2)\) 사이에 있는 p의 위치를 알고 싶다고 하자.</p>

<p>p1과 p2 사이의 거리를 정규화하여 1로 놓으면,</p>

\[d1 = α, d2 = 1 - α(0&lt;=α&lt;=1)\]

<p>라고 할 수 있다.</p>

<p>d1의 길이가 커질수록 p는 p2에 가까워지고, d2의 길이가 커질수록 p는 p1에 가까워진다.
α를 가중치로 생각해 보면 다음과 같이 나타낼 수 있다.</p>

\[p = (1 - α)p1 + αp2\]

<p>아래와 같이 벡터로 이해할 수도 있다.</p>

<p><img src="https://github.com/Hyun-Soon/Hyun-Soon.github.io/assets/66724166/8b0bd221-c9fe-43d1-969b-8d5e04213b43" alt="linear_interpolation" /></p>

<p>가중치의 합이 1이 넘어버리면 직선보다 위에 p가 위치하게 된다.</p>

<p><br /></p>
<h1 id="2-baycentric-coordinate무게-중심-좌표계">2. Baycentric coordinate(무게 중심 좌표계)</h1>
<p><br />
이번엔 세 점으로 이루어진 삼각형 내의 점을 생각해 보자.</p>

<p><img src="https://github.com/Hyun-Soon/Hyun-Soon.github.io/assets/66724166/69895098-25e6-4a65-9d4b-8cac09515b14" alt="area" /></p>

<p><a href="https://blog.naver.com/gt7461/220583985623">이미지 출처</a></p>

<p>1차원 직선에서 두 점 사이에 있는 점의 좌표를 직선간의 비율로 구했듯이, 2차원 평면에서 세 점 사이의 좌표를 넓이의 비율로 구할 수 있다.</p>

<p>삼각형 전체의 넓이를 S(= s1 + s2 + s3)라고 하면 점 A, B, C로 이루어진 삼각형 내의 점 P의 좌표는 다음과 같다.</p>

\[P = w_a*A + w_b * B + w_c * C\]

\[(w_a = s_2 / S, w_b = s_3 / S, w_c = s_1 / S)\]

<p>마찬가지로 삼각형도 3개의 점을 벡터로 이어서 생각해볼 수 있다. 각 가중치가 1/3이면 벡터의 1/3씩 더해서 삼각형의 중앙에 p가 위치할 것이고, 가중치의 합이 1을 넘어가면 삼각형보다 위에 p가 위치할 것이다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Graphics" /><category term="LinearInterpolation" /><category term="BaycentricCoordinate" /><category term="Graphics" /><summary type="html"><![CDATA[Interpolation, Baycentric coordinate에 대해 알아보자.]]></summary></entry><entry><title type="html">\[수치해석\] 뉴턴-랩슨 방법(Newton-Raphson method)</title><link href="http://localhost:4000/numerical-analysis/newton-raphson-method/" rel="alternate" type="text/html" title="\[수치해석\] 뉴턴-랩슨 방법(Newton-Raphson method)" /><published>2024-07-01T00:00:00+09:00</published><updated>2024-07-01T00:00:00+09:00</updated><id>http://localhost:4000/numerical-analysis/newton-raphson-method</id><content type="html" xml:base="http://localhost:4000/numerical-analysis/newton-raphson-method/"><![CDATA[<h1 id="0-newtons-method-newton-raphson-method란">0. Newton’s method, Newton-Raphson method란?</h1>

<p>Newton’s method 및 Newton-Raphson method 라고 불리는 이 방법은 실숫값 함수의 영점을 근사하는 방법 중 하나이다.</p>

<h1 id="1-뉴턴-랩슨-방법의-이해">1. 뉴턴-랩슨 방법의 이해</h1>

<p>제곱근을 구하는 문제를 생각해보자.</p>

<p><img src="https://github.com/Hyun-Soon/Hyun-Soon.github.io/assets/66724166/4b50df00-cdbe-4552-80b6-1561a6176d63" alt="Newton-Raphson_Method1" /></p>

\[f(x)=x^2-N\]

<p>위의 방정식에서 $f(x) = 0$이 되는 $x$값을 구하면 N의 제곱근을 구할 수 있다.</p>

<p>답을 모르는 상황에서 임의의 $x = a_1$에 대해 $f(a_1)$와 $f’(a_1)$를 구해보자.</p>

<p><img src="https://github.com/Hyun-Soon/Hyun-Soon.github.io/assets/66724166/a4af5e61-ff9e-4166-bb0e-cccbbce52cc3" alt="Newton-Raphson_Method2" /></p>

<p>$f’(a)$이 $x = a$에서 $f(x)$의 기울기임을 생각해보자.
$f(a) &gt; 0$, $f’(a) &gt; 0$ 일 때 $f(x) = 0$이 되는 $x$값은 $a$보다 작다는 것을 알 수 있다.</p>

<p>위 그림에서 $a_1$을 통해 $a_2$를 찾을 수 있고, 이런 식으로 접선을 그려 반복하면 실제 해에 가까워지는 것을 확인할 수 있다.</p>

\[a_2=a_1-\frac{f(a_1)}{f'(a_1)}\]

\[(\because f'(a_1)=\frac{f(a_1)}{a_1-a_2})\]

<p><br />
이런 식으로 해에 가까운 $x$값을 찾다가 $x$의 변화량이 일정값 이하로 작아지면, 즉 $|a_1-a_2|$ &lt; value(매우 작은 값)이 되면 $a_2$을 해로 상정한다.</p>

<p>즉, 뉴턴 방법(Newton’s method)는 임의의 $x$값에서 접선을 그려 해당 접선과 $x$축이 만나는 곳으로 점점 x값을 옮기며 점진적으로 해를 찾는 방법이다.</p>

<h1 id="2-뉴턴-랩슨-방법의-제약">2. 뉴턴-랩슨 방법의 제약</h1>

<p>간단하지만 효과적인 이 방법에는 제약이 존재한다.</p>

<ul>
  <li>해가 없는 경우, 당연히 해를 찾을 수 없다.</li>
  <li>$f(x)$가 연속이고 미분 가능해야 한다.</li>
  <li>해가 여러개인 경우, 뉴턴-랩슨 방법은 그 중 하나의 해를 찾아줄 뿐이며 초기값 $a_1$을 어떻게 설정하느냐에 따라 해가 달라질 수 있다.</li>
</ul>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="numerical-analysis" /><category term="Newton-Method" /><category term="Newton-Raphson-Method" /><summary type="html"><![CDATA[뉴턴-랩슨 방법을 알아보자.]]></summary></entry><entry><title type="html">\[42Seoul\] Philosophers 가이드</title><link href="http://localhost:4000/42seoul/Philosophers/" rel="alternate" type="text/html" title="\[42Seoul\] Philosophers 가이드" /><published>2023-12-06T00:00:00+09:00</published><updated>2023-12-06T00:00:00+09:00</updated><id>http://localhost:4000/42seoul/Philosophers</id><content type="html" xml:base="http://localhost:4000/42seoul/Philosophers/"><![CDATA[<h1 id="0-과제-설명">0. 과제 설명</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dining Philosopher 문제를 해결해 본다. multi threads, multi processors 환경에서 발생할 수 있는 race condition 및 deadlock을 방지한다.
</code></pre></div></div>

<p><br /></p>

<h1 id="1-필요-개념">1. 필요 개념</h1>
<p><br /></p>

<h2 id="1-1-공유-자원">1-1. 공유 자원</h2>

<p>여러 프로세스 또는 스레드가 공동으로 사용하는 변수, 메모리, 파일 등의 자원이나 변수를 의미한다.</p>

<p><br /></p>

<h2 id="1-2-thread">1-2. Thread</h2>

<p>thread란 프로세스 내에서 작업이 실행되는 흐름의 단위를 말한다. 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행하며, 두 개 이상의 스레드를 가지는 경우를 멀티 스레드(multi threads)라고 한다. 아래 코드를 보자.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">increase_a</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">a</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">pthread_t</span> <span class="n">th1</span><span class="p">,</span> <span class="n">th2</span><span class="p">;</span>

	<span class="err"></span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">increase_a</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="err"></span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">increase_a</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">pthread_join</span><span class="p">(</span><span class="n">th1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">pthread_join</span><span class="p">(</span><span class="n">th2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"a : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>pthread_create함수를 통해 실행 흐름의 단위인 스레드를 2개 만들었다. 각각의 thread는 increase_a 함수를 실행하고 pthread_join을 통해 종료될 것이다. 즉 increase_a 함수가 2번 실행된다는 것이고 printf의 결과로 2000000이 출력될 것을 예상할 수 있다.</p>

<p><br /></p>

<h2 id="1-3-race-condition">1-3. Race Condition</h2>

<p>1-2의 코드에서 우리는 결과가 2000000일 것이라고 예상했다. 하지만 실제로 코드를 실행해보면 출력이 2000000이 아닌 경우가 종종 발생한다. 왜 이런 현상이 발생할까?</p>

<p>각각의 스레드가 a++을 한번씩 실행한다고 생각해보자.</p>

<table>
  <thead>
    <tr>
      <th>Thread 1</th>
      <th>Thread 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>메모리에서 CPU로 a 값을 가져온다 — a = 0</td>
      <td> </td>
    </tr>
    <tr>
      <td>a++ — a = 1</td>
      <td>메모리에서 CPU로 a 값을 가져온다 — a = 0</td>
    </tr>
    <tr>
      <td>a 값을 메모리에 업데이트 해준다 — a = 1</td>
      <td>a++ — a = 1</td>
    </tr>
    <tr>
      <td> </td>
      <td>a 값을 메모리에 업데이트 해준다 — a = 1</td>
    </tr>
  </tbody>
</table>

<p>a++이 총 2번 실행이 됐지만, thread 1이 값을 연산 후 메모리에 업데이트 해주기 전에 thread 2가 값을 확인했기 때문에 a = 1이 되는 상황이 발생했다. Race Condition은 이렇게 공유 자원에 대해 여러 프로세스 또는 스레드들이 동시에 접근을 시도하여 결과에 영향을 줄 수 있는 상태를 말한다.</p>

<p><br /></p>

<h2 id="1-4-critical-section">1-4. Critical Section</h2>

<p>critical section이란 병렬 프로그래밍에서 스레드 또는 프로세스가 동시 접근을 해서는 안되는 코드 영역을 말한다. critical section의 목적은 공유 자원에 대한 동시 접근으로 인해 발생할 수 있는 race condition을 방지하고 데이터 일관성을 유지하는 것이다. 이를 위해서는 상호 배제(mutual exclusion) 매커니즘이 필요하며 대표적인 방법으로 mutex와 semaphore가 있다.</p>

<p><br /></p>

<h2 id="1-5-mutex">1-5. Mutex</h2>

<p>critical section에 동시 접근을 막기 위한 기법 중 하나로 <strong>Mut</strong>ual <strong>Ex</strong>clusion을 줄여서 Mutex라고 부른다.
mutex는 lock과 unlock 두 가지 기능을 가진다.
공유 변수 a에 대한 동시 접근을 막고 싶다면 다음과 같이 mutex를 사용할 수 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="c1">//critical section 진입</span>
<span class="n">mutex_lock</span><span class="p">();</span>
<span class="n">a</span><span class="o">++</span><span class="p">;</span>
<span class="n">mutex_unlock</span><span class="p">();</span>
<span class="c1">//critical section 탈출</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="p">.</span>
</code></pre></div></div>

<p>thread 1이 mutex_lock을 실행하고 다음 줄인 a++로 갔을 때, thread 2가 mutex_lock()에 접근한다면 thread 2는 코드를 더 이상 진행하지 못하고 mutex_lock()에 멈춰있게 된다. thread 1이 a++ 실행 후 mutex_unlock()까지 실행해야 thread 2는 비로소 mutex_lock()을 실행하고 a++로 넘어가게 된다.</p>

<p>이런 식으로 mutex를 사용하면 한 스레드가 공유 변수에 접근했을 때 다른 스레드들의 접근을 배제함으로써 race condition을 방지하고 원자성을 보장할 수 있다.</p>

<p><br /></p>

<h2 id="1-6-semaphore">1-6. Semaphore</h2>

<p>mutex는 한 스레드가 critical section에 진입하면 다른 모든 스레드의 접근을 막는 방식으로 작동한다. 반면 Semaphore는 한 스레드가 critical section에 진입했더라도 가용할 수 있는 자원이 남아 있으면, 남은 수 만큼의 스레드의 접근을 허용한다.</p>

<p>백화점 화장실을 떠올려 보자.</p>

<ol>
  <li>변기를 사용할 수 있는 칸이 5칸이 있다(어떤 공유 변수를 동시에 5개의 스레드까지 사용해도 상관 없는 경우 semaphore의 초기 값을 5로 초기화한다).</li>
  <li>한 명이 첫 번째 칸에 들어간다면 남아 있는 사용가능한 칸은 4칸이 있다(어떤 스레드가 공유 변수에 접근할 때 semaphore 값을 하나 내려서 4로 만든 뒤 공유 변수를 사용한다).</li>
  <li>다음 사람이 화장실에 들어왔을 때 남은 4칸 중 하나에 들어갈 것이고 남은 칸은 3칸이 된다(다른 스레드가 공유 변수에 접근할 때 semaphore 값을 하나 내려서 3으로 만든 뒤 공유 변수를 사용한다).</li>
  <li>한 명이 볼일이 끝나서 칸에서 나오게 되면 사용 가능한 칸은 1칸이 늘어난다(스레드 하나가 공유 변수 사용이 끝났으면 semaphore 값을 하나 올린다).</li>
  <li>모든 칸을 사용 중이라면 남은 칸은 0칸이 되고, 이후에 오는 사람은 한명이 나올 때 까지 기다려야 한다(스레드가 공유 변수에 접근하려고 할 때 해당 변수의 semaphore 값이 0이라면 양수가 될 때까지 기다려야 한다).</li>
</ol>

<p>semaphore는 위와 같은 식으로 공유 변수에 대한 접근을 제한한다.</p>

<p><br /></p>

<h2 id="1-7-dead-lock">1-7. Dead Lock</h2>

<p>둘 이상의 프로세스(스레드)가 다른 프로세스(스레드)가 점유하고 있는 자원을 얻기 위해 서로 기다리는 경우 무한 대기에 빠지는 상황을 말한다.
예를 들어, 한 스레드가 공유 자원 a, b에 접근하기 위해 다음과 같은 코드를 실행 중이라면</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="n">mutex_lock</span><span class="p">(</span><span class="n">mutex_a</span><span class="p">);</span>
<span class="n">a</span><span class="o">++</span><span class="p">;</span>
<span class="n">mutex_lock</span><span class="p">(</span><span class="n">mutex_b</span><span class="p">);</span>
<span class="n">b</span><span class="o">++</span><span class="p">;</span>
<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">mutex_a</span><span class="p">);</span>
<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">mutex_b</span><span class="p">);</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="p">.</span>
</code></pre></div></div>

<p>아래 코드를 실행 중인 또 다른 스레드와 dead lock을 일으킬 수 있다(열심히 고민해 보자).</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="n">mutex_lock</span><span class="p">(</span><span class="n">mutex_b</span><span class="p">);</span>
<span class="n">b</span><span class="o">++</span><span class="p">;</span>
<span class="n">mutex_lock</span><span class="p">(</span><span class="n">mutex_a</span><span class="p">);</span>
<span class="n">b</span><span class="o">++</span><span class="p">;</span>
<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">mutex_a</span><span class="p">);</span>
<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">mutex_b</span><span class="p">);</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="p">.</span>
</code></pre></div></div>

<h3 id="1-7-1-deadlock-발생조건-4가지">1-7-1. DeadLock 발생조건 4가지</h3>

<ol>
  <li><strong>상호 배제</strong> : 한 번에 프로세스(스레드) 하나만 특정 공유 자원을 사용할 수 있다. 사용 중인 자원을 다른 프로세스(스레드)가 사용하려면 해당 자원에 걸린 제한이 해제될 때까지 기다려야 한다.</li>
  <li><strong>점유 대기</strong> : 자원을 최소한 하나 확보하고, 다른 자원을 점유하기 위해 대기하는 프로세스(스레드)가 존재해야 한다.</li>
  <li><strong>비선점</strong> : 다른 프로세스나 스레드가 점유한 자원을 강제로 빼앗을 수 없다.</li>
  <li><strong>순환 대기</strong> : 자원을 얻으려는 프로세스(스레드)가 순환 형태로 대기하고 있어야 한다.</li>
</ol>

<h3 id="1-7-2-deadlock-해결법">1-7-2. DeadLock 해결법</h3>

<ol>
  <li><strong>예방(Prevention)</strong> : 데드락의 발생조건 4가지 중 하나도 만족하지 않게 설계하는 것. 시스템 처리량이나 효율을 떨어뜨리는 문제가 발생할 수 있다.</li>
  <li><strong>회피(Avoidance)</strong> : 데드락 발생 가능성을 허용하지만 적절하게 회피하는 방법. 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서 차례로 모두에게 할당해 줄 수 있다면 <strong>safe state</strong>에 있다고 말한다. 또한 특정한 순서로 프로세스들에게 자원을 할당, 실행, 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서를 <strong>safe sequence</strong>라고 한다. 회피 알고리즘은 자원을 할당한 후에도 시스템이 항상 safe state에 있을 수 있도록 할당을 허용하는 것이다.</li>
  <li><strong>탐지 및 회복(Detection and Recovery)</strong> : 시스템이 데드락 예방이나 회피를 하지 않았을 때, 데드락이 발생하면 이를 탐지하고 회복하는 알고리즘.</li>
</ol>

<p><br /></p>

<h2 id="1-8-context-switch">1-8. Context Switch</h2>

<p>하나의 프로세스(스레드)가 CPU를 사용하던 상황에서 다른 프로세스(스레드)가 CPU를 사용하기 위해, 먼저 사용하고 있던 프로세스(스레드)의 상태를 저장해놓고 다음 프로세스(스레드)의 저장되어 있던 상태를 불러오는 것을 말한다.</p>

<p>프로세스 끼리는 메모리를 공유하지 않지만 스레드 끼리는 <code class="language-plaintext highlighter-rouge">stack</code>영역을 제외한 <code class="language-plaintext highlighter-rouge">code</code>, <code class="language-plaintext highlighter-rouge">data</code>, <code class="language-plaintext highlighter-rouge">heap</code> 영역을 공유하기 때문에, 프로세스에서 다른 프로세스로 context switch가 일어나는 것보다, 한 프로세스 내의 스레드 사이에서 context switch가 발생하는 것이 overhead가 적다.</p>

<p><br /></p>

<h2 id="1-9-효율적인-멀티스레딩">1-9. 효율적인 멀티스레딩</h2>

<p>스레드를 많이 만든다고 무조건 좋은 프로그램이 아니다. 이는 하드웨어의 성능에 따라 달라진다.</p>

<p><a href="https://www.youtube.com/watch?v=M1e9nmmD3II&amp;t=16s">유튜브 포프tv</a></p>

<p><br /></p>

<h1 id="3-시행착오-및-팁">3. 시행착오 및 팁</h1>

<ul>
  <li>Mandatory
    <ol>
      <li>philosopher가 1명일 때 프로그램을 종료하기 위해 pthread_detach()를 사용했는데, main thread에서 free를 완료하고 난 후, 아직 종료되지 않은 philo 스레드에서 free된 변수를 참조하면 segfault가 발생한다.</li>
      <li>인자에 0이 오는 경우는 웬만하면 에러처리하자.</li>
      <li>반복되는 계산은 변수에 담아서 계산을 줄이자.</li>
    </ol>
  </li>
  <li>Bonus
    <ol>
      <li>스레드 없이 프로세스 자체에서 먹기, 자기, 생각하기를 하면서 죽는 시간을 계산하려고 했으나, 죽었는지 체크해주는 스레드가 없으면 usleep이 걸려있는 동안 자신이 죽었는지 확인할 방법이 없다.</li>
      <li><code class="language-plaintext highlighter-rouge">typedef int sem_t</code>로 선언되어 있어서 sem_t 변수에 직접 접근해서 값을 확인할 수 있을 줄 알았지만 불가능했다.</li>
    </ol>
  </li>
</ul>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="42Seoul" /><category term="42Seoul" /><category term="Philosophers" /><category term="Dining_Philosophers" /><category term="semaphore" /><category term="mutex" /><category term="race_condition" /><summary type="html"><![CDATA[Dining Philosopher 문제를 해결해보자.]]></summary></entry></feed>
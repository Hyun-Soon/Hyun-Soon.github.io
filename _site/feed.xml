<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-10-20T20:58:17+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hyuim’s blog</title><subtitle>Hyuim&apos;s personal blog.</subtitle><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><entry><title type="html">Born2beroot</title><link href="http://localhost:4000/42seoul/Born2beroot/" rel="alternate" type="text/html" title="Born2beroot" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-20T00:00:00+09:00</updated><id>http://localhost:4000/42seoul/Born2beroot</id><content type="html" xml:base="http://localhost:4000/42seoul/Born2beroot/"><![CDATA[<h1 id="0-과제-설명">0. 과제 설명</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>가상 머신을 이용해 엄격한 규칙들로 이루어진 나만의 서버를 구현한다.
</code></pre></div></div>

<p><br />
<br /></p>

<h1 id="1-필요-개념">1. 필요 개념</h1>

<h2 id="server">Server</h2>

<p>클라이언트의 요청을 받으면 서비스, 데이터를 제공하는 컴퓨터 혹은 프로그램(요청을 받으면 데이터를 보내주는 기계)</p>

<p>닭갈비집 알바생으로 비유하면 이해가 쉽다.<br />
닭갈비 2인분 주세요~ 하면 닭갈비 2인분을 가져다 주는 것 처럼, 웹서버도 마찬가지로 네이버 웹툰 페이지 주세요~ 하면 네이버 웹툰 페이지를 가져다 준다. 이것이 서버다.</p>

<p>서버를 구축할 때, OS를 선택해야 한다. 운영체제의 종류는 다양하기 때문에 사용성에 맞는 적절한 서버 운영체제를 선택하는 것이 중요하다. 이후 그 운영체제로 돌아가는 서버를 다룬다.
<br /></p>
<h2 id="linux">Linux</h2>

<ul>
  <li>GUI vs CLI
  Graphical User Interface vs Command-Line Interface</li>
</ul>

<p>윈도우, 맥OS, 안드로이드, IOS 등은 일반인, 즉 개발자가 아닌 사람들을 대상으로 만들어진 운영체제이기 때문에 GUI로 만들어진 화면에서 만들어진 기능을 사용할 수 있도록 환경을 제공하는 데 초점이 맞춰져 있다.</p>

<p>리눅스는 버전에 따라 GUI도 제공하지만, 가장 큰 장점은 CLI로 사용자가 할 수 있는 무궁무진한 작업들이다. 타 OS들이 완제품이라면 리눅스는 프로그래밍을 할 줄 아는 프로그래머들이 얼마든 이것저것 만져보고 개조해 볼 수 있는 조립식 제품 같은 개념이다.
<br /></p>
<ul>
  <li>오픈소스 운영체제</li>
</ul>

<p>리눅스는 오픈소스 운영체제이다. 오픈소스라 함은 누구나 공짜로 가져다 쓸 수 있을 뿐 아니라, 그 설계도인 코드도 마음대로 들여다볼 수 있고 이를 원하는대로 개조할 수도 있다는 의미다. 리눅스를 사용할 때 Ubuntu, 민트, CentOS 등등 수많은 버전들 중에서 골라야 하는 건 바로 이 때문이다. 리누스 토르발즈가 만든 리눅스에서 출발했지만, 이를 필요에 따라 개조하고 발전시킨 여러 버전들이 만들어졌기 때문이다.</p>

<ul>
  <li>Linux 커널(kernel)</li>
</ul>

<p>커널은 <strong>운영체제의 핵심</strong>으로 하드웨어와 프로그램 사이에서 인터페이스를 제공한다. OS의 최하단, 하드웨어를 상대하는 최전선에서 하드웨어를 직접 다루고 제어한다. 즉, 운영체제라는 소프트웨어의 존재이유이자 핵심.
<br /></p>
<h2 id="network">Network</h2>

<ul>
  <li>네트워크란?</li>
</ul>

<p>네트워크란 Net + Work의 합성어로 컴퓨터(노드)들이 그물처럼 연결되어 상호작용하는 통신 이용 형태를 말한다.</p>

<ul>
  <li>IP 주소란?</li>
</ul>

<p>네트워크 환경에서 컴퓨터(노드)간에 통신하기 위해 각 컴퓨터에 부여된 네트워크상의 주소.<br />
 ip주소는 네트워크 주소와 호스트 주소로 나뉜다.<br />
 <code class="language-plaintext highlighter-rouge">192.163.0.101</code> 이라는 ip 주소가 있다고 하자.<br />
 <code class="language-plaintext highlighter-rouge">192.168.0</code>은 네트워크 주소이고, <code class="language-plaintext highlighter-rouge">101</code>은 호스트 주소가 된다.<br />
 네트워크 주소는 공통적인 부분이고(ex. 서울시 중랑구 면목동 @@아파트 105동), 호스트 주소가 유일한 식별자 역할을 한다(ex. 202호).
<br /></p>
<h2 id="partition과-mount">Partition과 Mount</h2>

<ul>
  <li>
    <p>Partition</p>

    <ul>
      <li>하나의 물리적인 디스크를 여러개의 논리적 디스크로 나누는 것.</li>
      <li>Primary Partition은 하드 MBR에 기록되는 4개의 파티션을 말한다. 각각의 파티션별로 시작, 끝 지점이 기록되어 있고, OS의 디스크 드라이버는 이것을 인식하고 이 영역 내에서만 쓴다.</li>
      <li>Logical Partition은 파티션 하나를 내부적으로 파티션 몇 개로 나눈 것이고, 이 때 자기 자신을 몇 개로 나눈 파티션을 확장 파티션이라고 한다.</li>
    </ul>
  </li>
  <li>
    <p>File System</p>

    <ul>
      <li>파일 시스템(File System)은 운영 체제에서 파일과 디렉토리를 구성하고 저장하는 방식이다. 파일 시스템은 디스크, CD-ROM 등의 저장 장치를 관리하고, 사용자와 프로그램이 파일을 읽고 쓰는 방법을 제공한다. 리눅스에서는 다양한 파일 시스템이 지원되며, 대표적으로 ext4, XFS, NTFS, FAT32 등이 있다. 각 파일 시스템마다 특정한 특징과 장단점이 있으며, 사용 목적에 따라 선택할 수 있다.</li>
    </ul>
  </li>
  <li>
    <p>Mount</p>

    <ul>
      <li>파일 시스템을 운영 체제의 디렉토리 구조에 연결하는 것.</li>
      <li>리눅스 파일 단위로 모든 장치를 관리하기 때문에 새롭게 만든 파일 시스템을 사용하기 위해서는 디스크 장치를 임의의 디렉토리에 마운트 시켜 사용해야 한다. 마운트를 통해 해당 파일 시스템을 읽고 쓸 수 있게 되며, 해당 파티션의 파일이 디렉토리 구조에서 접근 가능해진다.</li>
    </ul>
  </li>
  <li>
    <p>Mount Point</p>

    <ul>
      <li>파일 시스템을 운영 체제의 디렉토리 구조에 연결할 때 사용되는 디렉토리를 의미한다.</li>
      <li>마운트 포인트는 해당 파일 시스템의 루트 디렉토리 역할을 하며, 해당 파일 시스템 내의 파일과 디렉토리는 마운트 포인트를 통해 접근된다.</li>
      <li>예를 들어, ‘/dev/sda1’ 파티션을 ‘/mnt/data’ 디렉토리에 마운트하면, ‘mnt/data’는 해당 파티션의 루트 디렉토리가 된다. 따라서 ‘/mnt/data/file.txt’와 같은 경로로 파일에 접근할 수 있다.</li>
      <li>마운트 포인트는 일반적으로 빈 디렉토리를 사용한다. 디렉토리 내부에 다른 파일이나 디렉토리가 존재하면, 해당 디렉토리를 마운트 포인트로 사용할 수 없다.
<br /></li>
    </ul>
  </li>
</ul>

<h2 id="lvm">LVM</h2>

<p>LVM(Logical Volume Manager)는 리눅스의 저장 공간을 효율적이고 유연하게 관리하기 위한 커널의 한 부분이다.</p>

<p>LVM은 리눅스 안에서 하나의 디스크를 여러 파티션으로 분할해서 파일 시스템을 이용해 특정 디렉토리와 연결시켜 사용한다. 파티션을 논리적인 개념인 볼륨으로 나눠서 더 유동적으로 디스크의 용량을 관리할 수도 있다. 볼륨은 기본적으로 단일 파티션에 상주하게 되지만 다수의 파티션을 하나의 볼륨으로 관리할 수도 있다. 따라서 여러 개의 파티션을 합치거나 분할하기에 용이하다.</p>

<p><strong>파티션</strong></p>

<p>디스크는 파티션이라는 논리적인 크기로 분할/통합해서 사용한다. 하나의 디스크를 여러 개로 분할하기도 하고 여러 개의 디스크를 하나의 파티션으로 통합하기도 한다.</p>

<p>파티션은 고정적이고 물리적인 개념이 강하며 한 번 크기를 설정하면 변경하거나 추가하기 힘들고 OS는 각 파티션을 별도의 디스크처럼 인식한다.</p>

<p><strong>볼륨</strong></p>

<p>파일 시스템으로 포맷된 디스크 상의 저장 영역이라고도 하며 파티션과 비슷한 개념이지만 엄연히 다르다.</p>

<p>볼륨은 디스크의 단일 파티션에 상주하게 되며 파티션보다 논리적으로 유동적이다. 우리는 하나의 디스크를 여러 개의 파티션으로 나누어 사용한다. 이 때 볼륨은 파티션마다 하나씩 존재하기도 하고, 여러 파티션에 하나만 존재할 수도 있다.</p>

<p><strong>LVM vs 일반 disk partitioning</strong></p>

<p>LVM이 아닌 기존 방식의 경우, 하드 디스크를 파티셔닝 한 후 OS 영역에 마운트하여 read/write를 수행했다.</p>

<p>이 경우 저장 공간의 크기가 고정되어서 증설/축소가 어렵다. 이를 보완하기 위한 방법으로 LVM을 구성할 수 있다.</p>

<p>LVM은 파티션 대신에 volume이라는 단위로 저장 장치를 다룬다.</p>

<p>스토리지의 확장, 변경에 유연하며, 크기를 변경할 때 기존 데이터의 이전이 필요 없다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/boot를 lvm 밖에 설정하는 이유는 lvm을 암호화해놨기 때문에, /boot를 lvm에 넣어놓으면 부트를 하지 못하기 때문이다. 부트를 해야 암호를 물어보던가 말던가 할 수 있다.
</code></pre></div></div>

<p><br /></p>
<h2 id="ssh">SSH</h2>

<p>SSH(Secure SHell)는 컴퓨터와 컴퓨터가 인터넷과 같은 Public Network를 통해 서로 통신을 할 때 보안적으로 안전하게 사용하기 위해 사용하는 네트워크 *프로토콜이다.</p>

<p><strong>대표적인 사용 예</strong></p>
<ul>
  <li>데이터 전송(소스 코드를 원격 저장소인 Github에 Push할 때)</li>
  <li>원격 제어(AWS와 같은 클라우드 서비스에 접속하여 해당 머신에 명령을 내릴 때)</li>
</ul>

<p>FTP나 Telnet과 같은 다른 컴퓨터와 통신을 위해 사용하는 프로토콜도 있는 반면 SSH를 사용하는 이유는 ‘보안’이다. FTP, Talnet은 민감한 정보(로그인 정보 등)를 주고 받기에는 정보를 직접 네트워크를 통해 넘기기 때문에 누구나 해당 정보를 열어볼 수 있으므로 보안에 상당히 취약하다. 반면 SSH는 먼저 보안적으로 훨씬 안전한 채널을 구성한 뒤 정보를 교환하기 때문에 민감한 정보를 주고 받기에 훨씬 유용하다.</p>

<p>*프로토콜 : 복수의 컴퓨터 사이나 중앙 컴퓨터와 단말기 사이에서 데이터 통신을 원활하게 하기 위해 필요한 통신 규약. 신호 송신의 순서, 데이터의 표현법, 오류 검출법 등을 정함.</p>

<p><strong>SSH 작동 원리</strong></p>

<p>SSH는 다른 컴퓨터와 통신을 하기 위해 접속을 할 때 우리가 일반적으로 사용하는 비밀번호의 입력을 통한 접속을 하지 않는다. 기본적으로 SSH는 한 쌍의 Key를 통해 접속하려는 컴퓨터와 인증 과정을 거치게 된다.</p>

<p>한쌍의 키는 다음과 같다.</p>

<ul>
  <li>Private Key</li>
  <li>Public Key</li>
</ul>

<p>SSH는 암호화된 통신을 위해 사용되는 프로토콜로, 키 기반 인증을 지원합니다. 이것은 공개 키/개인 키 쌍을 사용하여 사용자를 인증하고 서버에 안전하게 로그인할 수 있도록 한다.</p>

<p>공개 키/개인 키 쌍은 두 개의 다른 키로 구성됩니다. 공개 키는 다른 사용자들과 공유할 수 있는 키이며, 개인 키는 단 하나의 소유자만이 액세스할 수 있는 비밀 키다.</p>

<p>공개 키는 보안적으로 안전하다. 개인 키를 알지 못하면 공개 키를 통해 암호화된 정보를 해독할 수 없기 때문이다. 공개 키는 일반적으로 사용자가 SSH 서버에 로그인하고자 할 때, SSH 클라이언트에서 서버에 보내지며, 서버는 이를 수신하고 인증을 위해 공개 키와 일치하는 개인 키를 요청한다.</p>

<p>반면에 개인 키는 항상 소유자에게 보관되어야 한다. 개인 키가 유출될 경우, 해당 키로 암호화된 모든 정보는 해독될 수 있으므로 보안에 매우 취약하다. 따라서 개인 키는 안전한 저장소에 보관해야 한다.</p>

<p>이러한 이유로, 공개 키/개인 키 쌍을 사용한 SSH 인증 방식은 매우 안전하고 널리 사용되고 있다.
<br /></p>
<h2 id="tty">TTY</h2>

<p>TTY는 콘솔 또는 터미널을 의미하며, 사용자와 컴퓨터 간의 상호작용을 위한 인터페이스이다. 즉, TTY는 사용자가 컴퓨터와 상호작용할 때, 문자 기반 인터페이스를 제공하는 장치나 프로그램이다.</p>

<p>일반적으로 리눅스나 유닉스 시스템에서, 새로운 콘솔 창을 열거나 SSH 세션을 열 때마다 TTY가 생성된다. 이 TTY는 터미널 에뮬레이터를 통해 사용자와 컴퓨터 간의 상호작용을 가능하게 한다.</p>

<p>우리가 사용하는 리눅스 환경은 기본적으로 TTY(Teletypewriter) 위에 그려져 있다. 즉, 데스크탑 GUI(xwindows) 환경은 실질적으로 *콘솔 위에 올려져 있는 형태인 것이다.</p>

<p>콘솔은 CLI 혹은 CUI라고도 불리며 컴퓨터를 운용하기 위한 목적으로 텍스트를 사용자와 컴퓨터가 주고 받는 인터페이스를 말한다.</p>

<p>TTY는 일반적으로 /dev/ttyX 또는 /dev/pts/X의 형식으로 표현된다. 여기서 X는 TTY의 번호를 나타낸다. 예를 들어, /dev/tty1은 시스템의 첫 번째 TTY를 나타낸다.</p>

<p>전체 콘솔은 다음과 같은 구성을 가지고 있다.</p>

<ul>
  <li>/dev(device)
    <ul>
      <li>TTY(일반 CLI 콘솔)
        <ul>
          <li>TTYs(시리얼 tty)</li>
          <li>PTS(기본 xwindows를 위한 가상 콘솔)
            <ul>
              <li>PTY(외부의 원격 접속을 위한 가상 콘솔)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>콘솔 모드는 모니터, 키보드로 직접 본체에 연결된 모드를 말하고, 2번째 콘솔부터가 가상 콘솔이다. 2번째 모니터, 키보드는 실제로 존재하지 않으니까 가상(pseudo)이라는 말이 붙는다.</p>

<p>*콘솔 : 서버의 로컬 장치(물리적 터미널)에서 직접 명령어를 작성할 수 있는 입출력 장치. 콘솔이 물리적인 장치라면 터미널은 원격제어 환경까지 포함하는 더 넓은 의미라고 할 수 있다.
<br /></p>
<h2 id="apparmor">AppArmor</h2>

<p>리눅스 커널에서 동작하는 보안 모듈 중 하나로, 프로세스가 사용할 수 있는 파일, 디렉토리, 네트워크 포트 등의 자원에 대한 접근을 제한하는 보안 기능을 제공한다.</p>

<p>기본적으로 시스템에서 실행 중인 프로세스들에게 보안 정책을 적용하며, 허용되지 않은 동작이나 시도를 감지하고 차단할 수 있다. 예를 들어, 특정 프로그램이 사용할 수 있는 파일이나 디렉토리를 제한하거나, 특정 프로그램이 인터넷에 연결되는 것을 막을 수 있다.</p>

<blockquote>
  <p>핸드폰 어플의 카메라, 위치 등의 접근 권한과 비슷하다.</p>
</blockquote>

<p>*모듈 : 프로그램을 작성할 때 필요한 함수, 클래스, 변수, 상수 등의 코드 블록을 담고 있는 파일 단위. 모듈을 사용하면 코드를 재사용하고 구성 요소를 분리하여 개발 및 유지 보수를 용이하게 할 수 있다.</p>

<p>* MAC(Mandatory Access control) : 컴퓨터 보안에서 사용하는 용어로, 운영체제가 어떤 수행 객체(subject)의 다른 객체(object)로의 접근과 수행 기능을 제한하는 식으로 보안성을 높이는 기능을 의미한다. 운영체제가 직접 관여하기 때문에 이 보안 기능은 강제(Mandatory)된다.</p>

<p>* SELinux : 관리자가 시스템 액세스 권한을 효과적으로 제어할 수 있게 하는 Linux 시스템용 보안 아키텍처. Redhat 계열의 리눅스에서 사용한다.
<br /></p>
<h2 id="ubuntu-package-manager">Ubuntu Package Manager</h2>

<ul>
  <li>apt</li>
</ul>

<p>Advanced Package Tool의 약자로, apt-get을 개선한 패키지 관리 도구. apt는 패키지 설치, 업그레이드, 삭제, 의존성 해결 등을 자동으로 처리해준다. apt는 패키지 관리에 필요한 메타 데이터를 인터넷으로부터 다운로드해야 하기 때문에, 인터넷에 연결되어 있어야 한다.</p>

<ul>
  <li>dpkg</li>
</ul>

<p>Debian Package의 약자로, 패키지 설치와 관리를 위한 기본적인 도구이다. dpkg는 패키지를 직접 설치, 삭제하며, 파일 시스템과 관련된 작업을 수행한다. dpkg는 apt-get과 같은 고급 패키지 관리 도구의 기반 기술로 사용된다.</p>

<ul>
  <li>aptitude</li>
</ul>

<p>aptitude는 apt와 비슷한 고급 패키지 관리 도구이다. apt와 마찬가지로 패키지 설치, 업그레이드, 삭제, 의존성 해결 등을 처리한다. aptitude는 apt와 달리 패키지 관리에 대한 명령어를 더 많이 제공하며, 대화형 인터페이스도 제공한다. CLI(Command Line Interface)인 apt과 달리 CUI(Command-line User Interface)를 기반으로 하기 때문에 더 직관적이고 사용자 친화적인 UI를 제공한다.</p>

<p>이들 패키지 관리 도구는 모두 Debian 계열 리눅스에서 사용되며, Ubuntu와 같은 다른 Debian 기반 배포판에서도 널리 사용된다. 이들 도구는 리눅스 시스템에서 패키지 관리를 자동화하고, 개발자 및 시스템 관리자가 소프트웨어 설치와 유지 보수를 효율적으로 수행할 수 있도록 도와준다.
 <br /></p>
<h2 id="firewall">Firewall</h2>

<p>네트워크 방화벽은 시스템과 외부 소스 사이에 장벽을 형성한다. 본질적으로 외부에서 발생한 피해가 확산하여 소중한 내부 데이터를 손상시키지 못하도록 차단한다.</p>

<p>방화벽은 다음과 같이 작동한다.</p>

<ol>
  <li>검사 : 시스템으로 송수신되는 *트래픽을 바이트 단위로 빈틈없이 검사한다.</li>
  <li>결정 : 허용할 작업 또는 특성을 정의합니다. 이 때 정해진 규칙과 비교하여 트래픽을 결정한다.</li>
  <li>실행 : 규칙에 부합하는 트래픽은 허용되며, 그렇지 않은 트래픽은 거부된다.</li>
</ol>

<p>* 트래픽 : 네트워크에서 “트래픽”은 전송되는 데이터의 양을 의미한다. 즉, 네트워크를 통해 전송되는 모든 데이터의 양을 말한다. 이러한 데이터는 인터넷을 통해 이메일, 웹 페이지, 파일, 미디어 스트림 등 다양한 형태로 전송될 수 있다.
<br /></p>
<h2 id="ufw">UFW</h2>

<p>ufw는 Uncomplicated Firewall의 약자로, Ubuntu 및 Debian 기반 시스템에서 사용할 수 있는 간단한 방화벽 도구이다. ufw는 iptables(기본적인 방화벽 명령어)를 기반으로 하며, 쉬운 사용성과 간단한 구성을 통해 시스템 보안을 유지할 수 있도록 도와준다. 명령줄 인터페이스를 제공하기 때문에 사용자가 수동으로 iptables 규칙을 작성하는 것보다 더 쉽게 사용할 수 있다.</p>

<p>ufw를 사용해 다음과 같은 작업을 수행할 수 있다.</p>

<ul>
  <li>특정 포트의 트래픽 허용 또는 차단</li>
  <li>특정 IP 주소 또는 IP 대역의 트래픽 허용 또는 차단</li>
  <li>다양한 프로토콜 (TCP, UDP 등)의 트래픽 허용 또는 차단
<br /></li>
</ul>

<h2 id="gateway">Gateway</h2>

<p>쉽게 말하면 다른 네트워크로 가기 위한 문이다. 서로 다른 프로토콜을 가진 네트워크를 연결하기 위한 translator다. 서로 다른 네트워크 대역을 가진 네트워크끼리 통신을 하려고 하면, 우선 Gateway로 간 후 목적지를 찾아간다.</p>

<p>예를 들어, 하나의 네트워크를 집이라고 하면, 우리가 네트워크가 틀린(옆집) 집으로 가려면 현관문을 거쳐야 우리집이 아닌 다른 곳으로 갈 수가 있다. Gateway도 마찬가지다. 내가 사용하는 네트워크(ex. 192.168.10.0)에서 다른 네트워크(172.16.20.0) 대역으로 통신을 하려면, Gateway를 거쳐야만 통신이 가능하다. 보통 같은 네트워크에서는 *MAC Address를 이용해서 통신을 하기 때문에 Gateway를 몰라도 통신이 가능하다. 같은 네트워크 대역일 때, 즉 아파트 같은 103동일 때 105호에서 1203호를 가도 아파트 현관을 거치지 않아도 되는 것과 마찬가지.</p>

<p>* MAC Address : 주민등록번호와 같이 단 하나의 고유한 주소를 부여해서 통신을 할 수 있도록 만든 일종의 하드웨어 주소
<br /></p>
<h2 id="port-forwarding">Port Forwarding</h2>

<p>포트포워딩은 공유기의 포트를 통해 이 공유기와 연결된 기기들이 특정 포트에 진입할 수 있게 하는 기능이다.</p>

<p>만약 공유기에 컴퓨터와 핸드폰이 연결되어 있는데 그냥 공유기 주소 + 포트번호로 입력한다면 공유기의 ‘어느 기기’의 포트로 들어가야 하는지 알 수 없다. 따라서 포트 포워딩은 공유기에 연결된 기기의 포트를 특정 번호를 통해 전달(forwarding)해 주는 것이라고 이해할 수 있다. 또는 공유기에 기기 + 해당 기기의 포트에 해당하는 포트 번호를 할당해 준다고 봐도 된다. 예를 들어 공유기의 180포트로 접속하면 핸드폰의 5000 포트에 접속하게 하고, 280포트로 접속하면 컴퓨터의 5000포트에 접속하게 하는 것이다. 여기서 180, 280 등을 지정하는 작업이 포트포워딩이다.
<br /></p>
<h2 id="명령어-저장-위치">명령어 저장 위치</h2>

<p>| 디렉토리 | 용도 | 사용권한 |
| :—: | :—: | :—: |
| /bin | 기본적인 명령어 | 일반 사용자 |
| /sbin | 시스템 관리를 위한 명령어 | 슈퍼 유저(root) |
| /usr/bin | /bin에 있는 명령어를 제외한 기본적인 명령어 | 일반 사용자 |
| /usr/sbin | /sbin에 있는 명령어를 제외한, 시스템 관리를 위한 명령어 | 슈퍼 유저(root) |
<br /></p>
<h2 id="shell--shell-script">Shell &amp; Shell Script</h2>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/8/8e/Linux_system_diagram.png" alt="Shell" /></p>

<p>쉘은 커널과 사용자 간의 다리 역할을 하는 것으로 사용자로부터 명령을 받아 명령을 해독하고 프로그램을 실행하는 역할을 한다. 즉, 사용자가 사용자 프로그램을 이용해 명령어를 입력하면 사용자가 이용하는 쉘이 명령을 받아 커널에 전달해 준다.</p>

<p>쉘 스크립트는 쉘에게 어떠한 명령을 할지 스크립트를 ‘.sh’ 파일 확장자로 작성하여 만든 파일이다. 확장자를 sh 파일로 하는 것은 리눅스 사용자에게 ASCII test 실행파일이라는 암묵적인 약속이다.</p>

<p>쉘 스크립트는</p>
<ol>
  <li>반복되는 작업의 자동화(cron)가 가능하다.</li>
  <li>다른 프로그래밍 언어 보다 훨씬 더 빠른 경우가 많다.</li>
  <li>컴파일 단계가 없기 때문에 스크립트는 디버깅을 하는 동안 빠르게 실행할 수 있다.</li>
  <li>스크립트의 내용을 모르는 사용자도 실행할 수 있다.</li>
  <li>모니터링, 데이터 백업, 복구, 보안, 인증 등 여러 상황에서 많이 활용된다.
<br /></li>
</ol>

<h2 id="cpu-vs-virtual-cpuvcpu">CPU vs Virtual CPU(vCPU)</h2>

<p>virtual CPU는 가상화 환경에서 사용되는 가상의 중앙 처리 장치이다. 가상 CPU는 호스트 컴퓨터의 물리적 CPU 자원을 사용하여 가상머신(VM)을 구동하면서 각 VM에게 독립적인 CPU 자원을 할당하는 방식으로 동작한다.</p>

<p>가상 CPU는 가상 머신에 대한 하드웨어 추상화를 제공하며, 여러 가상 CPU를 각각의 가상 머신에 할당함으로써 각각의 VM이 독립적으로 작동하도록 한다. 가상 CPU를 사용하면 여러 개의 가상 머신을 하나의 호스트 컴퓨터에서 실행할 수 있으며, 각각의 가상 머신은 서로 독립적으로 실행되어 상호 간에 영향을 미치지 않는다.</p>

<p>가상 CPU는 클라우드 컴퓨팅, 서버 가상화, 컨테이너 가상화 등에서 사용된다. 이를 통해 하나의 물리적 서버에서 여러 개의 가상 서버를 실행하여 하드웨어 자원을 효율적으로 사용할 수 있다.
<br /></p>
<h2 id="processor-vs-cpu-vs-core">Processor vs CPU vs Core</h2>

<p><strong>Processor</strong></p>

<p>컴퓨터 운영을 위해 기본적인 명령어들을 처리하고 반응하기 위한 논리회로이다. 보통 소프트웨어의 지시를 읽고 하드웨어의 다른 부분으로 신호를 보내는 제어장치(Control Unit)와 덧셈, 뺄셈 등 사칙연산과 AND, OR과 같은 논리연산 등을 담당하는 연산장치(ALU)로 구성된다. 디바이스가 해야할 일을 총 지휘하는 프로세서를 CPU라고 하며, CPU의 기능을 보조하는 프로세서를 보조 프로세서(Coprocessor)라고 한다. 그러나 프로세서라는 용어는 점차 CPU라는 용어를 대체해왔다.</p>

<p><strong>CPU</strong></p>

<p>컴퓨터를 뇌에 비유하자면 단기기억 담당은 RAM, 장기기억은 하드디스크, CPU는 사고를 담당하는 대뇌피질 정도로 볼 수 있다. 대뇌피질 없이 인간의 사고가 성립하지 않듯이 컴퓨터도 CPU 없이는 그냥 전기 잡아먹는 기계가 된다.</p>

<p>간단하게 말하자면 컴퓨터의 뇌와 같다.</p>

<p>컴퓨터의 구성 단위 중 기억, 연산, 제어의 3대 기능을 종합하는 장치이고 컴퓨터의 가장 중요한 부분이다.</p>

<p><strong>Core</strong></p>

<p>코어란 각종 연산을 하는 CPU의 핵심요소이며, CPU 내부에는 코어 말고도 컨트롤러, 캐시메모리 등이 있다. A가 혼자 100의 일을 다 하기에는 힘들지만 B와 함께 50씩 나눠서 일을하면 일처리가 빠르고 편할 것이다. 이것이 코어의 개념이다.
<br /></p>
<h2 id="lighttpd-mariadb-php">lighttpd, MariaDB, PHP</h2>

<p><strong>lighttpd</strong></p>

<p>경량 웹서버. 적은 메모리와 CPU 자원으로 높은 성능을 내는 것이 특징. Apache와 NGINX가 가장 많이 쓰이는 웹서버이다.</p>

<p><strong>PHP</strong></p>

<p>서버 측에서 동작하는 웹 프로그래밍 언어로, Personal HomePage tools의 약자이다. PHP는 주로 동적 웹 사이트, 웹 애플리케이션 및 웹 서비스를 개발하는 데 사용된다. 무료이며 오픈 소시이기 때문에 다양한 개발자들에게 널리 사용되고 있다. PHP는 웹 개발에 필요한 기능을 포함하고 있으며, 데이터베이스 연결, 파일 업로드 및 처리, 세션 관리, 쿠키 처리 등을 쉽게 구현할 수 있다.</p>

<p><strong>MariaDB</strong></p>

<p>MariaDB는 MySQL 데이터베이스 관리 시스템의 분기 버전이다. MySQL과 동일한 구조와 기능을 제공하며, MySQL과 호환되는 대부분의 애플리케이션 및 도구들과 호환된다.
<br /></p>

<h2 id="wordpress">WordPress</h2>

<p>워드프레스는 오픈소스 기반 설치형 블로그 또는 CMS이다.</p>

<p>CMS : Contents Management System의 약자로 게시판, 레이아웃, 모듈 등을 쉽게 관리할 수 있는 프로그램.</p>

<p>언어는 PHP를 사용하고 있다. 설치형 블로그는 무료로 사용할 수 있고, CMS는 유료.</p>

<p>* wget : wget은 웹사이트에서 파일을 다운로드하는 데 사용되는 커맨드 라인 도구이다. 이를 사용하여 웹 서버에서 파일을 직접 다운로드하거나 FTP 서버에서 파일을 가져올 수 있다. ‘wget’은 많은 옵션을 제공하여 다운로드 속도를 제어하고 재시도 횟수를 지정하고, 다운로드 중에 끊어진 연결을 자동으로 다시 연결하고, 다운로드 된 파일에 대한 각종 정보를 표시할 수 있다.
<br />
<br /></p>

<h1 id="2-명령어">2. 명령어</h1>

<p>apt-get(Advanced Packaging Tool)은 우분투(Ubuntu)를 포함한 데비안(Debian)계열의 리눅스에서 쓰이는 패키지 관리 명령어 도구이다.
<br /></p>
<h3 id="package">Package</h3>

<ul>
  <li>dpkg –get-selections : 설치되어 있는 package 확인</li>
  <li>apt-get install sudo : sudo 설치</li>
  <li>apt-get update : 운영체제에서 사용 가능한 패키지들과 그 버전에 대한 정보를 업데이트. 설치되어 있는 패키지를 최신으로 업데이트하는 것이 아닌, 설치가능한 리스트를 업데이트하는 것. → apt-get install 명령을 이용해서 특정 패키지를 설치할 수 없는 경우 패키지 리스트를 최신으로 업데이트 해야 할 필요가 있다.</li>
  <li>apt-get upgrade : 운영체제에 apt-get install 명령으로 설치한 패키지들을 최신 버전으로 업그레이드 하는 명령어이다. apt-get upgrade 명령을 이용하면 apt-get update로 가져온 각 패키지들의 최신 버전에 맞게 업그레이드를 해준다.</li>
  <li>apt list &lt;package name&gt; : 패키지 설치 확인
<br /></li>
</ul>

<h3 id="sudo">SUDO</h3>

<ul>
  <li>su - : 사용자 계정에서 root 계정 로그인</li>
  <li>su - $username : 루트 계정에서 사용자 계정으로 로그인</li>
  <li>visudo : sudo 권한을 편집. /etc/sudoers에 접근해 직접 편집할 수도 있지만, 문법체크를 해주는 visudo를 쓰는 게 좋다.</li>
  <li>usermod -aG sudo &lt;username&gt; : 해당 유저를 sudo 그룹에 추가
<br /></li>
</ul>

<h3 id="password">PASSWORD</h3>

<ul>
  <li>chage -l &lt;username&gt; : 현재 사용자의 암호정보 확인</li>
  <li>sudo vi /etc/pam.d/common-password : 현재 패스워드 정책 확인</li>
  <li>sudo vim /etc/login.defs : 패스워드 정책 커스텀</li>
  <li>sudo apt install libpam-pwquality : 패스워드 정책 설정에 필요한 모듈 설치</li>
  <li>passwd -e &lt;username&gt; : 계정 비밀번호 변경. 명령어를 입력 → logout → 다시 로그인 할 때 비밀번호 변경</li>
</ul>

<p>/etc, /usr/etc 디렉토리는 시스템의 부팅, 셧다운 시에 필요한 파일들과 시스템의 전반에 걸친 설정 파일들 및 초기 스크립트 파일들이 있다. 시스템에 어떤 문제가 생긴다거나, 시스템 전체 환경에 관한 설정을 바꾸기 위해서는 이들 디렉토리 내에 포함되어 있는 파일들에 대하여 잘 알아야 한다.
<br /></p>

<h3 id="user">USER</h3>

<ul>
  <li>
    <p>sudo adduser &lt;username&gt; : 새 사용자 계정 생성</p>
  </li>
  <li>
    <p>sudo usermod -aG sudo &lt;username&gt; : sudo 그룹에 사용자 추가</p>
  </li>
  <li>
    <p>sudo deluser username : 사용자 삭제</p>
  </li>
  <li>
    <p>hostnameclt : hostname 확인</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">hostnamectl set-hostname --static &lt;username&gt;</code> : hostname 변경(재부팅 해야함)</p>
  </li>
  <li>
    <p>groupadd user42 : 그룹 추가</p>
  </li>
  <li>
    <p>lsblk : 파티션 구조 확인</p>
  </li>
  <li>
    <p>ss -tunlp : 수신 포트를 확인</p>
  </li>
  <li>
    <p>reboot : 재부팅. 설정이 반영이 안됐을 때는 재부팅 해보자.
<br /></p>
  </li>
</ul>

<h3 id="ip">IP</h3>

<ul>
  <li>ip addr : ip 확인</li>
  <li>ip route : gateway 확인</li>
  <li>ipconfig getifaddr en0 : 현재 사용중인 Mac의 ip 확인</li>
  <li>id &lt;username&gt; : user의 그룹 확인
<br /></li>
</ul>

<h3 id="ufw-1">UFW</h3>

<ul>
  <li>ufw status : ufw 상태 확인</li>
  <li>ufw enable : ufw 실행</li>
  <li>ufw disable : ufw 중지</li>
  <li>ufw allow 4242/tcp : 4242번 포트를 allow</li>
  <li>ufw delete allow 8080/tcp : 8080번 포트를 delete
<br /></li>
</ul>

<h3 id="apparmor-1">AppArmor</h3>

<ul>
  <li>aa-enabled : AppArmor 실행여부 확인
<br /></li>
</ul>

<h3 id="cron">CRON</h3>

<ul>
  <li>crontab -e : crontab 실행</li>
  <li>crontab -l : crontab 내용 확인</li>
  <li>crontab -r : 크론탭 삭제</li>
  <li>systemctl disable cron</li>
  <li>sudo /etc/init.d/cron stop</li>
</ul>

<p><br /></p>

<h3 id="ssh-1">SSH</h3>

<ul>
  <li>vi /etc/ssh/sshd_config : ssh 서버 설정 파일 vi로 열기(client는 ssh_config 파일)</li>
</ul>

<p><br /></p>

<h3 id="bonus">BONUS</h3>

<ul>
  <li>lighttpd -v : lighttpd version 확인</li>
  <li>systemctl stop/start/enable/status lighttpd.service : lighttpd 서버 중지, 시작, 상태 확인</li>
  <li>vim /etc/lighttpd/conf-available/15-fastcgi-php.conf : lighttpd의 fastcgi 설정 파일 열기</li>
  <li>systemctl stop/start/enable/disable/status mysql.service : mysql 중지, 시작, 상태 확인</li>
  <li>mysql -u &lt;username&gt; -p : mysql 접속, -p option → passwd 입력</li>
  <li>sudo vim /var/www/html/wordpress/wp-config.php</li>
  <li>journalctl -f : 실시간 ssh 로그인 실패 기록</li>
  <li>sudo systemctl status fail2ban</li>
  <li>sudo vim /etc/fail2ban/jail.local : fail2ban 설정 파일 열기</li>
  <li>sudo fail2ban-client status sshd : 차단 현황 보기</li>
  <li>sudo fail2ban-client set sshd unbanip 000.000.000.000 : 차단 풀어주기
<br />
<br /></li>
</ul>

<h3 id="reference">📬 <strong>Reference</strong></h3>

<p><a href="https://www.howtoforge.com/how-to-install-lighttpd-with-php-and-mariadb-on-debian-10/">https://www.howtoforge.com/how-to-install-lighttpd-with-php-and-mariadb-on-debian-10/</a></p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="42Seoul" /><category term="42Seoul" /><category term="Born2beroot" /><category term="가상머신" /><category term="VM" /><category term="virtual_machine" /><summary type="html"><![CDATA[가상머신을 이용해 나만의 서버를 만들어 보자.]]></summary></entry><entry><title type="html">ft_printf</title><link href="http://localhost:4000/42seoul/ft_printf/" rel="alternate" type="text/html" title="ft_printf" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-20T00:00:00+09:00</updated><id>http://localhost:4000/42seoul/ft_printf</id><content type="html" xml:base="http://localhost:4000/42seoul/ft_printf/"><![CDATA[<h1 id="0-과제-설명">0. 과제 설명</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printf 함수를 구현한다.
</code></pre></div></div>

<p><br />
<br /></p>
<h1 id="1--가변-인자variable-argument">1.  가변 인자(variable argument)</h1>
<p>가변 인자는 말 그대로 개수가 변할 수 있는 인자이다.<br />
함수 printf를 사용하는 경우를 생각해보자.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%s %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"this is an example."</span><span class="p">,</span> <span class="mi">123</span><span class="p">);</span>
	<span class="n">printf</span> <span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">456</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 코드에서 첫 번째 printf에 <code class="language-plaintext highlighter-rouge">"%s %s\n"</code>, <code class="language-plaintext highlighter-rouge">"this is an example"</code>, <code class="language-plaintext highlighter-rouge">123</code> 3개의 인자가 들어갔다. 하지만 두 번째 printf에는 <code class="language-plaintext highlighter-rouge">"%d\n"</code>, <code class="language-plaintext highlighter-rouge">456</code> 2개의 인자가 들어갔다.
printf 함수는 첫 번째 인자 문자열에 주어지는 <code class="language-plaintext highlighter-rouge">%</code>의 수에 따라 추가적인 인자가 필요하므로, printf 함수를 만들 때 사용자가 몇 개의 인자를 넣을 것인지 미리 알 수 없다.
이렇게 상황에 따라 함수가 받는 인자의 수를 조절하고 싶을 때 가변 인자를 사용할 수 있다.
<br /></p>
<h2 id="1-1-가변-인자-사용법">1-1. 가변 인자 사용법</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
</span></code></pre></div></div>
<p><br />
가변 인자에 관한 함수와 구조체는 stdarg.h 헤더에 들어 있다.<br />
가변 인자를 갖는 함수의 프로토 타입은 다음과 같다.
<br /></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_args</span><span class="p">,</span> <span class="p">...);</span>
</code></pre></div></div>
<p><br />
가변 인자는 몇 개가 될지 모르므로 <code class="language-plaintext highlighter-rouge">...</code>으로 표시한다. <br />
<u>최소 1개의 고정 인수(위의 경우 num_args)가 필요하다는 점에 유의하자.</u>
이 고정 인수는 뒤에 올 가변 인자의 개수를 알려주는 역할을 한다.</p>

<h2 id="1-2-매크로">1-2. 매크로</h2>
<p>stdarg.h에는  가변 인수를 사용하기 위한 다양한 매크로가 존재한다.</p>

<h3 id="1-2-1-va_list">1-2-1. va_list</h3>
<p>va_list는 가변 인수들의 정보를 담아 놓기 위한 타입이다. 길이가 변할 수 있는 인수들을 저장해야 하기 때문에 va_list 또한 저장 공간의 크기를 유동적으로 늘리고 줄일 수 있는 가변 공간이다.</p>

<div class="notice--warning">
  <p>⚠️ 클러스터 Mac(Intel Mac)에서는 va_list 자료형 자체로 포인터지만, M1 Mac에서는 포인터가 아닌 일반 자료형이다. 따라서 va_list를 통해 가변 인자 값에 접근하는 방식에 있어서 차이가 발생한다.</p>
</div>

<h3 id="1-2-2-va_start">1-2-2. va_start</h3>
<p>va_start는 va_list를 사용하기 전에 초기화하는 역할을 한다. 왜 va_list를 초기화해야 할까?<br />
va_list가 가리키고 있는 주소를 마지막 고정 인자 다음의 첫 번째 가변 인자의 주소로 설정해야 하기 때문이다(va_list는 포인터 임을 잊지 말자).<br />
따라서 va_start는 <code class="language-plaintext highlighter-rouge">va_list</code>, <code class="language-plaintext highlighter-rouge">마지막 고정인자</code> 2개의 인자를 필요로 한다.
<br /></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// ap의 주소를 고정 인자 n 다음, 즉 첫 번째 가변 인자의 주소로 옮긴다.</span>
<span class="p">}</span>
</code></pre></div></div>
<p><br /></p>
<h3 id="1-2-3-va_arg">1-2-3. va_arg</h3>
<p>va_list가 현재 가리키고 있는 인자를 반환하고, va_list의 주소를 다음 인자로 이동시킨다.
첫 번째 인자로 va_list, 두 번째 인자로 현재 인자의 type을 입력받는다.
<br /></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">//ap에서 int 타입의 인자를 반환한다.</span>
<span class="p">}</span>
</code></pre></div></div>
<p><br /></p>

<div class="notice--primary">
  <p>🔔 va_arg로 <code class="language-plaintext highlighter-rouge">char</code>타입 인자를 반환받는 경우, 아래와 같이 char형이 아닌 int 자료형을 두 번째 인자로 넣어줘야 한다. CPU는 메모리를 4bytes씩 접근하는데, char는 1byte만을 차지하기 때문에, 3bytes의 남는 공간이 생긴다. 하지만 1byte만 char형을 넣어놓고 바로 이어서 4bytes인 int형을 넣어 놓는다면, 메모리가 char형을 읽고 다음 4bytes 위치의 메모리에 접근했을 때 int 변수의 시작 주소가 아닌 중간 주소에 접근하는 꼴이 되므로 효율적인 메모리 접근이 불가능하다. 따라서 CPU의 메모리 접근 크기보다 작은 char형은 실질적인 내용은 1byte 밖에 없지만 4bytes의 공간을 차지하도록 할당한다.</p>

  <table>
    <thead>
      <tr>
        <th style="text-align: center">char</th>
        <th style="text-align: center">empty</th>
        <th style="text-align: center">empty</th>
        <th style="text-align: center">empty</th>
        <th style="text-align: center">int</th>
        <th style="text-align: center">int</th>
        <th style="text-align: center">int</th>
        <th style="text-align: center">int</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="text-align: center">메모리 접근</td>
        <td style="text-align: center">————</td>
        <td style="text-align: center">————</td>
        <td style="text-align: center">————</td>
        <td style="text-align: center">메모리 접근</td>
        <td style="text-align: center">————</td>
        <td style="text-align: center">————</td>
        <td style="text-align: center">————</td>
      </tr>
    </tbody>
  </table>

  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div>  </div>
</div>
<p><br /></p>
<h3 id="1-2-4-va_end">1-2-4. va_end</h3>
<p>가변 인자를 모두 사용하고 난 후 실행하는 함수로, ap의 값을 <code class="language-plaintext highlighter-rouge">NULL</code>로 변경한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
</code></pre></div></div>
<p><br /></p>
<h2 id="1-2-예시-코드">1-2. 예시 코드</h2>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"ft_printf.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">ft_printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bytes</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="n">read_format</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span> 
	<span class="c1">// read_format : format을 해석하고, 이에 맞게 출력 후 출력한 글자 byte 수를 리턴해주는 함수</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="42Seoul" /><category term="printf" /><category term="42Seoul" /><category term="ft_printf" /><summary type="html"><![CDATA[printf를 구현해보자.]]></summary></entry><entry><title type="html">get_next_line</title><link href="http://localhost:4000/42seoul/get_next_line/" rel="alternate" type="text/html" title="get_next_line" /><published>2023-10-20T00:00:00+09:00</published><updated>2023-10-20T00:00:00+09:00</updated><id>http://localhost:4000/42seoul/get_next_line</id><content type="html" xml:base="http://localhost:4000/42seoul/get_next_line/"><![CDATA[<h1 id="0-과제-설명">0. 과제 설명</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>파일에서 한 줄씩 읽어오는 함수 get_next_line을 구현한다.
</code></pre></div></div>

<p><br />
<br /></p>
<h1 id="1-fdfile-descriptor">1. fd(File Descriptor)</h1>
<h2 id="file-descriptor">File Descriptor</h2>
<ul>
  <li>파일을 대표하기 위해 시스템으로부터 할당 받은 음수가 아닌 정수</li>
  <li>각각의 프로세스에서 열린 파일의 목록을 관리하는 테이블의 인덱스</li>
</ul>

<p><br />
흔히 유닉스 시스템에 존재하는 모든 것은 파일이라고 한다. 유닉스 시스템에서는 프로세스가 파일들에 접근할 때 ‘파일 디스크립터’라는 개념을 사용한다.</p>

<p>기본적으로 할당되는 파일 디스크립터</p>

<ul>
  <li>0 : 표준 입력(Standard Input)</li>
  <li>1 : 표준 출력 (Standard Output)</li>
  <li>2 : 표준 에러(Standard Error)</li>
</ul>

<p>우리가 파일을 열어서 할당되는 파일 디스크립터들은 3번부터 차례대로 부여받는다.<br />
예를 들어, example.out 이라는 실행파일에서 open() 함수로 “file.txt” 파일을 연다면, file.txt는 fd 3번을 부여 받는다.
<br /></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd2</span><span class="p">;</span>

	<span class="n">fd1</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
	<span class="c1">//file.txt 파일을 첫 번째로 열었으므로 fd1 값은 3이 된다.</span>
	<span class="n">fd2</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"file2.txt"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
	<span class="c1">//file2.txt 파일을 두 번째로 열었으므로 fd2 값은 3 다음 값인 4가 된다.</span>
	
<span class="p">}</span>
</code></pre></div></div>

<h2 id="file-descriptor의-작동-방식">File Descriptor의 작동 방식</h2>

<p><img src="https://mug896.github.io/bash-shell/images/file_descriptor.jpg" alt="fdTable" /></p>

<p>fd는 프로세스가 가지고 있는 fd table의 인덱스이다. <code class="language-plaintext highlighter-rouge">fd = 3</code>인 경우, 위 그림처럼 fd table의 3번째 인덱스로 접근하고, 해당 인덱스가 가리키는 inode table로 가서 파일에 접근해 원하는 행동을 할 수 있는 것이다.</p>

<p>file table의 각 칸들은 mode와 inode table pointer의 offset을 가지고 있다.</p>

<p>inode table은 소유자 그룹, 접근 모드(읽기, 쓰기, 실행 권한), 파일 형태, 고유 번호(inode number) 등 해당 파일에 관한 정보를 가지고 있다.</p>

<p><strong>inode란 무엇일까?</strong><br />
파일을 기술하는 디스크 상의 데이터 구조로써 파일의 데이터 블록이 디스크 상의 어느 주소에 위치하고 있는가와 같은 파일에 대한 중요한 정보를 갖고 있다. 각각의 inode들은 고유 번호(inode number)를 가지고 있어서 파일을 식별할 때 사용한다.<br />
터미널에서 ls -i 옵션으로 inode number를 확인할 수 있다.</p>

<p><br />
<br /></p>
<h1 id="2-file-control을-위한-함수들">2. File Control을 위한 함수들</h1>

<h2 id="open">open()</h2>

<p>Linux, Unix 계열의 시스템에서 Process가 File을 열 때 open 함수 혹은 openat 함수를 사용할 수 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="c1"> // open 함수가 있는 헤더파일이다.</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">openat</span><span class="p">(</span><span class="kt">int</span> <span class="n">dirfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">openat</span><span class="p">(</span><span class="kt">int</span> <span class="n">dirfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>
</code></pre></div></div>

<p>File Descriptor(fd)값을 반환한다. 에러가 나면 -1을 반환한다.</p>

<h2 id="creat">creat()</h2>

<p>새로운 파일 생성은 creat 함수를 이용할 수 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="n">creat</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">)</span>
</code></pre></div></div>

<p>creat 함수의 단점은 write 모드로만 열린다는 것이다. 다시 읽기 위해서는 creat 함수로 만든 파일을 close 함수로 닫고, O_RDONLY로 읽는 과정이 필요하다.</p>

<h2 id="close">close()</h2>

<p>open 함수로 연 파일은 close 함수로 닫을 수 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
</code></pre></div></div>

<p>정상적으로 종료되면 0, 실패하면 -1을 리턴한다.</p>

<h2 id="read">read()</h2>

<p>file을 열고 난 후 데이터를 읽어올 때에는 read 함수를 사용한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>
</code></pre></div></div>

<p>read 함수는 파일로 부터 읽은 데이터를 저장할 공간인 buff를 가리키는 포인터와, 읽을 데이터의 크기를 받아서 정상적으로 종료되면 읽어온 바이트 수를, 실패하면 -1을, 읽을 데이터가 없으면 (파일의 끝에서 시도) 0을 반환한다.</p>

<h2 id="write">write()</h2>

<p>파일을 열고 난 후 데이터를 쓸 때에는 write 함수를 사용한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>
</code></pre></div></div>

<p>정상적으로 종료되면 기록한 바이트 수를, 실패하면 -1을 반환한다.
<br />
<br /></p>
<h1 id="3-static-변수">3. static 변수</h1>

<h2 id="static-변수란">static 변수란?</h2>

<p>static 변수는 전역 변수, 지역 변수 어느 것으로도 이용이 가능하다.</p>

<p>전역이든 지역이든 static 변수는 Data Segment에 위치한다.</p>

<h2 id="외부-정적-변수">외부 정적 변수</h2>

<p>전역으로 선언된 static 변수는 외부 정적 변수라고도 불리며, 별도의 초기화 구문이 없어도 0으로 초기화된다.</p>

<p>→ Data Segment의 BSS 영역에 위치하여 0으로 초기화된다. 초기화 구문 존재 시에는 Data Segment의 Data 영역에 위치한다.</p>

<h2 id="내부-정적-변수">내부 정적 변수</h2>

<p>특정 함수나 클래스 내부에 선언된 static 지역 변수는 내부 정적 변수라고도 불리며, 외부 정적 변수와 마찬가지로 별도의 초기화 구문이 없어도 0으로 초기화 된다. 또한 내부 정적 변수의 경우에도 프로세스의 메모리가 할당되는 프로그램의 시작 시점에 이뤄지기 때문에 함수 실행 등의 코드 실행으로는 초기화가 이뤄지지 않고 무시된다.</p>

<p>초기화 시점이 프로그램의 시작이라서 함수 실행 시 초기화 구문에서 초기화가 안된다고 했는데, 이렇게 되어도 문제가 없는 이유는 static 변수가 함수 혹은 클래스에 대해서 내부 정적 변수로 이용되는 경우에 <u>각 함수 별 혹은 클래스 별로 공유되는 일종의 공유 변수</u>로 이용되기 때문이다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span>	<span class="nf">plus_one</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span>	<span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
	<span class="o">++</span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>		<span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">plus_one</span><span class="p">();</span>
	<span class="n">plus_one</span><span class="p">();</span>
	<span class="n">plus_one</span><span class="p">();</span>
	
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 코드의 경우 static int num이라는 내부 정적 변수의 초기화는 프로그램의 시작에 이뤄지며 초기 값은 1이 된다. 이 때 static int num은 increase_num이라는 함수의 지역 변수처럼 보여 Stack에 위치할 것 같지만, 실제로는 (이 경우에는 초기화 구문이 존재하므로 BSS 영역이 아닌) Data 영역에 위치하고 있다. 위에서 언급했던 초기화 구문이 동작하지 않는다는 얘기는 increase_num 함수 내의 초기화 구문인 static int num = 1이 매 함수 실행마다 이뤄지지 않는다는 말이다. 또한 내부 정적 변수는 특정 함수 혹은 클래스 간 공유되어 사용된다고 했기 때문에 위 main 함수의 실행 결과는 1, 2, 3이 된다.</p>

<div class="notice--warning">
  <p>⚠️ 다른 소스 파일에 존재하는 전역 static 변수 (외부 정적 변수)는 참조할 수 없다.</p>
</div>

<p><br />
<br /></p>
<h1 id="4-주의할-점">4. 주의할 점</h1>

<ul>
  <li>버퍼 한 번 읽을 때 \n\n\n 처럼 개행이 여러번 올 때를 생각하자.</li>
  <li><code class="language-plaintext highlighter-rouge">NULL</code>과 안에 <code class="language-plaintext highlighter-rouge">\0</code>이 들어있는 포인터와는 전혀 다르다. NULL 포인터는 값에 접근하면 segv가 뜬다.</li>
  <li>파일을 읽어서 ‘문자열’로 리턴하는 것이기 때문에, 마지막에 null character terminating을 해줘야 한다.</li>
  <li>리턴할 것이 아니면 free는 웬만하면 malloc한 곳에서 용도가 끝나면 바로 해주는 것이 베스트.
<br />
    <h3 id="bonus-part">bonus part</h3>
  </li>
  <li>연결리스트에서 head는 따로 있는 노드가 아니라, 첫번째 노드를 가리키는 포인터다.</li>
  <li>read가 -1을 리턴했을 때, 모든 노드를 삭제하는 것이 아니라 해당 노드만 삭제해야 한다. 만약 사용자가 실수로 잘못된 fd를 입력했을 때, 기존의 정상 노드까지 다 삭제되어 버리면 남아있던 buf가 사라져서 정보를 잃게 된다. 이렇게 작동하면 사용자가 너무 불편할 것이다. 코드를 짤 때 사용자의 입장에서 생각해보자.</li>
  <li>read가 0을 리턴했을 때는 buf에 남아있는 내용을 리턴해주고 노드를 clear한다.</li>
  <li>node 구조체에 buf_size를 넣어 놓음으로써 ret을 제외한 임시 문자열(buf)의 마지막에 <code class="language-plaintext highlighter-rouge">\0</code>문자를 넣을 필요가 없었다. buf_size를 참고하여 문자열을 순회할 수 있었다. 구조체를 만들 때, 해당 구조체에 필요한 정보가 무엇이 있는지 생각해보고 구조체에 추가해서 코드를 간편하게 줄이자.</li>
</ul>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="42Seoul" /><category term="42Seoul" /><category term="get_next_line" /><category term="fd" /><summary type="html"><![CDATA[파일에서 한 줄씩 읽어오는 함수 get_next_line을 구현한다.]]></summary></entry><entry><title type="html">Libft</title><link href="http://localhost:4000/42seoul/Libft/" rel="alternate" type="text/html" title="Libft" /><published>2023-10-19T00:00:00+09:00</published><updated>2023-10-19T00:00:00+09:00</updated><id>http://localhost:4000/42seoul/Libft</id><content type="html" xml:base="http://localhost:4000/42seoul/Libft/"><![CDATA[<h1 id="0-과제-설명">0. 과제 설명</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>libc에 있는 함수 및 앞으로의 문제를 푸는 데 유용한 함수들을 구현하고 library로 만든다.
</code></pre></div></div>

<p><br />
<br /></p>

<h1 id="1-library">1. Library</h1>

<h2 id="1-1-library란">1-1. Library란?</h2>

<p><strong>라이브러리</strong>는 주로 소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임이다.
비휘발성 자원의 예로는 미리 작성된 코드, 함수, 클래스, 자료형 등이 있다.<br />
라이브러리는 재사용이 필요한 기능의 반복적인 코드 작성을 피하고, 언제든지 필요한 곳에서 호출하여 사용하기 위한 목적을 가지고 만들어진다.<br />
새로운 소스 파일들과 빠르게 링크될 수 있도록 보통 컴파일된 형태인 <code class="language-plaintext highlighter-rouge">object file</code>로 존재하며 미리 컴파일 되어 있기 때문에 컴파일 시간도 단축된다.
<br /></p>
<h2 id="1-2-library의-종류">1-2. Library의 종류</h2>

<p>라이브러리는 크게 <strong>정적 라이브러리</strong>와 <strong>동적 라이브러리</strong> 두 종류로 사용된다.<br />
두 라이브러리의 가장 큰 차이점은 실행파일에 링킹되는 시점이다.</p>

<ul>
  <li>
    <p><strong>정적 라이브러리</strong>(Static Library) (.a / .lib)</p>

    <p>정적으로 만들어진 라이브러리는 링크 단계에서 실행 파일에 포함된다.
  즉, 라이브러리의 동작 코드가 실행 파일에 들어있기 때문에 별도의 추가 작업 없이 실행 파일에서
  바로 라이브러리의 함수들을 사용할 수 있다.
  하지만 실행 파일에서 사용하지 않는 코드가 라이브러리에 많이 담겨 있을수록, 실행 파일의 불필요한 볼륨이
  커지기 때문에 메모리의 공간 활용 효율이 떨어지는 등의 문제가 생긴다.
<br /></p>
  </li>
  <li>
    <p><strong>동적 라이브러리</strong>(Dynamic Library) (.so / .dll)</p>

    <p>컴파일 타임에 링킹되는 정적 라이브러리와 다르게 동적 라이브러리는 런타임에 연결된다.
  정적 라이브러리와의 가장 큰 차이점은, 라이브러리를 사용할 때 각각의 프로세스마다 메모리에 라이브러리 전체 내용을 할당하는 것이 아닌, 필요한 내용만 할당하여 사용할 수 있다는 점이다.
  이러한 특징이 생기는 이유는 obj 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을 복사하지 않고, 해당 모듈의 주소만을 가지고 있다가 런타임에 실행 파일과 라이브러리가 메모리에 위치될 때 해당 모듈의 주소로 가서 필요한 것만 들고 오는 방식이기 때문이다. 런타임에 운영체제에 의하여 이러한 작업이 수행된다.
<br /></p>
  </li>
  <li>
    <p><strong>정적 라이브러리와 동적 라이브러리의 차이점</strong></p>

    <p>정적 라이브러리는 실행할 때 라이브러리의 내용을 모두 메모리에 로드하는 반면, 동적 라이브러리는 메모리에 이미 존재하는 경우 로드되는 시간과 공간을 아낄 수 있다. 하지만 매번 라이브러리의 주소에 접근해야 하기 때문에 오버헤드가 존재해 수행 시간은 정적 라이브러리보다 느리다.</p>
  </li>
</ul>

<p><br /></p>
<h2 id="1-3-라이브러리-만들기">1-3. 라이브러리 만들기</h2>

<p>명령어 ar을 사용한다.<br />
컴파일된 <em>.o 파일들을 묶어서 library (</em>.a)로 만든다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">option</th>
      <th style="text-align: center">meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">-r</td>
      <td style="text-align: center">지정한 파일을 archive 파일에 추가, 만약 기존 파일이면 치환한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">-c</td>
      <td style="text-align: center">archive가 생성 되어질 때 기본적으로 표준 에러로 기록되어지는 진단 메세지의 출력을 제한한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">-u</td>
      <td style="text-align: center">오브젝트 파일의 타임스탬프를 비교해 새로운 파일일 경우에만 치환한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">-v</td>
      <td style="text-align: center">자세한 내용을 보여주는 verbose 모드로, 파일 크기나 갱신 시각 등의 상세 정보를 출력한다.</td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>
<h1 id="2-필요-개념">2. 필요 개념</h1>

<ul>
  <li>
    <p><strong>void pointer로 입력받은 인자를 unsigned char 포인터로 캐스팅해서 접근하는 이유</strong></p>

    <p>void pointer에 어떤 포인터가 들어올지 모르기 때문에 1바이트씩 접근해야 안전하다. 포인터는 주소값이기 때문에 부호를 쓰지 않는다. 따라서 char가 아닌 unsigned char를 쓰는 것이 관례이다.
<br /></p>
  </li>
  <li>
    <p><strong>const int*와 int* const의 차이</strong></p>

    <p>const int<em>( = int const *)는 const int형을 가리키는 포인터로, 포인터 값은 변경 가능하지만 내부의 int값은 const로 선언되어 변경이 불가능하다. 반면 int</em> const는 const 포인터가 int형을 가리키고 있으므로 포인터의 값은 변경 불가능하지만 내부의 int값은 변경이 가능하다.
<br /></p>
  </li>
  <li>
    <p><strong>mem vs str functions</strong></p>

    <p>str함수는 “문자열을 검사하기 위한” 함수. 즉, ‘\0’ 또는 size를 통해서 종료 시점을 결정한다.<br />
  반면 mem 함수는 모든 배열에 대해 사용할 수 있어야 하기 때문에 size만을 통해서 종료 시점을 결정한다.</p>

    <p>함수 내부에서 unsigned char로 캐스팅 해주는 이유 : unsigned char는 변수 안의 모든 값이 부호비트나 패딩비트같이 어떠한 용도로 사용되는 값이 없고, 우리가 전달하고자 하는 값으로 모두 차있기 때문에 비트 해석이 왜곡될 걱정이 없다.</p>

    <p>*패딩비트 : 가장 큰 자료형의 크기를 따르기 때문에 생기는 사용하지 않는 비트
<br /></p>
  </li>
  <li>
    <p><strong>size_t</strong></p>

    <p>size_t는 typedef를 이용하여 정의한 하나의 별칭(alias)으로 ‘이론상 가장 큰 사이즈를 담을 수 있는 unsigned 데이터 타입’으로 정의된다.<br />
  즉, 32bit에서는 unsigned int, 64bit에서는 unsigned long long이 된다.
<br /></p>
  </li>
  <li>
    <p><strong>함수 포인터</strong></p>

    <p>포인터는 다른 변수의 주소를 저장하는 변수다. 이와 유사하게 함수 포인터는 함수의 주소를 저장하는 변수다.</p>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>식별자 foo는 함수의 이름이다. 변수와 마찬가지로 함수는 메모리의 할당된 주소에 있다.</p>

<p>() 연산자를 통해 함수를 호출하면, 호출되는 함수의 주소로 점프하여 실행한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">foo</span><span class="p">();</span> <span class="c1">//foo 함수의 주소(ex.0x002717f0)로 점프한다.</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>함수 foo를 printf로 출력하면 0x002717f0가 출력된다.
<br />
함수 포인터는 함수의 주소를 저장했다가, 해당 주소의 함수를 호출하는 데 사용하는 포인터를 말한다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>반환형식 (* 식별자) (파라미터형 목록)
</code></pre></div></div>

<p>위와 같은 형식으로 사용한다.</p>

<p><br /></p>
<ul>
  <li><strong>함수 포인터 사용법</strong></li>
</ul>

<p>반환값과 매개변수가 없는 경우</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">print_hello</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Hello, world!</span><span class="se">\\</span><span class="s">n"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)();</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">print_hello</span><span class="p">;</span>
	<span class="n">fp</span><span class="p">()</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-&gt;</span> <span class="err">실행결과</span> <span class="o">:</span> <span class="n">Hello</span><span class="p">,</span> <span class="n">world</span><span class="o">!</span>
</code></pre></div></div>

<p>반환값과 매개변수가 있는 경우</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span> <span class="n">fp</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">sub</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span> <span class="n">fp</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

	<span class="o">-&gt;</span> <span class="err">실행결과</span> <span class="o">:</span><span class="mi">8</span>
			   <span class="mi">2</span>
</code></pre></div></div>
<p><br /></p>
<ul>
  <li><strong>함수 포인터 배열 사용하기</strong></li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;}</span>
<span class="kt">int</span> <span class="nf">sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;}</span>
<span class="kt">int</span> <span class="nf">mul</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;}</span>
<span class="kt">int</span> <span class="nf">div</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">[</span><span class="mi">4</span><span class="p">])(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">//함수 포인터 배열 선언</span>
	
	<span class="n">fp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
	<span class="n">fp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub</span><span class="p">;</span>
	<span class="n">fp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mul</span><span class="p">;</span>
	<span class="n">fp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">div</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span> <span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-&gt;</span> <span class="err">실행결과</span> <span class="o">:</span> <span class="mi">30</span>
			<span class="mi">10</span>
			<span class="mi">200</span>
			<span class="mi">2</span>
</code></pre></div></div>
<p><br /></p>
<ul>
  <li><strong>typedef로 함수 포인터 간소화 하기</strong></li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">PtrFunc</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>

<span class="n">PtrFunc</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
</code></pre></div></div>
<p><br /></p>
<ul>
  <li>
    <p><strong>메모리 해제(free)</strong></p>

    <p>동적 메모리를 할당하면 힙(heap) 메모리의 공간을 할당받는다. 이 공간은 프로그램이 종료될 때까지 보존된다. 따라서 메모리를 할당만 하고 해제를 해주지 않으면 메모리 사용량만 계속 증가하게 된다. 즉 프로그램이 필요하지 않은 메모리를 계속 점유하고 있는 현상을 “메모리 누수(memory leak)”라고 한다. 즉 동적 할당으로 힙 메모리에 공간을 생성해놓은 뒤 회수하지 않으면 프로그램이 실행되는 동안은 그 공간은 계속해서 살아있게 되고 이는 메모리의 낭비를 초래하여 성능 부하를 이르킬 수 있다. 고로 사용하지 않는 메모리는 free함수를 사용하여 꼭 회수해줘야 한다.</p>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>
    <p><strong>2의 보수법</strong></p>

    <p>C언어는 2진 보수 방식을 사용한다.<br />
  첫번째 비트가 0일 때는 양수라는 의미로 2진수를 읽듯이 읽으면 된다. 첫번째 비트가 1일 때는 음수라는 의미로 2진 보수를 역(1을 빼고 1진 보수법 적용)으로 취한 값이 절댓값이 된다.<br />
  예를 들어 8비트의 메모리에 10010001 값이 들어 있다면 첫번째 비트가 1이므로 음수를 의미한다. 절댓값을 계산해보면 10010001 → 10010000 → 01101111로 1 + 2 + 4 + 8 + 32 + 64 = 111이다. 즉 10010001은 -111이다.<br />
  2진 보수 방식에서 8비트(1바이트)로 표현할 때 01111111이 가장 큰 정수이고, 10000000이 가장 작은 정수이다.
<br /></p>
  </li>
  <li>
    <p>큰 자료형 → 작은 자료형 형 변환시 뒤쪽(오른쪽) 비트부터 자른다.
<br /></p>
  </li>
</ul>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="42Seoul" /><category term="42Seoul" /><category term="Libft" /><category term="Archive" /><category term="Library" /><summary type="html"><![CDATA[표준 C 라이브러리(libc)에 있는 함수 및 앞으로 과제를 하면서 유용한 함수들을 구현하고 library로 만든다.]]></summary></entry><entry><title type="html">Makefile 문법 및 예시</title><link href="http://localhost:4000/42seoul/Makefile/" rel="alternate" type="text/html" title="Makefile 문법 및 예시" /><published>2023-10-19T00:00:00+09:00</published><updated>2023-10-19T00:00:00+09:00</updated><id>http://localhost:4000/42seoul/Makefile</id><content type="html" xml:base="http://localhost:4000/42seoul/Makefile/"><![CDATA[<h1 id="0-들어가며">0. 들어가며</h1>
<hr />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>빌드를 쉽게 해주는 make와 Makefile에 대해 알아보자.
</code></pre></div></div>

<p><br />
<br /></p>
<h1 id="1-make란">1. make란?</h1>
<hr />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"의존성 관리”와 “증분 빌드” 기능을 갖춘 빌드 도구.
</code></pre></div></div>

<h2 id="1-1-의존성-관리">1-1. 의존성 관리</h2>

<p>빌드 과정에서 의존성에 따른 빌드 순서는 무척 중요하다.<br />
컴파일, 즉 <code class="language-plaintext highlighter-rouge">a.c</code>로 <code class="language-plaintext highlighter-rouge">a.o</code>를 만들고, <code class="language-plaintext highlighter-rouge">a.o</code>로 <code class="language-plaintext highlighter-rouge">a.out</code>을 만드는 상황을 가정하자.<br />
여기서 <code class="language-plaintext highlighter-rouge">a.out</code>은 <code class="language-plaintext highlighter-rouge">a.o</code>에, <code class="language-plaintext highlighter-rouge">a.o</code>는 <code class="language-plaintext highlighter-rouge">a.c</code>에 의존성이 있다고 할 수 있다.</p>

<div class="notice--primary">
  <p>🔔 <code class="language-plaintext highlighter-rouge">.o</code>파일은 컴파일 과정에서 생성되는 오브젝트 파일입니다.</p>
</div>

<p>이번엔 더 복잡한 상황을 생각해 보자.<br />
만약 프로그램 <code class="language-plaintext highlighter-rouge">exec.out</code>을 만들기 위해 <code class="language-plaintext highlighter-rouge">file1.o</code>, <code class="language-plaintext highlighter-rouge">file2.o</code>, <code class="language-plaintext highlighter-rouge">file3.o</code>가 필요하고 각각은 <code class="language-plaintext highlighter-rouge">file1.c</code>, <code class="language-plaintext highlighter-rouge">file2.c</code>, <code class="language-plaintext highlighter-rouge">file3.c</code>가 필요하다면 의존성 관계는 위의 케이스보다 복잡해진다.</p>

<p>실제로 필요한 프로그램을 코딩할 때는 필요한 소스 파일이 한 두개가 아니고, 이 많은 소스 파일들의 의존성을 직접 파악하기란 쉽지 않다.</p>

<p>실행파일을 만들기 위해 순서를 잘 지키면서 과정을 따라가야 한다. make는 규칙을 정의하면 그 규칙에서 적절한 작업 순서를 찾아서, 그 순서대로 작업을 수행한다. 이것을 <strong>의존성 관리</strong>라고 한다.
<br /></p>
<h2 id="1-2-증분-빌드">1-2. 증분 빌드</h2>

<p>만약 의존성을 파악하지 않고 모든 파일을 다시 컴파일 한다면, 변경된 내용이 없는 <code class="language-plaintext highlighter-rouge">.c</code>파일도 모두 다시 <code class="language-plaintext highlighter-rouge">.o</code> 파일로 만들어야 하므로 컴파일에 불필요한 비용이 든다.</p>

<p>소스 파일에 변경된 내용이 있다면, 변경사항이 있는 소스파일만 <code class="language-plaintext highlighter-rouge">.o</code>파일을 새로 만들어 링킹하는 것이 효율적이다.</p>

<p>즉, 의존성 그래프에서 변경사항을 추적해서 변경이 필요한 것들만 다시 만들면 된다. 하지만 이 과정을 직접 하는 것은 두통을 유발할 수 있다. make는 규칙을 잘 정의하면 무언가가 변경되었을 때, 변경이 필요한 것들만 다시 만들어준다. 이것을 <strong>증분 빌드</strong>라고 한다.</p>

<p><br />
<br /></p>
<h1 id="2-makefile이란">2. Makefile이란?</h1>
<hr />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux상에서 반복적으로 발생하는 컴파일을 쉽게하기 위해서 사용하는 make 프로그램의 설정 파일이다.  
make가 규칙을 정의하면 변경이 필요한 것만 만들어 주는 프로그램이라면, Makefile은 그 규칙을 정의하는 파일이다. &lt;br&gt; ## 2-1. 규칙
</code></pre></div></div>

<p>1-1에서의 예시와 같이 <code class="language-plaintext highlighter-rouge">a.c</code> → <code class="language-plaintext highlighter-rouge">a.o</code> → <code class="language-plaintext highlighter-rouge">a.out</code>의 경우를 생각해 보자.</p>

<p>여기서 <code class="language-plaintext highlighter-rouge">a.c</code>는 사람이 직접 만들 파일이므로 <code class="language-plaintext highlighter-rouge">a.c</code>를 만드는 규칙은 필요하지 않다. 따라서 아래의 두 가지 규칙만을 필요로 한다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">a.c</code> → <code class="language-plaintext highlighter-rouge">a.o</code>
    <ul>
      <li>의존성 : a.c</li>
      <li>만드는 법 : cc -c a.c</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">a.o</code> → <code class="language-plaintext highlighter-rouge">a.out</code>
    <ul>
      <li>의존성 : a.o</li>
      <li>만드는 법 : cc a.o -o a.out</li>
    </ul>
  </li>
</ol>

<p>이를 Makefile 문법으로 나타내면 다음과 같다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">a.o</span><span class="o">:</span> <span class="nf">a.c</span>
	cc <span class="nt">-c</span> a.c

<span class="nl">a.out</span><span class="o">:</span> <span class="nf">a.o</span>
	cc a.o <span class="nt">-o</span> a.out
</code></pre></div></div>

<p><br />
위 코드 블럭의 첫 번째 경우, <code class="language-plaintext highlighter-rouge">a.o</code>는 <code class="language-plaintext highlighter-rouge">target</code>, <code class="language-plaintext highlighter-rouge">a.c</code>는 <code class="language-plaintext highlighter-rouge">dependency</code>, <code class="language-plaintext highlighter-rouge">cc -c a.c</code>는 <code class="language-plaintext highlighter-rouge">command</code>라고 부른다.
<code class="language-plaintext highlighter-rouge">target</code>은 <code class="language-plaintext highlighter-rouge">command</code>가 수행되어서 나온 결과 파일을 의미한다.</p>

<p>우선 <code class="language-plaintext highlighter-rouge">(target1) (target2) …: (dependency1) (dependency2) …</code> 처럼 의존 관계를 정의하고, 다음 줄부터 탭으로 들여쓰기 해서 한 줄씩 차례대로 쓰면 된다.
<br /></p>
<h2 id="2-1-변수">2-1. 변수</h2>

<p><u>파일의 이름을 직접 사용하는 것은 좋지 않다.</u><br />
예를 들어 특정 파일의 이름을 여러번 쓴다면, 파일 이름이 바뀌거나 의존성에 변화가 생길 때마다 그 파일 이름을 쓴 모든 곳을 수정해야 한다. 그 중 한 곳이라도 수정하는 것을 잊으면 makefile을 통해 컴파일을 할 때 문제가 생긴다. 이런 문제를 피하기 위해 변수를 사용할 수 있다.</p>

<p>변수는 <code class="language-plaintext highlighter-rouge">변수명 = 값</code> 으로 정의하고, <code class="language-plaintext highlighter-rouge">$(변수명)</code>으로 사용할 수 있다.
변수 하나에 여러 파일을 할당하고 싶으면 <code class="language-plaintext highlighter-rouge">\</code>로 구분하여 할당 가능하다.
아래 예시 코드의 <code class="language-plaintext highlighter-rouge">CFLAGS</code>처럼 플래그도 할당 가능하다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#변수 정의
</span><span class="nv">CC</span> <span class="o">=</span> cc
<span class="nv">SRCS</span> <span class="o">=</span> file1.c <span class="se">\</span>
		file2.c <span class="se">\</span>
		file3.c
		
<span class="nv">OBJS</span> <span class="o">=</span> file1.o <span class="se">\</span>
		file2.o <span class="se">\</span>
		file3.o
		
<span class="nv">TARGET</span> <span class="o">=</span> a.out

<span class="nv">CFLAGS</span> <span class="o">=</span> <span class="nt">-Wall</span> <span class="nt">-Wextra</span> <span class="nt">-Werror</span>

<span class="c">#변수 사용
</span><span class="nl">$(OBJS)</span><span class="o">:</span> <span class="nf">$(SRCS)</span>
	<span class="p">$(</span>CC<span class="p">)</span> <span class="p">$(</span>CFLAGS<span class="p">)</span> <span class="nt">-c</span> <span class="p">$(</span>SRCS<span class="p">)</span>
<span class="nl">$(TARGET)</span><span class="o">:</span> <span class="nf">$(OBJS)</span>
	<span class="p">$(</span>CC<span class="p">)</span> <span class="p">$(</span>OBJS<span class="p">)</span> <span class="nt">-o</span> <span class="p">$(</span>TARGET<span class="p">)</span>
</code></pre></div></div>

<p>이렇게 변수를 정의해두면 파일명이나 컴파일러가 바뀌어도, 그 파일명이나 컴파일러가 쓰인 모든 곳을 바꿀 필요 없이 변수를 정의한 곳만 바꾸면 된다.
<br /></p>
<h2 id="2-2-자동-변수-패턴-규칙">2-2. 자동 변수, 패턴 규칙</h2>

<p>위처럼 모든 파일마다 규칙을 만들어야 한다면 Makefile을 쓰더라도 길이가 매우 길어질 것이다.
보다 간편한 작성을 위해 make는 자동 변수와 패턴 규칙을 제공한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">자동 변수(Automatic Variables)</code>는 Makefile 안에서 사용할 수 있는, 그때그때 자동으로 만들어지는 변수이다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><strong>자동 변수</strong></th>
      <th style="text-align: center"><strong>의미</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">$@</td>
      <td style="text-align: center">만들려는 파일(target) 이름</td>
    </tr>
    <tr>
      <td style="text-align: center">$&lt;</td>
      <td style="text-align: center">의존성 중 첫번째</td>
    </tr>
    <tr>
      <td style="text-align: center">$^</td>
      <td style="text-align: center">모든 의존성</td>
    </tr>
    <tr>
      <td style="text-align: center">$?</td>
      <td style="text-align: center">현재의 target 파일보다 최근에 갱신된 의존성들</td>
    </tr>
  </tbody>
</table>

<p><br /></p>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#예시
</span><span class="nl">a.o</span><span class="o">:</span> <span class="nf">a.c</span>
	cc <span class="nt">-c</span> <span class="nv">$&lt;</span>
<span class="nl">a.out</span><span class="o">:</span> <span class="nf">a.o</span>
	cc <span class="nv">$^</span> <span class="nt">-o</span> <span class="nv">$@</span>
</code></pre></div></div>
<p><br /></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">패턴 규칙(pattern rule)</code>은 반복되는 패턴을 하나의 규칙으로 단순화시킬 때 사용된다. 패턴 규칙에서는 <code class="language-plaintext highlighter-rouge">wildcard %</code>가 사용된다. <code class="language-plaintext highlighter-rouge">%</code>는 어떠한 것과도 매치될 수 있다(shell에서의 *).</li>
</ul>

<p>이런 자동 변수와 패턴을 결합하면 여러 파일에 대한 규칙을 간단하게 정의할 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">TARGET</span> <span class="o">=</span> a.out

<span class="nl">%.o</span><span class="o">:</span> <span class="nf">%.c            //%.o가 a.o라면 %.c도 a.c가 된다. //모든 .c 파일 → .o 파일</span>
	cc <span class="nt">-c</span> <span class="nv">$&lt;</span>
	
<span class="nl">$(TARGET)</span><span class="o">:</span> <span class="nf">a.o</span>
	cc <span class="nv">$^</span> <span class="nt">-o</span> <span class="nv">$@</span>
</code></pre></div></div>
<p><br /></p>
<h2 id="2-3-내장-변수-내장-규칙">2-3. 내장 변수, 내장 규칙</h2>

<p>GNU Make에는 많은 변수와 규칙이 내장되어있다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">내장 변수</th>
      <th style="text-align: center">의미</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">CC</td>
      <td style="text-align: center">C 컴파일러. default : cc</td>
    </tr>
    <tr>
      <td style="text-align: center">CFLAGS</td>
      <td style="text-align: center">C 컴파일러 플래그</td>
    </tr>
    <tr>
      <td style="text-align: center">CXX</td>
      <td style="text-align: center">C++ 컴파일러. default : c++</td>
    </tr>
    <tr>
      <td style="text-align: center">CXXFLAGS</td>
      <td style="text-align: center">C++ 컴파일러 플래그</td>
    </tr>
    <tr>
      <td style="text-align: center">LDFLAGS</td>
      <td style="text-align: center">링커 플래그</td>
    </tr>
    <tr>
      <td style="text-align: center">CPPFLAGS</td>
      <td style="text-align: center">C 전처리기 플래그. C와 C++에 모두 사용</td>
    </tr>
  </tbody>
</table>

<p><br />
이런 내장 규칙을 활용해서 Makefile의 길이를 쉽게 줄일 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">%.o</span><span class="o">:</span> <span class="nf">%.c</span>
	<span class="p">$(</span>CC<span class="p">)</span> <span class="p">$(</span>TARGET_ARCH<span class="p">)</span> <span class="p">$(</span>CPPFLAGS<span class="p">)</span> <span class="p">$(</span>CFLAGS<span class="p">)</span> <span class="nt">-o</span> <span class="nv">$@</span> <span class="nt">-c</span> <span class="nv">$&lt;</span>
<span class="nl">%.o</span><span class="o">:</span> <span class="nf">%.cpp</span>
	<span class="p">$(</span>CXX<span class="p">)</span> <span class="p">$(</span>TARGET_ARCH<span class="p">)</span> <span class="p">$(</span>CPPFLAGS<span class="p">)</span> <span class="p">$(</span>CXXFLAGS<span class="p">)</span> <span class="nt">-o</span> <span class="nv">$@</span> <span class="nt">-c</span> <span class="nv">$&lt;</span>
<span class="nl">%</span><span class="o">:</span> <span class="nf">%.o</span>
	<span class="p">$(</span>CC<span class="p">)</span> <span class="p">$(</span>TARGET_ARCH<span class="p">)</span> <span class="p">$(</span>LOADLIBES<span class="p">)</span> <span class="p">$(</span>LDLIBS<span class="p">)</span> <span class="p">$(</span>LDFLAGS<span class="p">)</span> <span class="nt">-o</span> <span class="nv">$@</span> <span class="nv">$^</span>
</code></pre></div></div>
<p><br /></p>
<h2 id="2-4-phony-규칙">2-4. .PHONY 규칙</h2>

<p>자주 쓰는 명령어를 make에 등록해서 쓸 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">clean</span><span class="o">:</span>
	<span class="nb">rm</span> <span class="nt">-f</span> <span class="k">*</span>.o
</code></pre></div></div>

<p>하지만 위의 경우, clean이라는 파일이 있으면 make clean이 아무것도 실행하지 않는다.
의존성이 없기 때문에 항상 clean 파일이 최신 상태(변경된 의존성 파일이 없는 경우)라고 생각하기 때문이다.</p>

<p>이런 문제를 해결하기 위해 clean을 가짜를 의미하는 .PHONY 타겟으로 지정할 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">clean</span><span class="o">:</span>
	<span class="nb">rm</span> <span class="nt">-f</span> <span class="k">*</span>.o
	
<span class="nl">.PHONY</span><span class="o">:</span> <span class="nf">clean</span>
</code></pre></div></div>

<p>이렇게 clean을 .PHONY 타겟으로 지정하면 clean이라는 파일이 있어도 make clean이 의도대로 동작한다.
<br /></p>
<h2 id="2-5-매크로-치환macro-substitution">2-5. 매크로 치환(Macro substitution)</h2>

<p>필요에 의해 매크로의 내용을 조금 바꾸어야 할 때가 있다. 매크로 내용의 일부만 바꾸기 위해서는 $(MACRO_NAME:OLD=NEW)와 같은 형식을 이용하면 된다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">MY_NAME</span> <span class="o">=</span> HyunsoonIm
<span class="nv">NEW_NAME</span> <span class="o">=</span> <span class="p">$(</span>MY_NAME:Im<span class="o">=</span>Kim<span class="p">)</span>
</code></pre></div></div>

<p>위의 예제에서는 <code class="language-plaintext highlighter-rouge">Im</code>이란 부분이 <code class="language-plaintext highlighter-rouge">Kim</code>으로 바뀌게 된다. 즉 <code class="language-plaintext highlighter-rouge">YOUR_NAME</code>이란 매크로의 값은 <code class="language-plaintext highlighter-rouge">HyunsoonKim</code>이 된다.</p>

<p>매크로 치환을 활용하면 오브젝트 파일들을 쉽게 정의할 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">SRCS</span> <span class="o">=</span> main.c <span class="se">\</span>
		read.c <span class="se">\</span>
		write.c 
		
<span class="nv">OBJS</span> <span class="o">=</span> <span class="p">$(</span>OBJS:.o<span class="o">=</span>.c<span class="p">)</span>
</code></pre></div></div>

<div class="notice--warning">
  <p>⚠ <code class="language-plaintext highlighter-rouge">OBJS : .o = .c</code>처럼 가독성을 위해 띄어쓰지 말 것.<br />
띄어쓰면 makefile이 인식하지 못한다.</p>
</div>

<p>위 예제의 OBJS에는 SRCS에서 .c가 .o로 바뀐 이름들이 할당된다. 즉 아래와 같다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">OBJS</span> <span class="o">=</span> main.o read.o write.o
</code></pre></div></div>
<p><br /></p>
<h2 id="2-6-addprefix접두어-붙이기">2-6. addprefix(접두어 붙이기)</h2>

<p>목적에 맞게 폴더를 나눠서 작업을 하거나, 소스 파일들을 어떤 폴더에 옮겨야 하는 상황일 때, makefile이 소스 파일의 위치를 인지할 수 있도록 변수 앞에 경로를 붙여줘야 한다.</p>

<p>변수의 앞에 문자를 붙일 때, addprefix를 사용하면 간편하게 작업할 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#예를 들어 main.c, read.c, write.c가 my_files 폴더에 있는 경우,
</span>
<span class="nv">SRCS</span> <span class="o">=</span> main.c <span class="se">\</span>
	read.c <span class="se">\</span>
	write.c

<span class="nv">PATH_PREFIX</span> <span class="o">=</span> ./my_files/

<span class="nv">SRCS_WITH_PATH</span> <span class="o">=</span> <span class="p">$(</span>addprefix <span class="p">$(</span>PATH_PREFIX<span class="p">)</span>, <span class="p">$(</span>SRCS<span class="p">))</span>
</code></pre></div></div>
<p><br />
위 코드는 다음과 같은 의미를 갖는다.</p>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">SRCS_WITH_PATH</span> <span class="o">=</span> ./my_files/main.c <span class="se">\</span>
				./my_files/read.c <span class="se">\</span>
				./my_files/write.c
</code></pre></div></div>
<p><br /></p>
<h2 id="2-7-예시">2-7. 예시</h2>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 디렉토리 구조 : ./headers, ./libft, ./srcs
# headers : pipex.h 헤더파일이 있는 디렉토리
# libft : libft.a 아카이브 파일이 있는 디렉토리
# srcs : main.c, init.c 등 소스파일이 있는 디렉토리
</span>
<span class="nv">SRCS_NAME</span> <span class="o">=</span>	main.c <span class="se">\</span>
		init.c <span class="se">\</span>
		parse.c <span class="se">\</span>
		exec.c <span class="se">\</span>
		redirect.c

<span class="nv">OBJS</span> <span class="o">=</span> <span class="p">$(</span>SRCS:.c<span class="o">=</span>.o<span class="p">)</span>
<span class="nv">PREFIX</span> <span class="o">=</span> ./srcs/
<span class="nv">SRCS</span> <span class="o">=</span> <span class="p">$(</span>addprefix <span class="p">$(</span>PREFIX<span class="p">)</span>, <span class="p">$(</span>SRCS_NAME<span class="p">))</span>
<span class="nv">CC</span> <span class="o">=</span> cc
<span class="nv">CFLAGS</span> <span class="o">=</span> <span class="nt">-Wall</span> <span class="nt">-Wextra</span> <span class="nt">-Werror</span> <span class="nt">-c</span>
<span class="nv">HEADER</span> <span class="o">=</span> ./headers
<span class="nv">NAME</span> <span class="o">=</span> pipex

<span class="nv">LIBFT</span> <span class="o">=</span> ft

<span class="nl">all </span><span class="o">:</span> <span class="nf">$(NAME)</span>


<span class="nl">$(NAME) </span><span class="o">:</span> <span class="nf">$(OBJS)</span>
	<span class="nb">cd </span>libft<span class="p">;</span> make<span class="p">;</span> <span class="nb">cd</span> ..
	<span class="p">$(</span>CC<span class="p">)</span> <span class="p">$(</span>OBJS<span class="p">)</span> <span class="nt">-Llibft</span> <span class="nt">-l</span><span class="p">$(</span>LIBFT<span class="p">)</span> <span class="nt">-o</span> <span class="p">$(</span>NAME<span class="p">)</span> <span class="nt">-I</span> <span class="p">$(</span>HEADER<span class="p">)</span>

<span class="nl">%.o </span><span class="o">:</span> <span class="nf">%.c</span>
	<span class="p">$(</span>CC<span class="p">)</span> <span class="p">$(</span>CFLAGS<span class="p">)</span> <span class="nv">$&lt;</span> <span class="nt">-o</span> <span class="nv">$@</span> <span class="nt">-I</span> <span class="p">$(</span>HEADER<span class="p">)</span>

<span class="nl">clean </span><span class="o">:</span>
	<span class="nb">cd </span>libft<span class="p">;</span> make clean<span class="p">;</span> <span class="nb">cd</span> ..
	<span class="nb">rm</span> <span class="nt">-f</span> <span class="p">$(</span>OBJS<span class="p">)</span>

<span class="nl">fclean </span><span class="o">:</span> <span class="nf">clean</span>
	<span class="nb">cd </span>libft<span class="p">;</span> make fclean<span class="p">;</span> <span class="nb">cd</span> ..
	<span class="nb">rm</span> <span class="nt">-f</span> <span class="p">$(</span>NAME<span class="p">)</span>

<span class="nl">re </span><span class="o">:</span> <span class="nf">fclean all</span>


<span class="nl">.PHONY </span><span class="o">:</span> <span class="nf">clean fclean re</span>
</code></pre></div></div>

<p><br /></p>
<h3 id="reference">📬 <strong>Reference</strong></h3>

<ul>
  <li><a href="http://doc.kldp.org/KoreanDoc/html/GNU-Make/GNU-Make.html#toc3">GNU Make 강좌</a></li>
  <li><a href="https://80000coding.oopy.io/6172b586-8056-4cb1-8c4f-2179009aef3f#6172b586-8056-4cb1-8c4f-2179009aef3f">Makefile, make 기초</a></li>
</ul>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="42Seoul" /><category term="42Seoul" /><category term="Linux" /><category term="Make" /><category term="Makefile" /><summary type="html"><![CDATA[리눅스에서 빌드를 편하게 해주는 Makefile에 대해 알아보자.]]></summary></entry><entry><title type="html">Markdown 사용법</title><link href="http://localhost:4000/etc/Markdown/" rel="alternate" type="text/html" title="Markdown 사용법" /><published>2023-10-18T00:00:00+09:00</published><updated>2023-10-18T00:00:00+09:00</updated><id>http://localhost:4000/etc/Markdown</id><content type="html" xml:base="http://localhost:4000/etc/Markdown/"><![CDATA[<h1 id="0-들어가며">0. 들어가며</h1>
<hr />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Github를 구경하다 보면 .md 파일을 자주 만나게 된다.  
이런 파일들은 Markdown 문법으로 작성된 파일이다.  
본 게시글도 Markdown으로 작성되었다.
</code></pre></div></div>

<p><br />
<br /></p>

<h1 id="1-markdown이란">1. Markdown이란?</h1>
<hr />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Markdown은 일반 텍스트 기반의 경량 마크업 언어이다.
마크업 언어란 태그 등을 이용해 문서나 데이터의 구조 등을 명시하는 언어를 말한다.
Markdown은 일반 텍스트로 서식이 있는 문서를 작성하는 데 사용되며,
일반 마크업 언어에 비해 문법이 쉽고 간단한 것이 특징이다.
</code></pre></div></div>

<p><br />
<br /></p>

<h1 id="2-markdown-문법">2. Markdown 문법</h1>
<hr />

<h2 id="2-1-제목header">2-1. 제목(Header)</h2>
<hr />

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	# 제목 1
	## 제목 2
	### 제목 3
	#### 제목 4
	##### 제목 5
	###### 제목 6
</code></pre></div></div>
<p><br /></p>

<h1 id="제목-1">제목 1</h1>
<h2 id="제목-2">제목 2</h2>
<h3 id="제목-3">제목 3</h3>
<h4 id="제목-4">제목 4</h4>
<h5 id="제목-5">제목 5</h5>
<h6 id="제목-6">제목 6</h6>

<p><br /></p>
<h2 id="2-2-강조emphasis">2-2. 강조(Emphasis)</h2>
<hr />
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>이텔릭체는 <span class="ge">*별표(asterisks)*</span> 또는 _언더바(underscore)_를 사용한다.
볼드체는 <span class="gs">**별표(asterisks)**</span> 또는 __언더바(underscore)__를 사용한다.
이텔릭체와 볼드체는 혼용 가능하다. <span class="gs">**_예를 들면_**</span> 또는 __<span class="ge">*이렇게*__</span>
취소선은 ~~물결표시(tilde)~~를 사용한다.
밑줄은 <span class="nt">&lt;u&gt;</span>abc<span class="nt">&lt;/u&gt;</span>를 사용한다.
</code></pre></div></div>
<p><br /></p>

<p>이텔릭체는 <em>별표(asterisks)</em> 또는 _언더바(underscore)_를 사용한다.<br />
볼드체는 <strong>별표(asterisks)</strong> 또는 <strong>언더바(underscore)__를 사용한다.<br />
이텔릭체와 볼드체는 혼용 가능하다. **<em>예를 들면</em>** 또는 __<em>이렇게</em></strong><br />
취소선은 <del>물결표시(tilde)</del>를 사용한다.<br />
밑줄은 <u>abc</u>를 사용한다.</p>

<p><br /></p>
<h2 id="2-3-목록lists">2-3. 목록(Lists)</h2>
<hr />
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">	1.</span> first
<span class="p">	2.</span> second
<span class="p">		-</span> second.first
<span class="p">		-</span> second.second
<span class="p">	3.</span> third<span class="sb">

	1. first
		- dash
		* asterisks
		+ plus

	- dash
	* asterisks
	+ plus
</span></code></pre></div></div>

<p><br /></p>

<ol>
  <li>first</li>
  <li>second
    <ul>
      <li>second.first</li>
      <li>second.second</li>
    </ul>
  </li>
  <li>
    <p>third</p>
  </li>
  <li>first
    <ul>
      <li>dash</li>
      <li>asterisks</li>
      <li>plus</li>
    </ul>
  </li>
</ol>

<ul>
  <li>dash</li>
  <li>asterisks</li>
  <li>plus</li>
</ul>

<p><br /></p>
<h2 id="2-4-링크links">2-4. 링크(Links)</h2>
<hr />
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nv">GOOGLE</span><span class="p">](</span><span class="sx">https://google.com</span><span class="p">)</span>

<span class="p">[</span><span class="nv">Naver</span><span class="p">](</span><span class="sx">https://naver.com</span> <span class="nn">"링크 설명"</span><span class="p">)</span>  

<span class="p">[</span><span class="nv">상대적 참조</span><span class="p">](</span><span class="sx">../users/hyuim</span><span class="p">)</span>

<span class="p">[</span><span class="nv">Hyuim's Blog</span><span class="p">][</span><span class="ss">My Blog Link</span><span class="p">]</span>

문서 안에서 [참조 링크]를 사용할 수도 있다.

아래와 같이 일반 URL이나 꺾쇠 안의 URL은 자동으로 링크로 인식한다.
구글 홈페이지 : https://google.com
네이버 홈페이지 : <span class="nv">&lt;https://naver.com&gt;</span>

<span class="p">[</span><span class="ss">참조 링크</span><span class="p">]:</span> <span class="sx">https://google.com</span> <span class="nn">"구글로 이동하기"</span>
<span class="p">[</span><span class="ss">Hyuim's Blog</span><span class="p">]:</span> <span class="sx">https://hyun-soon.github.io/</span>
</code></pre></div></div>
<p><br /></p>

<p><a href="https://google.com">GOOGLE</a></p>

<p><a href="https://naver.com" title="링크 설명">Naver</a></p>

<p><a href="../users/hyuim">상대적 참조</a></p>

<p>[Hyuim’s Blog][My Blog Link]</p>

<p>문서 안에서 <a href="https://google.com" title="구글로 이동하기">참조 링크</a>를 사용할 수도 있다.</p>

<p>아래와 같이 일반 URL이나 꺾쇠 안의 URL은 자동으로 링크로 인식한다.</p>

<p>구글 홈페이지 : https://google.com</p>

<p>네이버 홈페이지 : <a href="https://naver.com">https://naver.com</a></p>

<p><br /></p>
<h2 id="2-5-이미지images">2-5. 이미지(Images)</h2>
<hr />
<p>링크와 비슷하지만 <u>앞에 ! 가 붙는다</u>.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>![image name](https://cdn.pixabay.com/photo/2019/12/22/17/13/french-bulldog-4713013_1280.jpg)
</code></pre></div></div>
<p><br /></p>

<p><img src="https://cdn.pixabay.com/photo/2019/12/22/17/13/french-bulldog-4713013_1280.jpg" alt="image name" /></p>

<p><br /></p>
<h2 id="2-6-코드블록code-block">2-6. 코드블록(Code block)</h2>
<hr />
<p>코드를 <strong>```</strong>로 감싼다.<br />
<strong>```</strong> 옆에 언어 종류를 적어주면 해당 언어의 문법에 따라 강조 효과를 줄 수 있다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	```c++
		#include &lt;iostream&gt;
	
		using namespace std;
	
		int main()
		{
			cout &lt;&lt; "abc\n";
			return (0);
		}
	```
</code></pre></div></div>
<p><br /></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
	<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

	<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"abc</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>
<h2 id="2-7-표table">2-7. 표(Table)</h2>
<hr />
<p>헤더 셀을 구분할 때 3개 이상의 <code class="language-plaintext highlighter-rouge">-</code> 가 필요하다.<br />
헤더 셀을 구분하면서 <code class="language-plaintext highlighter-rouge">:</code> 으로 열을 나눌 수 있다.<br />
가장 좌측과 우측에 있는 <code class="language-plaintext highlighter-rouge">|</code> 는 생략 가능하다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| Col1 | Col2 | Col3 |
| --- |: --- |: --- |
| a | b | c |
| d | e | f |
| g | h | i |

Col1 | Col2 | Col3
--- |: --- |: ---
a | b | c
d | e | f
g | h | i
</code></pre></div></div>
<p><br /></p>

<table>
  <thead>
    <tr>
      <th>Col1</th>
      <th>Col2</th>
      <th>Col3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>a</td>
      <td>b</td>
      <td>c</td>
    </tr>
    <tr>
      <td>d</td>
      <td>e</td>
      <td>f</td>
    </tr>
    <tr>
      <td>g</td>
      <td>h</td>
      <td>i</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>Col1</th>
      <th>Col2</th>
      <th>Col3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>a</td>
      <td>b</td>
      <td>c</td>
    </tr>
    <tr>
      <td>d</td>
      <td>e</td>
      <td>f</td>
    </tr>
    <tr>
      <td>g</td>
      <td>h</td>
      <td>i</td>
    </tr>
  </tbody>
</table>

<p><br /></p>
<h2 id="2-8-인용문block-quote">2-8. 인용문(Block Quote)</h2>
<hr />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>인용문 예시
&gt; 이렇게 인용문을 사용할 수 있습니다.

중첩된 인용문
&gt; 중첩된 인용문도
&gt;&gt; 이렇게 하면
&gt;&gt; 사용할 수
&gt;&gt;&gt; 있습니다.
&gt;&gt;&gt; example1
&gt;&gt;&gt; example2
&gt;&gt;&gt; example3
</code></pre></div></div>
<p><br /></p>

<p>인용문 예시</p>

<blockquote>
  <p>이렇게 인용문을 사용할 수 있습니다.</p>
</blockquote>

<p>중첩된 인용문</p>

<blockquote>
  <p>중첩된 인용문도</p>
  <blockquote>
    <p>이렇게 하면
사용할 수</p>
    <blockquote>
      <p>있습니다.<br />
example1<br />
example2<br />
example3</p>
    </blockquote>
  </blockquote>
</blockquote>

<p><br /></p>
<h2 id="2-9-수평선horizontal-rule">2-9. 수평선(Horizontal Rule)</h2>
<hr />
<p>다음의 기호들을 3개씩 사용하면 수평선을 만들 수 있다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
(Hyphens)

***
(Asterisks)

___
(Underscores)
</code></pre></div></div>
<p><br /></p>

<hr />
<p>(Hyphens)</p>

<hr />
<p>(Asterisks)</p>

<hr />
<p>(Underscores)</p>

<p><br /></p>
<h2 id="2-10-줄바꿈line-breaks">2-10. 줄바꿈(Line Breaks)</h2>
<hr />
<p>일반 줄바꿈이 동작하지 않는다면, 2번의 띄어쓰기를 줄바꿈으로 사용할 수 있다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>가나다라  &lt;!--2칸의 공백--&gt;
마바사
</code></pre></div></div>
<p><br /></p>

<p>가나다라  <!--2칸의 공백--><br />
마바사</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Etc" /><category term="Etc" /><category term="Markdown" /><summary type="html"><![CDATA[Markdown 사용법을 알아보자.]]></summary></entry></feed>
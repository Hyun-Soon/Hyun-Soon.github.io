<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-07-09T13:22:51+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hyuim’s blog</title><subtitle>Hyuim&apos;s personal blog.</subtitle><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><entry><title type="html">\[Effective C++\] C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자</title><link href="http://localhost:4000/cpp/EffectiveC++05/" rel="alternate" type="text/html" title="\[Effective C++\] C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자" /><published>2024-07-09T00:00:00+09:00</published><updated>2024-07-09T00:00:00+09:00</updated><id>http://localhost:4000/cpp/EffectiveC++05</id><content type="html" xml:base="http://localhost:4000/cpp/EffectiveC++05/"><![CDATA[<p><br /></p>
<h1 id="1-c가-은근슬쩍-만들어-호출해-버리는-함수들에-촉각을-세우자">1. C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자</h1>
<p><br />
C++ 컴파일러는 빈 클래스를 훑고 지나갈 때 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 생성한다. 이들은 모두 inline 함수이고, public이기 때문에 우리가 의도하지 않은 대로 동작할 수 있는 가능성이 생긴다.</p>

<p>예를 들어,</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Empty</span><span class="p">{};</span>
<span class="c1">//위의 코드는</span>
<span class="c1">//아래의 코드와 같다.</span>
<span class="k">class</span> <span class="nc">Empty</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="n">Empty</span><span class="p">()</span> <span class="p">{...};</span>
		<span class="n">Empty</span><span class="p">(</span><span class="k">const</span> <span class="n">Empty</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{...};</span>
		<span class="o">~</span><span class="n">Empty</span><span class="p">()</span> <span class="p">{...};</span>
		<span class="n">Empty</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">EMpty</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{...};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>물론 컴파일러가 이들이 꼭 필요하다고 판단할 때만 만들어지지만, 조건이 그리 대단한 것도 아니다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Empty</span> <span class="n">e1</span><span class="p">;</span> <span class="c1">//기본 생성자, 소멸자</span>
<span class="n">Empty</span> <span class="nf">e2</span><span class="p">(</span><span class="n">e1</span><span class="p">);</span> <span class="c1">//복사 생성자</span>
<span class="n">e2</span> <span class="o">=</span> <span class="n">e1</span><span class="p">;</span> <span class="c1">//복사 대입 연산자</span>
</code></pre></div></div>

<p>소멸자는 해당 클래스가 상속받은 기본 클래스의 소멸자가 가상 소멸자로 되어 있지 않으면 역시 비가상 소멸자로 만들어진다.</p>

<p>생성자의 경우, 인자를 받는 생성자가 클래스 안에 선언이 되어 있으면 컴파일러는 기본 생성자를 만들지 않는다. 즉, 인자를 받지 않는 생성자를 컴파일러가 눈치 없이 만들어서 우리의 의도가 무산될 걱정은 하지 않아도 된다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">NameObject</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="n">NameObject</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
		<span class="p">...</span>
		<span class="c1">//이런 경우에 컴파일러는 NameObject() {...}를 만들지 않는다.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이번엔 복사 대입 연산자에 대해 생각해보자.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">NameObject</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="n">NameObject</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
		<span class="c1">//oprator=은 선언되어 있지 않다.</span>

	<span class="nl">private:</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">nameValue</span><span class="p">;</span>
		<span class="k">const</span> <span class="n">T</span> <span class="n">objectValue</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newDog</span><span class="p">(</span><span class="s">"DooBoo"</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">oldDog</span><span class="p">(</span><span class="s">"BangWool"</span><span class="p">);</span>

	<span class="n">NameObject</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="n">newDog</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">NameObject</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">(</span><span class="n">oldDog</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 코드의 <code class="language-plaintext highlighter-rouge">p = s</code>에서  어떤 일이 발생할까?
reference는 원래 자신이 참조하고 있는 것과 다른 객체를 참조할 수 없기 때문에 p.nameValue가 s.nameValue가 참조하는 객체를 가리키도록 바뀌는 것은 불가능하다. 그렇다면 p.nameValue가 참조하는 string 객체 자체가 바뀌는 게 맞을까? 이 역시도 해당 string을 참조하거나 포인터를 갖고 있는 다른 객체에 영향을 주기 때문에 적절한 방식이 아니다.</p>

<p>이런 문제들에 대해, C++는 시원하게 컴파일을 거부해버린다. 따라서 reference를 데이터 멤버로 갖고 있는 클래스에 대해 대입 연산을 지원하려면 직접 복사 대입 연산자를 정의해줘야 한다. objectValue처럼 데이터 멤버가 상수인 경우에도 컴파일러가 비슷하게 동작한다.</p>

<p>상속 받는 기본 클래스가 복사 대입 연산자를 private로 선언해 놓은 경우, 자식 클래스는 암시적 복사 대입 연산자를 가질 수 없다. 자식 클래스에서 호출할 권한이 없기 때문에 이 역시 컴파일러가 거부해 버리기 때문이다.</p>

<p class="notice--primary">🔔 컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Cpp" /><category term="Cpp" /><category term="Cplusplus" /><category term="EffectiveCplusplus" /><summary type="html"><![CDATA[Effective C++ 항목 05 정리]]></summary></entry><entry><title type="html">\[Effective C++\] 낌새만 보이면 const를 들이대 보자!</title><link href="http://localhost:4000/cpp/EffectiveC++03/" rel="alternate" type="text/html" title="\[Effective C++\] 낌새만 보이면 const를 들이대 보자!" /><published>2024-07-09T00:00:00+09:00</published><updated>2024-07-09T00:00:00+09:00</updated><id>http://localhost:4000/cpp/EffectiveC++03</id><content type="html" xml:base="http://localhost:4000/cpp/EffectiveC++03/"><![CDATA[<p><br /></p>
<h1 id="1-const_iterator">1. const_iterator</h1>
<p><br /></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span> <span class="c1">//int 값이 const</span>
<span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">;</span> <span class="c1">//int 값이 const</span>
<span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span><span class="p">;</span> <span class="c1">//ptr이 const</span>
</code></pre></div></div>

<p>STL iterator는 포인터를 본뜬 것이기 때문에 기본 동작 원리가 T* 포인터와 매우 흡사하다. 변경이 불가능한 객체를 가리키는 iterator가 필요하다면, <code class="language-plaintext highlighter-rouge">const_iterator</code>를 사용하면 된다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span> <span class="c1">//iter가 const</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">cIter</span><span class="p">;</span> <span class="c1">//cIter가 가리키는 값이 const</span>
<span class="c1">//</span>
</code></pre></div></div>
<p><br /></p>
<h1 id="2-상수-멤버-함수">2. 상수 멤버 함수</h1>
<p><br />
멤버 함수 끝에 붙는 const 키워드의 역할은 “해당 멤버 함수가 상수 객체에 대해 호출될 수 있는 함수이다”라는 사실을 알려주는 것이다. C++ 프로그램의 실행 성능을 높이는 핵심 기법 중 하나는 객체 전달을 ‘상수 객체에 대한 참조자(reference-to-const)’로 진행하는 것이다. 이 기법이 제대로 동작하려면 const 멤버 함수가 존재해야 한다. const 키워드가 있고 없고의 차이만 있는 멤버 함수들은 오버로딩이 가능하다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TextBloack</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="p">...</span>

		<span class="c1">//상수 객체에 대한 operator[]</span>
		<span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="c1">//비상수 객체에 대한 operator[]</span>
		<span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
		<span class="p">}</span>

	<span class="k">private</span><span class="o">:</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">TextBlock</span> <span class="n">tb</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//비상수 멤버 함수를 호출한다.</span>

	<span class="k">const</span> <span class="n">TextBlock</span> <span class="n">ctb</span><span class="p">(</span><span class="s">"World"</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ctb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//상수 멤버 함수를 호출한다.</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>멤버 함수가 상수 멤버라는 것은 두가지 개념을 내포한다.</p>
<ol>
  <li>bitwise constness(physical constness) 비트수준 상수성</li>
  <li>logical constness 논리적 상수성</li>
</ol>

<p>비트수준 상수성은 어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야 그 멤버 함수가 ‘const’임을 인정하는 개념이다. 그런데, 애석하게도 ‘제대로 const’로 동작하지 않는데도 이 비트수준 상수성 검사를 통과하는 멤버 함수들이 존재한다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CTextBlock</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="p">...</span>

		<span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span> <span class="k">const</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">pText</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
		<span class="p">}</span>

	<span class="k">private</span><span class="o">:</span>
		<span class="kt">char</span><span class="o">*</span> <span class="n">pText</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>operator[]의 내부 코드만 보면 pText를 건드리지 않으므로 컴파일러는 operator[] 코드를 생성할 때 불평할 이유가 없다. 하지만 reference를 반환하고 있으므로 다른 코드에서 operater[]를 이용해 pText의 값을 바꿀 위험이 있다. 상수 멤버 함수를 사용했지만 비트수준 상수성이 깨질 가능성이 있다는 말이다.</p>

<p>논리적 상수성은 이런 황당한 상황을 보완하는 대체 개념으로 나오게 되었다.
상수 멤버 함수라고 해서 객체의 한 비트도 수정할 수 없는 것이 아니라 일부 몇 비트 정도는 바꿀 수 있되, 그것을 사용자(이 책에서는 이 코드를 사용하는 다른 프로그래머도 사용자라고 칭한다) 측에서 알아채지 못하게만 하면 상수 멤버 자격이 있다는 것이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CTextBlock</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="p">...</span>

		<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

	<span class="nl">private:</span>

		<span class="kt">char</span><span class="o">*</span> <span class="n">pText</span><span class="p">;</span>
		
		<span class="c1">//mutable은 non-static 데이터 멤버를 비트 수준 상수성의 족쇄에서 해방시켜준다.</span>
		<span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">textLength</span><span class="p">;</span>
		<span class="k">mutable</span> <span class="kt">bool</span> <span class="n">lengthIsValid</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">CTextBlock</span><span class="o">::</span><span class="n">length</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lengthIsValid</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">textLength</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">strlen</span><span class="p">(</span><span class="n">pText</span><span class="p">);</span>
		<span class="n">lengthIsValid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">textLength</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>
<h1 id="3-상수-멤버-및-비상수-멤버-함수에서-코드-중복-현상을-피하는-방법">3. 상수 멤버 및 비상수 멤버 함수에서 코드 중복 현상을 피하는 방법</h1>
<p><br />
단순히 문자를 리턴하는 것이 아니라 operator[] 내부에서 경계 검사, 자료 무결성 검증 등 다양한 일을 한다고 생각해보자.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TextBlock</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="p">...</span>

		<span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span>
		<span class="p">{</span>
			<span class="p">...</span> <span class="c1">//경계 검사</span>
			<span class="p">...</span> <span class="c1">//자료 무결성 검증</span>
			<span class="p">...</span> <span class="c1">//등등</span>
			<span class="p">...</span>
			<span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="p">...</span> <span class="c1">//경계 검사</span>
			<span class="p">...</span> <span class="c1">//자료 무결성 검증</span>
			<span class="p">...</span> <span class="c1">//등등</span>
			<span class="p">...</span>
			<span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
		<span class="p">}</span>

	<span class="k">private</span><span class="o">:</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>같은 기능을 하지만 const 때문에 코드 중복이 발생한다. 이 때 코드 중복을 피할 수 있는 방법이 있는데, 주의할 점이 있다. const가 아닌 것에 const를 붙이는 것은 안전하지만, 이미 const인 것에서 const를 떼어내는 것은 위험하다는 점을 생각하자.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TextBlock</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="p">...</span>

		<span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span> <span class="c1">//이전과 동일</span>
		<span class="p">{</span>
			<span class="p">...</span>
		<span class="p">}</span>

		<span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&amp;&gt;</span><span class="p">(</span>
						<span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">TextBlock</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">position</span><span class="p">]</span>
						<span class="p">);</span>
		<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p class="notice--primary">🔔 const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다. const는 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을 수 있고, 멤버 함수에도 붙을 수 있다.<br />
🔔 컴파일러 쪽에서 보면 비트 수준 상수성을 지켜야 하지만, 프로그래머는 논리적 상수성을 사용해서 프로그래밍하는 방법도 있다는 것을 알아두자.<br />
🔔 상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드 중복을 피하는 것이 좋은데, 이때 비상수 버전이 상수 버전을 호출하도록 만들어라.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Cpp" /><category term="C++" /><category term="Cpp" /><category term="EffectiveC++" /><summary type="html"><![CDATA[Effective C++ 항목 03 정리]]></summary></entry><entry><title type="html">\[Effective C++\] \#define을 쓰려거든 const, enum, inline을 떠올리자</title><link href="http://localhost:4000/cpp/EffectiveC++02/" rel="alternate" type="text/html" title="\[Effective C++\] \#define을 쓰려거든 const, enum, inline을 떠올리자" /><published>2024-07-09T00:00:00+09:00</published><updated>2024-07-09T00:00:00+09:00</updated><id>http://localhost:4000/cpp/EffectiveC++02</id><content type="html" xml:base="http://localhost:4000/cpp/EffectiveC++02/"><![CDATA[<p><br /></p>
<h1 id="1-define을-쓰려거든-const-enum-inline을-떠올리자">1. #define을 쓰려거든 const, enum, inline을 떠올리자</h1>
<p><br />
다시 말하면 “가급적 선행 처리자보다 컴파일러를 더 가까이 하자”는 뜻이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define ASPECT_RATIO 1.653
</span>
<span class="p">...</span>
</code></pre></div></div>

<p>위와 같이 작성된 코드가 있다고 하자. 위 소스 코드는 컴파일러로 넘어가기 전에 선행 처리자가 ASPECT_RATIO라는 이름을 밀어버리고 숫자 상수(1.653)로 대체한다. 그 결과 ASPECT_RATIO는 컴파일러가 쓰는 기호 테이블에 들어가지 않고, 이는 컴파일 에러를 해결할 때 어려움을 겪게 할 수 있다. 특히, 코드를 작성하지 않은 다른 사람이 이를 해결하려고 하면 더욱 난감할 것이다.</p>

<p>이 문제의 해결법은 매크로 대신 상수를 쓰는 것이다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">double</span> <span class="n">AspectRatio</span> <span class="o">=</span> <span class="mf">1.653</span><span class="p">;</span>
</code></pre></div></div>
<p>위의 AspectRatio는 언어 차원에서 지원하는 상수 타입의 데이터이기 때문에 당연히 컴파일러의 눈에도 보이며 기호 테이블에 들어간다.</p>

<p>또한 위의 예시처럼 작성할 경우, 컴파일을 거친 최종 코드의 크기가 <code class="language-plaintext highlighter-rouge">#define</code>을 썼을 때 보다 더 작을 수 있다. <code class="language-plaintext highlighter-rouge">#define</code>의 경우 선행 처리자가 코드 상의 ASPECT_RATIO를 1.653으로 바꾸는 만큼 1.653의 사본이 많이 생기는 반면, AspectRatio는 한 개의 변수만 존재하기 때문이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>상수 정의는 대개 헤더 파일에 넣는 것이 관례이다.
</code></pre></div></div>

<p>만약 클래스 멤버로 상수를 정의하는 경우, 그 상수의 사본 개수가 한 개를 넘지 못하게 하고 싶다면 <code class="language-plaintext highlighter-rouge">static</code> 멤버로 만들어야 한다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GamePlayer</span>
<span class="p">{</span>
	<span class="nl">private:</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">scores</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
		<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>보통은 위와 같이 클래스 안에 선언하는 것이 문제가 되지 않지만, 클래스 상수의 주소를 구하거나 구식 컴파일러의 경우 정의를 구현 파일에서 제공해야 한다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">GamePlayer</span><span class="o">::</span><span class="n">c</span><span class="p">;</span>
</code></pre></div></div>

<p>웬만한 경우에는 이것으로 해결이 되지만, GamePlayer::scores와 같이 배열을 선언할 때 컴파일러가 컴파일 과정에서 이 배열의 크기를 알아야 한다며 문제를 일으킬 수 있다. 이 경우에는 <code class="language-plaintext highlighter-rouge">enum hack</code> 기법을 떠올리자.</p>

<p><code class="language-plaintext highlighter-rouge">enum hack</code>은 enumerator 타입의 값은 int가 놓일 곳에도 쓰일 수 있다는 사실을 활용하는 것이다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GamePlayer</span>
<span class="p">{</span>
	<span class="nl">private:</span>
		<span class="k">enum</span> <span class="p">{</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">};</span>

		<span class="kt">int</span> <span class="n">scores</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">enum hack</code>의 동작 방식은 <code class="language-plaintext highlighter-rouge">const</code>보다 <code class="language-plaintext highlighter-rouge">#define</code>에 더 가깝다. enum의 주소를 취하는 것은 불법이며 #define의 주소를 얻는 것 역시 마찬가지다. 따라서 선언한 정수 상수를 가지고 다른 사람이 주소를 얻거나 참조자를 쓰는 것이 싫다면 enum은 아주 좋은 자물쇠가 될 수 있다.</p>

<p>#define을 오용하는 또다른 사례로 매크로 함수가 있다. 함수 호출 오버헤드를 일으키지 않는다는 점에서 매크로 함수를 사용하지만 문제가 있다. 아래는 매크로 인자들 중 큰 것을 사용해 어떤 함수 f를 호출하는 매크로이다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))
</span></code></pre></div></div>

<p>매크로를 작성할 때는 매크로 본문에 들어 있는 인자마다 반드시 괄호를 씌워줘야 한다. 하지만 이 부분을 제대로 처리했다고 해도 문제가 발생한다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">CALL_WITH_MAX</span><span class="p">(</span><span class="o">++</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>  <span class="c1">// a가 두 번 증가한다.</span>
<span class="n">CALL_WITH_MAX</span><span class="p">(</span><span class="o">++</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">+</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// a가 한 번 증가한다.</span>
</code></pre></div></div>

<p>비교의 결과로 어떤 인자를 가져오느냐에 따라 결과가 달라지는 문제가 발생한다.
함수 호출을 없애 주는 매크로의 효율을 그대로 유지하면서 정규 함수의 모든 동작방식 및 타입 안전성까지 완벽히 취할 수 있는 방법이 있다.
바로 “인라인 함수 템플릿”이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">callWithMax</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">f</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 함수는 템플릿이기 때문에 동일 계열 함수군(family of functions)을 만들어낸다. 또한 진짜 함수이기 때문에 유효범위 및 접근 규칙을 그대로 따라간다.</p>

<p class="notice--primary">🔔 단순한 상수를 쓸 때는, #define보다 const 객체 혹은 enum을 우선 떠올리자.
🔔 함수처럼 쓰이는 매크로를 만들려면, #define 매크로보다 인라인 함수를 우선 떠올리자.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Cpp" /><category term="C++" /><category term="Cpp" /><category term="EffectiveC++" /><summary type="html"><![CDATA[Effective C++ 항목 02 정리]]></summary></entry><entry><title type="html">\[Effective C++\] C++를 언어들의 연합체로 바라보는 안목은 필수</title><link href="http://localhost:4000/cpp/EffectiveC++01/" rel="alternate" type="text/html" title="\[Effective C++\] C++를 언어들의 연합체로 바라보는 안목은 필수" /><published>2024-07-09T00:00:00+09:00</published><updated>2024-07-09T00:00:00+09:00</updated><id>http://localhost:4000/cpp/EffectiveC++01</id><content type="html" xml:base="http://localhost:4000/cpp/EffectiveC++01/"><![CDATA[<p><br /></p>
<h1 id="1-c를-언어들의-연합체로-바라보는-안목을-갖자">1. C++를 언어들의 연합체로 바라보는 안목을 갖자</h1>
<p><br /></p>

<p>c++는 오늘날 <code class="language-plaintext highlighter-rouge">다중패러다임 프로그래밍 언어(multiparadigm programming language)</code>라고 불린다.절차적 프로그래밍을 기본으로 객체 지향, 함수식, 일반화, 메타 프로그래밍 개념까지 지원하고 있다. 이렇게 복잡한 c++를 제대로 이해하기 위해서는 시각을 바꿔 c++를 여러 언어들의 연합체로 바라봐야 한다. 즉, c++가 여러 개의 하위 언어를 제공한다는 점을 이해해야 한다.</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">C</code> : C++는 C를 기본으로 하고 있다. 블록, 문장, 선행 처리자 등 많은 것을 C에서 가져왔다.</li>
  <li>객체 지향 개념의 C++ : 이 부분에 ‘클래스를 쓰는 C’에 관한 모든 것이 해당된다. 클래스, 캡슐화, 상속, 다형성, 가상 함수(동적 바인딩) 등..</li>
  <li>템플릿 C++ : C++의 일반화 프로그래밍 부분이다. 오늘날 템플릿이 C++에 끼치는 영향은 매우 거대하며 이로 인해 <code class="language-plaintext highlighter-rouge">템플릿 메타프로그래밍(template metaprogramming: TMP</code>이라는 새로운 프로그래밍 패러다임이 파생되었다.</li>
  <li>STL : 이름에서 알 수 있듯 템플릿 라이브러리이다. STL은 <code class="language-plaintext highlighter-rouge">container</code>, <code class="language-plaintext highlighter-rouge">iterator</code>, <code class="language-plaintext highlighter-rouge">algorithm</code>, <code class="language-plaintext highlighter-rouge">function object</code>들이 얽혀 돌아가는 것을 규약으로 삼고 있으나, 템플릿과 라이브러리는 얼마든지 다른 아이디어를 중심으로 만들어질 수 있다. 또한 나름대로 독특한 사용규약이 있어서, STL을 써서 프로그래밍하려면 그 규약을 따라야 한다.</li>
</ol>

<p>위 네 가지의 하위 언어들이 C++을 이루고 있다는 점을 명심하고, 한 언어에서 다른 언어로 옮겨 가면서 대응 전략을 바꾸어야 하는 상황에서 이를 잘 활용해야 한다.</p>

<p>예를 들어, C 스타일로만 쓰고 있으면 기본제공 타입에 대해서는 “값 전달이 참조 전달보다 대개 효율이 더 좋다”라는 규칙이 통하지만, C++의 C 부분만 쓰다가 객체 지향 C++로 옮겨 가면 사용자 정의 생성자/소멸자 개념이 생기면서 상수 객체 참조자에 의한 전달(pass-by-reference-to-const) 방식이 더 좋은 효율을 보인다.</p>

<p>이런 현상은 템플릿 C++를 쓸 때 특히 두드러지는데, 왜냐하면 템플릿 C++의 세계에서는 우리가 손에 들고 있는 객체의 타입조차 알 수 없기 때문이다.</p>

<p>그러나 STL 쪽으로 넘어오면 전세가 또 바뀌게 된다. STL을 배우다 보면 iterator와 function object가 C의 포인터를 본떠 만든 것이란 점을 알게 되고, 그렇기 때문에 STL의 iterator 및 function object에 대해서는 값 전달에 대한 규칙이 다시 제 힘을 발휘하게 된다.</p>

<p>C++는 한 가지 프로그래밍 규칙 아래 똘똘 뭉친 통합 언어(unified language)가 아니라 네 가지 하위 언어들의 연합체이다. 즉, 각각의 하위 언어가 자신만의 규칙을 갖고 있다. “하위 언어들로 구성되어 있다”라는 점을 꼭 새겨두도록 하자.</p>

<p class="notice--primary">🔔 C++를 사용한 효과적인 프로그래밍 규칙은 경우에 따라 달라진다. 그 경우란, 바로 C++의 어떤 부분을 사용하느냐이다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Cpp" /><category term="C++" /><category term="Cpp" /><category term="EffectiveC++" /><summary type="html"><![CDATA[Effective C++ 항목 01 정리]]></summary></entry><entry><title type="html">\[Effective C++\] 객체를 사용하기 전에 반드시 그 객체를 초기화하자</title><link href="http://localhost:4000/cpp/EffectiveC++04/" rel="alternate" type="text/html" title="\[Effective C++\] 객체를 사용하기 전에 반드시 그 객체를 초기화하자" /><published>2024-07-09T00:00:00+09:00</published><updated>2024-07-09T00:00:00+09:00</updated><id>http://localhost:4000/cpp/EffectiveC++04</id><content type="html" xml:base="http://localhost:4000/cpp/EffectiveC++04/"><![CDATA[<p><br /></p>
<h1 id="1-객체를-사용하기-전에-반드시-그-객체를-초기화하자">1. 객체를 사용하기 전에 반드시 그 객체를 초기화하자</h1>
<p><br /></p>

<p>초기화 리스트를 사용하면 멤버 데이터들의 복사 생성자를 사용하여, 멤버 데이터를 생성과 동시에 초기화할 수 있다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PhoneBook</span>
<span class="p">{</span>
	<span class="nl">private:</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">phoneNumber</span><span class="p">;</span>

	<span class="nl">public:</span>
		<span class="p">...</span>
		<span class="n">PhoneBook</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">inputName</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">inputPhoneNumber</span><span class="p">)</span>
		<span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">inputName</span><span class="p">),</span> <span class="n">phoneNumber</span><span class="p">(</span><span class="n">inputPhoneNumber</span><span class="p">)</span>
		<span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이떤 클래스의 멤버 데이터가 있다. 멤버 초기화 리스트에 들어있지 않더라도 그 데이터 타입이 사용자 정의 타입이면 컴파일러는 자동으로 그들 멤버에 대해 기본 생성자를 호출한다. 하지만 실수를 줄이기 위해 웬만하면 모든 데이터 멤버는 초기화 리스트에서 초기화 해주도록 하자.</p>

<p>기본 생성자로 초기화하고 싶은 경우에도 초기화 리스트에 명시해주는 습관을 들이자.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PhoneBook</span><span class="p">()</span> <span class="o">:</span> <span class="n">name</span><span class="p">(),</span> <span class="n">phoneNumber</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>

<p>c++의 기본 제공 타입(bool, char, …)은 생성과 동시에 초기화하나, 생성 후에 대입을 하나 걸리는 시간이 똑같지만 가독성을 위해 초기화 리스트에 넣어주자. 기본 제공 타입을 반드시 초기화 리스트에 넣어야 할 경우가 있는데, 바로 <code class="language-plaintext highlighter-rouge">const</code> 또는 <code class="language-plaintext highlighter-rouge">reference</code>일 경우이다. const와 reference는 생성과 동시에 초기화되어야 한다.</p>

<p>C++에서 객체의 초기화 순서는 컴파일러를 막론하고 똑같다.</p>
<ol>
  <li>기본 클래스는 파생 클래스보다 먼저 초기화된다.</li>
  <li>클래스 데이터 멤버는 그들이 선언된 순서대로 초기화된다.
멤버 초기화 리스트에 넣는 순서도 선언된 순서대로 넣어주도록 하자.</li>
</ol>

<p>초기화 순서에 대한 하나의 문제가 남아있다.
“비지역 정적 객체(non-local static object)의 초기화 순서는 개별 번역 단위(translation unit)에서 정해진다”는 것이다.</p>

<p><code class="language-plaintext highlighter-rouge">정적 객체(static object)</code>는 자신이 생성된 시점부터 프로그램이 끝날 때까지 살아 있는 객체를 일컫는다.
정적 객체의 범주에 들어가는 것은 5가지가 있다.</p>
<ol>
  <li>전역 객체</li>
  <li>네임스페이스 유효범위에서 정의된 객체</li>
  <li>클래스 안에서 static으로 선언된 객체</li>
  <li>함수 안에서 static으로 선언된 객체</li>
  <li>파일 유효범위에서 static으로 정의된 객체</li>
</ol>

<p>이들 중 함수 안에 있는 정적 객체는 지역 정적 객체(local static object)라 하고(함수에 대해 지역성을 가지므로), 나머지는 비지역 정적 객체(non-local static object)라 한다.</p>

<p><code class="language-plaintext highlighter-rouge">번역 단위(translation unit)</code>는 컴파일을 통해 하나의 목적 파일(object file)을 만드는 바탕이 되는 소스 코드를 일컫는다. 여기서 번역은 소스의 언어를 기계어로 옮긴다는 의미다. 기본적으로는 소스 파일 하나가 되는데, 그 파일이 #include하는 파일들까지 합쳐서 하나의 번역 단위가 된다.</p>

<p>즉 위에서 말한 문제는, 별도로 컴파일된 소스 파일이 두 개 이상 있으며 각 소스 파일에 비지역 정적 객체가 한 개 이상 들어 있는 경우에서, 한 쪽의 정적 객체가 초기화되지 않은 상황에 다른 쪽에서 이 객체를 사용할 때 발생하는 문제를 말한다.</p>

<p>예를 들어, 파일 시스템에 관한 라이브러리가 있고 사용자가 이를 이용해 디렉토리 클래스를 만든다고 하자.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//파일 시스템 라이브러리</span>
<span class="k">class</span> <span class="nc">FileSystem</span> <span class="c1">//라이브러리에 포함된 클래스</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="p">...</span>
		<span class="n">std</span><span class="o">::</span><span class="n">stize_t</span> <span class="n">numDisks</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">//많고 많은 멤버 함수들 중 하나</span>
		<span class="p">...</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="n">FileSystem</span> <span class="n">tfs</span><span class="p">;</span> <span class="c1">//사용자가 쓰게 될 객체</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//사용자가 라이브러리를 이용해 만든 클래스</span>
<span class="k">class</span> <span class="nc">Directory</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="n">Directory</span><span class="p">(</span> <span class="n">params</span> <span class="p">);</span>
		<span class="p">...</span>
<span class="p">};</span>

<span class="n">Directory</span><span class="o">::</span><span class="n">Directory</span> <span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">disks</span> <span class="o">=</span> <span class="n">tfs</span><span class="p">.</span><span class="n">numDisks</span><span class="p">();</span> <span class="c1">//tfs 객체를 여기서 사용함</span>
	<span class="p">...</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Directory</span> <span class="n">tempDir</span><span class="p">(</span> <span class="n">params</span> <span class="p">);</span> <span class="c1">//임시 파일을 담는 디렉토리 //여기서 문제가 발생한다.</span>
	<span class="p">...</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>정적 객체 tfs의 초기화 순서 때문에 이런 상황에서 문제가 발생한다. tfs가 tempDir보다 먼저 초기화되지 않으면, tempDir의 생성자는 tfs가 초기화되지 않았는데도 tfs를 사용하려고 시도한다.</p>

<p>non-local static object의 초기화 순서가 정해져 있지 않은 상황에서 이 문제를 어떻게 해결할까?
함수 안에 집어넣어 <code class="language-plaintext highlighter-rouge">Singleton pattern</code>을 활용하면 된다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">'''</span><span class="n">FileSystem</span><span class="err">'''</span>

<span class="k">class</span> <span class="nc">FileSystem</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>

<span class="n">FileSystem</span><span class="o">&amp;</span> <span class="n">tfs</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">FileSystem</span> <span class="n">fs</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">fs</span><span class="p">;</span>
<span class="p">}</span>


<span class="err">'''</span><span class="n">Directory</span><span class="err">'''</span>

<span class="p">...</span>

<span class="n">Directory</span><span class="o">&amp;</span> <span class="n">tempDir</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">Directory</span> <span class="n">td</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">td</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이런 식으로 함수의 return을 받아 사용하게 되면 초기화 문제를 해결할 수 있다.</p>

<p>정리하자면, 어떤 객체가 초기화되기 전에 그 객체를 사용하는 사용하는 일이 생기지 않도록 하려면 세가지를 기억하자.</p>
<ol>
  <li>멤버가 아닌 기본제공 타입 객체는 직접 초기화 해야 한다.</li>
  <li>객체의 모든 부분에 대한 초기화에는 멤버 초기화 리스트를 사용한다.</li>
  <li>별개의 번역 단위에 정의된 비지역 정적 객체에 영향을 끼치는 불확실한 초기화 순서를 염두에 두고 이러한 불확실성을 피해서 프로그램을 설계해야 한다.</li>
</ol>

<p class="notice--primary">🔔 기본제공 타입의 객체는 직접 손으로 초기화한다.<br />
🔔 생성자에서는, 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방법으로 멤버를 초기화하지 말고 멤버 초기화 리스트를 사용하자. 이 때, 각 데이터 멤버가 선언된 순서와 똑같이 나열해야 한다.<br />
🔔 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제를 피해서 설계하자. 비지역 정적 객체를 지역 정적 객체로 바꾸면 된다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Cpp" /><category term="C++" /><category term="Cpp" /><category term="EffectiveC++" /><summary type="html"><![CDATA[Effective C++ 항목 04 정리]]></summary></entry><entry><title type="html">뉴턴-랩슨 방법(Newton-Raphson method)</title><link href="http://localhost:4000/numerical-analysis/newton-raphson-method/" rel="alternate" type="text/html" title="뉴턴-랩슨 방법(Newton-Raphson method)" /><published>2024-07-01T00:00:00+09:00</published><updated>2024-07-01T00:00:00+09:00</updated><id>http://localhost:4000/numerical-analysis/newton-raphson-method</id><content type="html" xml:base="http://localhost:4000/numerical-analysis/newton-raphson-method/"><![CDATA[<h1 id="0-newtons-method-newton-raphson-method란">0. Newton’s method, Newton-Raphson method란?</h1>

<p>Newton’s method 및 Newton-Raphson method 라고 불리는 이 방법은 실숫값 함수의 영점을 근사하는 방법 중 하나이다.</p>

<h1 id="1-뉴턴-랩슨-방법의-이해">1. 뉴턴-랩슨 방법의 이해</h1>

<p>제곱근을 구하는 문제를 생각해보자.</p>

<p><img src="https://github.com/Hyun-Soon/Hyun-Soon.github.io/assets/66724166/4b50df00-cdbe-4552-80b6-1561a6176d63" alt="Newton-Raphson_Method1" /></p>

\[f(x)=x^2-N\]

<p>위의 방정식에서 $f(x) = 0$이 되는 $x$값을 구하면 N의 제곱근을 구할 수 있다.</p>

<p>답을 모르는 상황에서 임의의 $x = a_1$에 대해 $f(a_1)$와 $f’(a_1)$를 구해보자.</p>

<p><img src="https://github.com/Hyun-Soon/Hyun-Soon.github.io/assets/66724166/a4af5e61-ff9e-4166-bb0e-cccbbce52cc3" alt="Newton-Raphson_Method2" /></p>

<p>$f’(a)$이 $x = a$에서 $f(x)$의 기울기임을 생각해보자.
$f(a) &gt; 0$, $f’(a) &gt; 0$ 일 때 $f(x) = 0$이 되는 $x$값은 $a$보다 작다는 것을 알 수 있다.</p>

<p>위 그림에서 $a_1$을 통해 $a_2$를 찾을 수 있고, 이런 식으로 접선을 그려 반복하면 실제 해에 가까워지는 것을 확인할 수 있다.</p>

\[a_2=a_1-\frac{f(a_1)}{f'(a_1)}\]

\[(\because f'(a_1)=\frac{f(a_1)}{a_1-a_2})\]

<p><br />
이런 식으로 해에 가까운 $x$값을 찾다가 $x$의 변화량이 일정값 이하로 작아지면, 즉 $|a_1-a_2|$ &lt; value(매우 작은 값)이 되면 $a_2$을 해로 상정한다.</p>

<p>즉, 뉴턴 방법(Newton’s method)는 임의의 $x$값에서 접선을 그려 해당 접선과 $x$축이 만나는 곳으로 점점 x값을 옮기며 점진적으로 해를 찾는 방법이다.</p>

<h1 id="2-뉴턴-랩슨-방법의-제약">2. 뉴턴-랩슨 방법의 제약</h1>

<p>간단하지만 효과적인 이 방법에는 제약이 존재한다.</p>

<ul>
  <li>해가 없는 경우, 당연히 해를 찾을 수 없다.</li>
  <li>$f(x)$가 연속이고 미분 가능해야 한다.</li>
  <li>해가 여러개인 경우, 뉴턴-랩슨 방법은 그 중 하나의 해를 찾아줄 뿐이며 초기값 $a_1$을 어떻게 설정하느냐에 따라 해가 달라질 수 있다.</li>
</ul>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="numerical-analysis" /><category term="Newton-Method" /><category term="Newton-Raphson-Method" /><summary type="html"><![CDATA[뉴턴-랩슨 방법을 알아보자.]]></summary></entry><entry><title type="html">09.무선 랜</title><link href="http://localhost:4000/network/network09/" rel="alternate" type="text/html" title="09.무선 랜" /><published>2023-12-23T00:00:00+09:00</published><updated>2023-12-23T00:00:00+09:00</updated><id>http://localhost:4000/network/network09</id><content type="html" xml:base="http://localhost:4000/network/network09/"><![CDATA[<h1 id="1-무선-랜">1. 무선 랜</h1>

<p>무선 랜은 <code class="language-plaintext highlighter-rouge">WAP(Wireless Access Point)</code>와 <code class="language-plaintext highlighter-rouge">무선 클라이언트(컴퓨터나 스마트폰 등)</code>로 구성된다.
컴퓨터가 WAP(무선 공유기)와 통신하려면 무선 랜 칩(chip)과 무선 랜 어댑터(adapter)가 필요하다.
무선 랜 어댑터는 USB 메모리 방식과 컴퓨터 카드 방식이 있다.</p>

<h1 id="2-무선-랜-연결-방식">2. 무선 랜 연결 방식</h1>

<ol>
  <li>infrastructure : WAP를 통해 통신하는 방식</li>
  <li>Ad Hoc : 무선 클라이언트끼리 직접 통신하는 방식</li>
</ol>

<h1 id="3-ssid">3. SSID</h1>

<p>무선 액세스 포인트와 무선 클라이언트를 연결하려면 혼선을 피하기 위해 <code class="language-plaintext highlighter-rouge">SSID</code>라는 액세스 포인트의 고유 이름을 사용해야 한다. 또한 무선 클라이언트가 자동으로 무선 액세스 포인트를 찾아 통신할 수 있기 위해 네트워크 이름, 인증, 암호화, 암호화 키를 설정해야 한다.
무선 액세스 포인트는 <code class="language-plaintext highlighter-rouge">beacon</code>이라고 하는 자기를 알리는 신호를 네트워크에 있는 모든 기기에 주기적으로 전송한다. 무선 클라이언트는 이 신호를 받은 후 자신의 SSID와 같은지 WAP에 문의한다. 같은 SSID의 WAP이 응답을 하고 서로의 존재를 알게 되면, 인증 방식이 올바른지 확인하고 무선 클라이언트는 WAP에 연결을 요청한다. WAP으로 부터 승인을 받으면 연결하여 통신을 할 수 있게 된다.</p>

<h1 id="4-채널">4. 채널</h1>

<p>WAP과 무선 클라이언트 사이의 거리가 멀수록 전파가 약해져 접속이 잘 안되거나 통신 속도가 느려진다. 이러한 이유로 WAP을 여러 대 설치해야한다. 무선 랜은 여러 기기를 동시에 연결할 수 있도록 주파수 대역을 분할하는데, 그 주파수 대역을 <code class="language-plaintext highlighter-rouge">채널</code>이라고 부른다. 공유기와 컴퓨터가 연결되려면 두 기기 모두 같은 채널을 설정해야 한다. 반면 공유기끼리는 다른 채널을 설정해야 한다. 다른 채널끼리는 주파수가 서로 다르기 때문에 전파가 겹치더라도 서로 간섭이 일어나지 않고 통신 속도도 떨어지지 않는다.
전파가 겹치는 무선 공유기들이 같은 채널로 설정되어 있으면 주파수가 서로 겹치면서 <code class="language-plaintext highlighter-rouge">전파 간섭</code>이 생기고 통신 속도가 느려진다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Network" /><category term="LAN" /><category term="Push_Swap" /><category term="SSID" /><category term="Channel" /><category term="beacon" /><summary type="html"><![CDATA[무선 랜에 대해 알아보자.]]></summary></entry><entry><title type="html">08.OSI 모델</title><link href="http://localhost:4000/network/network08/" rel="alternate" type="text/html" title="08.OSI 모델" /><published>2023-12-23T00:00:00+09:00</published><updated>2023-12-23T00:00:00+09:00</updated><id>http://localhost:4000/network/network08</id><content type="html" xml:base="http://localhost:4000/network/network08/"><![CDATA[<h1 id="1-osi-모델의-각-계층">1. OSI 모델의 각 계층</h1>

<ol>
  <li>응용 계층(세션 계층 + 표현 계층) : 어플리케이션 등에서 사용하는 데이터를 송수신하는 데 필요하다.</li>
  <li>전송 계층 : 목적지에 데이터를 정확하게 전달하는 데 필요하다.</li>
  <li>네트워크 계층 : 다른 네트워크에 있는 목적지에 데이터를 전달하는 데 필요하다.</li>
  <li>데이터 링크 계층 : 랜에서 데이터를 송수신하는 데 피룡하다.</li>
  <li>물리 계층 : 데이터를 전기 신호로 변환하는 데 필요하다.</li>
</ol>

<p>컴퓨터에서 데이터를 보낼 때, 7계층을 내려가며 캡슐화가 되고 목적지인 컴퓨터에 도착하면 7계층을 올라가며 역캡슐화가 된다.
스위치에서는 데이터 링크 계층까지, 라우터에서는 네트워크 계층까지 올라가며 역캡슐화가 됐다가 다시 내려오며 캡슐화가 된다.</p>

<h1 id="2-컴퓨터의-데이터가-전기-신호로-변환되는-과정">2. 컴퓨터의 데이터가 전기 신호로 변환되는 과정</h1>

<ol>
  <li><code class="language-plaintext highlighter-rouge">응용 계층</code>에서 3-way handshake로 connection이 확립된다.</li>
  <li>웹 브라우저에서 url을 입력하여 접속하면 html 데이터를 보내달라는 데이터(요청)가 생성된다.</li>
  <li><code class="language-plaintext highlighter-rouge">전송 계층</code>에서 TCP 헤더(출발지 포트 번호, 목적지 포트 번호가 들어 있다)가 붙는다. 즉, <strong>세그먼트</strong>가 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">네트워크 계층</code>에서 세그먼트에 IP 헤더(출발지 IP, 목적지 IP 주소가 붙어 있다)가 붙는다. 즉, <strong>IP 패킷</strong>이 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">데이터 링크 계층</code>에서 이더넷 헤더와 트레일러가 붙는다. 즉, <strong>이더넷 프레임</strong>이 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">물리 계층</code>에서 랜카드에 의해 <strong>전기 신호</strong>로 변환되어 네트워크로 전송된다.</li>
</ol>

<p>전기 신호를 받아 데이터로 변환하여 어플리케이션에 전달하는 과정은 위 과정의 역순이다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Network" /><category term="OSI" /><summary type="html"><![CDATA[OSI 모델의 전반적인 흐름에 대해 알아보자.]]></summary></entry><entry><title type="html">07.응용 계층</title><link href="http://localhost:4000/network/network07/" rel="alternate" type="text/html" title="07.응용 계층" /><published>2023-12-23T00:00:00+09:00</published><updated>2023-12-23T00:00:00+09:00</updated><id>http://localhost:4000/network/network07</id><content type="html" xml:base="http://localhost:4000/network/network07/"><![CDATA[<h1 id="1-응용-계층의-역할">1. 응용 계층의 역할</h1>

<p>서비스를 제공하는 측을 <code class="language-plaintext highlighter-rouge">서버</code>, 서비스를 요청하는 측에서 사용하는 프로그램을 <code class="language-plaintext highlighter-rouge">클라이언트</code>라고 한다.
이런 어플리케이션은 응용 계층에서 동작한다(여기서 응용 계층은 5계층의 세션 계층과 6계층의 표현 계층을 포함하는 의미).
응용 계층에서는 클라이언트의 요청을 서버 프로그램이 이해할 수 있는 데이터로 변환하고 전송한다.
클라이언트 측 어플리케이션과 서버 측 어플리케이션이 통신해야 하기 때문에 여기서도 프로토콜이 필요하다.</p>

<p>응용 계층의 대표적인 프로토콜 종류</p>
<ol>
  <li>HTTP : 웹사이트 접속</li>
  <li>FTP : 파일 전송</li>
  <li>SMTP : 메일 송신</li>
  <li>POP3 : 메일 수신</li>
  <li>DNS : 이름 해석(컴퓨터나 네트워크 장비에 붙여진 이름을 기반으로 IP 주소를 알아내는 것)</li>
</ol>

<h1 id="2-world-wide-webwww">2. World Wide Web(www)</h1>

<p>W3나 Web이라고도 불린다.
www에는 다음 3가지 기술이 사용된다.</p>

<ol>
  <li>HTML : 
  웹 페이지에서 문장 구조나 문자를 꾸미는 태그를 사용하여 작성하는 마크업 언어. 하이퍼링크를 사용할 수 있다. 이동한 사이트에 글과 그림이 있다면, 클라이언트는 글과 그림을 따로 요청하기 때문에 가끔 글이 먼저 보이고 그림이 나중에 보이는 경우가 발생한다.</li>
  <li>URL :
인터넷에서 파일 위치를 지정하기 위해 기술된 주소. 웹 사이트 주소를 지정하기 위해 사용된다.</li>
  <li>HTTP : 
  클라이언트는 웹 사이트를 보기 위해 웹 서버의 80번 포트를 통해 HTTP 통신을 한다. 클라이언트에서 index.html을 달라는 HTTP 요청을 보내면, 서버에서 HTTP 응답을 반환하고 index.html을 클라이언트에게 보낸다. 이전에는 요청이 있을 때마다 연결을 수립하고 해당 요청 처리 후 바로 연결을 끊었지만, HTTP/1.1 버전부터 keepalive 기능이 추가되어서 한번 연결을 수립하면 필요한 모든 요청을 처리 후 연결을 끊을 수 있게 되었기 때문에 효율이 상승했다.</li>
</ol>

<h1 id="3-domain-name">3. Domain name</h1>

<p>일반적으로 서버 컴퓨터에 접속하려면 서버 컴퓨터의 IP 주소를 알아야 하는데, 우리는 웹 브라우저 주소창에 www.google.com을 입력해도 구글 서버 컴퓨터로부터 정보를 받아올 수 있다.
<code class="language-plaintext highlighter-rouge">DNS</code>는 이처럼 URL을 IP 주소로 변환(이름 해석)해주는 시스템이다.
www.google.com을 컴퓨터나 네트워크를 식별하기 위해 붙여진 이름 즉 <code class="language-plaintext highlighter-rouge">도메인 이름</code>이라고 한다. 도메인 이름 앞에 있는 www는 <code class="language-plaintext highlighter-rouge">호스트 이름(서버 이름)</code>이다.
컴퓨터에서 www.google.com에 접속하려고 하면 컴퓨터는 우선 DNS 서버에 가서 www.google.com의 IP 주소를 요청한다. 이후 DNS 서버에서 해당 IP 주소를 넘겨주면 컴퓨터는 해당 IP 주소로 접속한다.
DNS 서버는 전 세계에 계층적으로 연결되어 있기 때문에 만약 컴퓨터가 요청한 첫번째 DNS 서버가 IP 주소를 모른다면, 첫번째 DNS 서버가 두번째 DNS 서버에게 IP 주소를 요청해서 이를 사용자 컴퓨터에게 전달한다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Network" /><category term="HTTP" /><category term="DNS" /><category term="www" /><summary type="html"><![CDATA[OSI 모델의 응용 계층에 대해 알아 보자.]]></summary></entry><entry><title type="html">06.전송 계층</title><link href="http://localhost:4000/network/network06/" rel="alternate" type="text/html" title="06.전송 계층" /><published>2023-12-20T00:00:00+09:00</published><updated>2023-12-20T00:00:00+09:00</updated><id>http://localhost:4000/network/network06</id><content type="html" xml:base="http://localhost:4000/network/network06/"><![CDATA[<h1 id="1-전송-계층의-역할">1. 전송 계층의 역할</h1>

<ol>
  <li>데이터가 신뢰할 수 있는 데이터인지 검사하고, 오류가 있으면 재전송을 요청한다.</li>
  <li>받은 데이터를 필요로 하는 어플리케이션에 전달한다.</li>
</ol>

<p>전송 계층의 통신 방식으로 2가지를 꼽을 수 있다.</p>
<ol>
  <li>연결형 통신 : 신뢰, 정확성을 우선으로 하여 통신 과정에서 여러 번 확인 절차를 거친다.</li>
  <li>비연결형 통신 : 동영상 같이 빠른 전송이 필요한 경우에 상대편과 통신하지 않고 보낸다.</li>
</ol>

<p>전송 계층의 연결형 통신 프로토콜에는 <code class="language-plaintext highlighter-rouge">TCP</code>가 사용되고, 비연결형 통신 프로토콜에는 <code class="language-plaintext highlighter-rouge">UDP</code>가 사용된다.</p>

<h1 id="2-tcp">2. TCP</h1>

<p>연결형 통신 프로토콜이다.
전송 계층에서 네트워크 계층으로 데이터를 보낼 때 TCP 헤더를 붙이는데, 이 때 TCP 헤더가 붙은 데이터를 <code class="language-plaintext highlighter-rouge">segment</code>라고 한다.
TCP에서 데이터를 전송하려면 먼저 <code class="language-plaintext highlighter-rouge">connection</code>이라는 가상의 독점 통신로를 확보해야 한다. 커넥션을 확보해야만 데이터를 전송할 수 있다. 데이터를 보내기 전에 연결(connection)을 확립하기 위해 패킷 요청을 세 번 교환하는 것을 <code class="language-plaintext highlighter-rouge">3-way handshake</code>라고 한다.</p>

<p>송신 측에서 수신 측으로 세그먼트를 보낼 때, 하나를 보내고 한 번 확인하는 식으로 데이터를 전달하면 시간이 오래걸리고 효율이 낮아지게 된다. 이를 해결하기 위해 세그먼트 여러 개를 많이 보내 놓고, 확인 응답을 몰아서 받는 방식을 사용한다.
세그먼트 여러 개를 많이 보내 놓을 수 있는 이유는 수신 측에서 버퍼에 데이터를 담아 놓기 때문이다. 3-way handshake를 할 때 양 측 컴퓨터는 상대방 컴퓨터의 버퍼 사이즈(window size)를 파악해 놓고 오버플로우가 나지 않게 데이터를 송수신한다. window size에 대한 정보는 TCP 헤더에 담긴다.</p>

<p>3-way handshake 이후 데이터를 전송할 때는 TCP 헤더의 일련번호와 확인 응답 번호가 사용된다.
TCP에서 데이터를 보낼 때 각 데이터에 일련 번호를 부여해 TCP 패킷의 순서를 제어할 수 있다.</p>

<h1 id="3-포트-번호">3. 포트 번호</h1>

<p>TCP 헤더에는 <code class="language-plaintext highlighter-rouge">출발지 포트 번호</code>와 <code class="language-plaintext highlighter-rouge">목적지 포트 번호</code>가 들어 있다. 이를 확인하여 어떤 어플리케이션으로 이 데이터가 가야하는지를 알 수 있다.
포트 번호는 0~65535번을 사용할 수 있다.</p>

<p>0~1023번 : well-known ports라고 하며 주요 프로토콜이 사용하도록 예약되어 있다.
1024번 : 예약되어 있지만 사용되지 않는 포트이다.
1025번 이상 : 랜덤포트로, 클라이언트 측의 송신 포트로 사용된다.</p>

<p>동작하는 어플리케이션들은 각각 포트 번호가 있어서 다른 어플리케이션과 구분된다. 데이터를 어플리케이션에 보낼 때, 이 포트 번호를 보고 구분하여 데이터를 전달한다.</p>

<h1 id="4-udp">4. UDP</h1>

<p>TCP가 신뢰할 수 있는 방식으로 안전하게 데이터를 상대방에가 전달하는 프로토콜이었다면, 비연결형 통신 프로토콜인 UDP는 효율성을 중요하게 여기는 프로토콜이다.
UDP는 데이터를 전송할 때 일일이 확인 작업을 하지 않기 때문에 데이터를 효율적으로 빠르게 보내는 것이 장점이다.
UDP 헤더가 붙은 데이터를 <code class="language-plaintext highlighter-rouge">UDP 데이터그램</code>이라고 한다. UDP 헤더는 신뢰성과 정확성이 필요하지 않아 TCP 헤더보다 훨씬 들어있는 정보가 적다.
UDP를 이용하면 같은 랜에 있는 컴퓨터나 네트워크 장비에 데이터를 일괄로 보낼 수 있으며, 이것을 <code class="language-plaintext highlighter-rouge">broadcast</code>라고 한다.
TCP는 3-way handshake와 같이 데이터를 전송할 때도 확인 응답을 하나씩 보내야 하기 때문에 브로드캐스트 같이 불특정 다수에게 보내는 통신에는 적합하지 않다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Network" /><category term="TCP" /><category term="Port" /><category term="UDP" /><summary type="html"><![CDATA[OSI 모델의 4계층인 전송 계층에 대해 알아보자.]]></summary></entry></feed>
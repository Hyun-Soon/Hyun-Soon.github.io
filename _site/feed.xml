<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-07-09T12:36:04+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hyuim’s blog</title><subtitle>Hyuim&apos;s personal blog.</subtitle><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><entry><title type="html">\[Effective C++\] 객체를 사용하기 전에 반드시 그 객체를 초기화하자</title><link href="http://localhost:4000/cpp/EffectiveC++04/" rel="alternate" type="text/html" title="\[Effective C++\] 객체를 사용하기 전에 반드시 그 객체를 초기화하자" /><published>2024-07-09T00:00:00+09:00</published><updated>2024-07-09T00:00:00+09:00</updated><id>http://localhost:4000/cpp/EffectiveC++04</id><content type="html" xml:base="http://localhost:4000/cpp/EffectiveC++04/"><![CDATA[<p><br /></p>
<h1 id="1-객체를-사용하기-전에-반드시-그-객체를-초기화하자">1. 객체를 사용하기 전에 반드시 그 객체를 초기화하자</h1>
<p><br /></p>

<p>초기화 리스트를 사용하면 멤버 데이터들의 복사 생성자를 사용하여, 멤버 데이터를 생성과 동시에 초기화할 수 있다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PhoneBook</span>
<span class="p">{</span>
	<span class="nl">private:</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">phoneNumber</span><span class="p">;</span>

	<span class="nl">public:</span>
		<span class="p">...</span>
		<span class="n">PhoneBook</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">inputName</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">inputPhoneNumber</span><span class="p">)</span>
		<span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">inputName</span><span class="p">),</span> <span class="n">phoneNumber</span><span class="p">(</span><span class="n">inputPhoneNumber</span><span class="p">)</span>
		<span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이떤 클래스의 멤버 데이터가 있다. 멤버 초기화 리스트에 들어있지 않더라도 그 데이터 타입이 사용자 정의 타입이면 컴파일러는 자동으로 그들 멤버에 대해 기본 생성자를 호출한다. 하지만 실수를 줄이기 위해 웬만하면 모든 데이터 멤버는 초기화 리스트에서 초기화 해주도록 하자.</p>

<p>기본 생성자로 초기화하고 싶은 경우에도 초기화 리스트에 명시해주는 습관을 들이자.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PhoneBook</span><span class="p">()</span> <span class="o">:</span> <span class="n">name</span><span class="p">(),</span> <span class="n">phoneNumber</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>

<p>c++의 기본 제공 타입(bool, char, …)은 생성과 동시에 초기화하나, 생성 후에 대입을 하나 걸리는 시간이 똑같지만 가독성을 위해 초기화 리스트에 넣어주자. 기본 제공 타입을 반드시 초기화 리스트에 넣어야 할 경우가 있는데, 바로 <code class="language-plaintext highlighter-rouge">const</code> 또는 <code class="language-plaintext highlighter-rouge">reference</code>일 경우이다. const와 reference는 생성과 동시에 초기화되어야 한다.</p>

<p>C++에서 객체의 초기화 순서는 컴파일러를 막론하고 똑같다.</p>
<ol>
  <li>기본 클래스는 파생 클래스보다 먼저 초기화된다.</li>
  <li>클래스 데이터 멤버는 그들이 선언된 순서대로 초기화된다.
멤버 초기화 리스트에 넣는 순서도 선언된 순서대로 넣어주도록 하자.</li>
</ol>

<p>초기화 순서에 대한 하나의 문제가 남아있다.
“비지역 정적 객체(non-local static object)의 초기화 순서는 개별 번역 단위(translation unit)에서 정해진다”는 것이다.</p>

<p><code class="language-plaintext highlighter-rouge">정적 객체(static object)</code>는 자신이 생성된 시점부터 프로그램이 끝날 때까지 살아 있는 객체를 일컫는다.
정적 객체의 범주에 들어가는 것은 5가지가 있다.</p>
<ol>
  <li>전역 객체</li>
  <li>네임스페이스 유효범위에서 정의된 객체</li>
  <li>클래스 안에서 static으로 선언된 객체</li>
  <li>함수 안에서 static으로 선언된 객체</li>
  <li>파일 유효범위에서 static으로 정의된 객체</li>
</ol>

<p>이들 중 함수 안에 있는 정적 객체는 지역 정적 객체(local static object)라 하고(함수에 대해 지역성을 가지므로), 나머지는 비지역 정적 객체(non-local static object)라 한다.</p>

<p><code class="language-plaintext highlighter-rouge">번역 단위(translation unit)</code>는 컴파일을 통해 하나의 목적 파일(object file)을 만드는 바탕이 되는 소스 코드를 일컫는다. 여기서 번역은 소스의 언어를 기계어로 옮긴다는 의미다. 기본적으로는 소스 파일 하나가 되는데, 그 파일이 #include하는 파일들까지 합쳐서 하나의 번역 단위가 된다.</p>

<p>즉 위에서 말한 문제는, 별도로 컴파일된 소스 파일이 두 개 이상 있으며 각 소스 파일에 비지역 정적 객체가 한 개 이상 들어 있는 경우에서, 한 쪽의 정적 객체가 초기화되지 않은 상황에 다른 쪽에서 이 객체를 사용할 때 발생하는 문제를 말한다.</p>

<p>예를 들어, 파일 시스템에 관한 라이브러리가 있고 사용자가 이를 이용해 디렉토리 클래스를 만든다고 하자.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//파일 시스템 라이브러리</span>
<span class="k">class</span> <span class="nc">FileSystem</span> <span class="c1">//라이브러리에 포함된 클래스</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="p">...</span>
		<span class="n">std</span><span class="o">::</span><span class="n">stize_t</span> <span class="n">numDisks</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">//많고 많은 멤버 함수들 중 하나</span>
		<span class="p">...</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="n">FileSystem</span> <span class="n">tfs</span><span class="p">;</span> <span class="c1">//사용자가 쓰게 될 객체</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//사용자가 라이브러리를 이용해 만든 클래스</span>
<span class="k">class</span> <span class="nc">Directory</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="n">Directory</span><span class="p">(</span> <span class="n">params</span> <span class="p">);</span>
		<span class="p">...</span>
<span class="p">};</span>

<span class="n">Directory</span><span class="o">::</span><span class="n">Directory</span> <span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">disks</span> <span class="o">=</span> <span class="n">tfs</span><span class="p">.</span><span class="n">numDisks</span><span class="p">();</span> <span class="c1">//tfs 객체를 여기서 사용함</span>
	<span class="p">...</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Directory</span> <span class="n">tempDir</span><span class="p">(</span> <span class="n">params</span> <span class="p">);</span> <span class="c1">//임시 파일을 담는 디렉토리 //여기서 문제가 발생한다.</span>
	<span class="p">...</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>정적 객체 tfs의 초기화 순서 때문에 이런 상황에서 문제가 발생한다. tfs가 tempDir보다 먼저 초기화되지 않으면, tempDir의 생성자는 tfs가 초기화되지 않았는데도 tfs를 사용하려고 시도한다.</p>

<p>non-local static object의 초기화 순서가 정해져 있지 않은 상황에서 이 문제를 어떻게 해결할까?
함수 안에 집어넣어 <code class="language-plaintext highlighter-rouge">Singleton pattern</code>을 활용하면 된다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">'''</span><span class="n">FileSystem</span><span class="err">'''</span>

<span class="k">class</span> <span class="nc">FileSystem</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>

<span class="n">FileSystem</span><span class="o">&amp;</span> <span class="n">tfs</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">FileSystem</span> <span class="n">fs</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">fs</span><span class="p">;</span>
<span class="p">}</span>


<span class="err">'''</span><span class="n">Directory</span><span class="err">'''</span>

<span class="p">...</span>

<span class="n">Directory</span><span class="o">&amp;</span> <span class="n">tempDir</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">Directory</span> <span class="n">td</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">td</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이런 식으로 함수의 return을 받아 사용하게 되면 초기화 문제를 해결할 수 있다.</p>

<p>정리하자면, 어떤 객체가 초기화되기 전에 그 객체를 사용하는 사용하는 일이 생기지 않도록 하려면 세가지를 기억하자.</p>
<ol>
  <li>멤버가 아닌 기본제공 타입 객체는 직접 초기화 해야 한다.</li>
  <li>객체의 모든 부분에 대한 초기화에는 멤버 초기화 리스트를 사용한다.</li>
  <li>별개의 번역 단위에 정의된 비지역 정적 객체에 영향을 끼치는 불확실한 초기화 순서를 염두에 두고 이러한 불확실성을 피해서 프로그램을 설계해야 한다.</li>
</ol>

<p class="notice--primary">🔔 기본제공 타입의 객체는 직접 손으로 초기화한다.<br />
🔔 생성자에서는, 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방법으로 멤버를 초기화하지 말고 멤버 초기화 리스트를 사용하자. 이 때, 각 데이터 멤버가 선언된 순서와 똑같이 나열해야 한다.<br />
🔔 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제를 피해서 설계하자. 비지역 정적 객체를 지역 정적 객체로 바꾸면 된다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Cpp" /><category term="C++" /><category term="Cpp" /><category term="EffectiveC++" /><summary type="html"><![CDATA[Effective C++ 항목 04 정리]]></summary></entry><entry><title type="html">\[Effective C++\] \#define을 쓰려거든 const, enum, inline을 떠올리자</title><link href="http://localhost:4000/cpp/EffectiveC++02/" rel="alternate" type="text/html" title="\[Effective C++\] \#define을 쓰려거든 const, enum, inline을 떠올리자" /><published>2024-07-09T00:00:00+09:00</published><updated>2024-07-09T00:00:00+09:00</updated><id>http://localhost:4000/cpp/EffectiveC++02</id><content type="html" xml:base="http://localhost:4000/cpp/EffectiveC++02/"><![CDATA[<p><br /></p>
<h1 id="1-define을-쓰려거든-const-enum-inline을-떠올리자">1. #define을 쓰려거든 const, enum, inline을 떠올리자</h1>
<p><br />
다시 말하면 “가급적 선행 처리자보다 컴파일러를 더 가까이 하자”는 뜻이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define ASPECT_RATIO 1.653
</span>
<span class="p">...</span>
</code></pre></div></div>

<p>위와 같이 작성된 코드가 있다고 하자. 위 소스 코드는 컴파일러로 넘어가기 전에 선행 처리자가 ASPECT_RATIO라는 이름을 밀어버리고 숫자 상수(1.653)로 대체한다. 그 결과 ASPECT_RATIO는 컴파일러가 쓰는 기호 테이블에 들어가지 않고, 이는 컴파일 에러를 해결할 때 어려움을 겪게 할 수 있다. 특히, 코드를 작성하지 않은 다른 사람이 이를 해결하려고 하면 더욱 난감할 것이다.</p>

<p>이 문제의 해결법은 매크로 대신 상수를 쓰는 것이다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">double</span> <span class="n">AspectRatio</span> <span class="o">=</span> <span class="mf">1.653</span><span class="p">;</span>
</code></pre></div></div>
<p>위의 AspectRatio는 언어 차원에서 지원하는 상수 타입의 데이터이기 때문에 당연히 컴파일러의 눈에도 보이며 기호 테이블에 들어간다.</p>

<p>또한 위의 예시처럼 작성할 경우, 컴파일을 거친 최종 코드의 크기가 <code class="language-plaintext highlighter-rouge">#define</code>을 썼을 때 보다 더 작을 수 있다. <code class="language-plaintext highlighter-rouge">#define</code>의 경우 선행 처리자가 코드 상의 ASPECT_RATIO를 1.653으로 바꾸는 만큼 1.653의 사본이 많이 생기는 반면, AspectRatio는 한 개의 변수만 존재하기 때문이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>상수 정의는 대개 헤더 파일에 넣는 것이 관례이다.
</code></pre></div></div>

<p>만약 클래스 멤버로 상수를 정의하는 경우, 그 상수의 사본 개수가 한 개를 넘지 못하게 하고 싶다면 <code class="language-plaintext highlighter-rouge">static</code> 멤버로 만들어야 한다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GamePlayer</span>
<span class="p">{</span>
	<span class="nl">private:</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">scores</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
		<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>보통은 위와 같이 클래스 안에 선언하는 것이 문제가 되지 않지만, 클래스 상수의 주소를 구하거나 구식 컴파일러의 경우 정의를 구현 파일에서 제공해야 한다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">GamePlayer</span><span class="o">::</span><span class="n">c</span><span class="p">;</span>
</code></pre></div></div>

<p>웬만한 경우에는 이것으로 해결이 되지만, GamePlayer::scores와 같이 배열을 선언할 때 컴파일러가 컴파일 과정에서 이 배열의 크기를 알아야 한다며 문제를 일으킬 수 있다. 이 경우에는 <code class="language-plaintext highlighter-rouge">enum hack</code> 기법을 떠올리자.</p>

<p><code class="language-plaintext highlighter-rouge">enum hack</code>은 enumerator 타입의 값은 int가 놓일 곳에도 쓰일 수 있다는 사실을 활용하는 것이다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GamePlayer</span>
<span class="p">{</span>
	<span class="nl">private:</span>
		<span class="k">enum</span> <span class="p">{</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">};</span>

		<span class="kt">int</span> <span class="n">scores</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">enum hack</code>의 동작 방식은 <code class="language-plaintext highlighter-rouge">const</code>보다 <code class="language-plaintext highlighter-rouge">#define</code>에 더 가깝다. enum의 주소를 취하는 것은 불법이며 #define의 주소를 얻는 것 역시 마찬가지다. 따라서 선언한 정수 상수를 가지고 다른 사람이 주소를 얻거나 참조자를 쓰는 것이 싫다면 enum은 아주 좋은 자물쇠가 될 수 있다.</p>

<p>#define을 오용하는 또다른 사례로 매크로 함수가 있다. 함수 호출 오버헤드를 일으키지 않는다는 점에서 매크로 함수를 사용하지만 문제가 있다. 아래는 매크로 인자들 중 큰 것을 사용해 어떤 함수 f를 호출하는 매크로이다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))
</span></code></pre></div></div>

<p>매크로를 작성할 때는 매크로 본문에 들어 있는 인자마다 반드시 괄호를 씌워줘야 한다. 하지만 이 부분을 제대로 처리했다고 해도 문제가 발생한다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">CALL_WITH_MAX</span><span class="p">(</span><span class="o">++</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>  <span class="c1">// a가 두 번 증가한다.</span>
<span class="n">CALL_WITH_MAX</span><span class="p">(</span><span class="o">++</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">+</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// a가 한 번 증가한다.</span>
</code></pre></div></div>

<p>비교의 결과로 어떤 인자를 가져오느냐에 따라 결과가 달라지는 문제가 발생한다.
함수 호출을 없애 주는 매크로의 효율을 그대로 유지하면서 정규 함수의 모든 동작방식 및 타입 안전성까지 완벽히 취할 수 있는 방법이 있다.
바로 “인라인 함수 템플릿”이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">callWithMax</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">f</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 함수는 템플릿이기 때문에 동일 계열 함수군(family of functions)을 만들어낸다. 또한 진짜 함수이기 때문에 유효범위 및 접근 규칙을 그대로 따라간다.</p>

<p class="notice--primary">🔔 단순한 상수를 쓸 때는, #define보다 const 객체 혹은 enum을 우선 떠올리자.
🔔 함수처럼 쓰이는 매크로를 만들려면, #define 매크로보다 인라인 함수를 우선 떠올리자.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Cpp" /><category term="C++" /><category term="Cpp" /><category term="EffectiveC++" /><summary type="html"><![CDATA[Effective C++ 항목 02 정리]]></summary></entry><entry><title type="html">\[Effective C++\] C++를 언어들의 연합체로 바라보는 안목은 필수</title><link href="http://localhost:4000/cpp/EffectiveC++01/" rel="alternate" type="text/html" title="\[Effective C++\] C++를 언어들의 연합체로 바라보는 안목은 필수" /><published>2024-07-09T00:00:00+09:00</published><updated>2024-07-09T00:00:00+09:00</updated><id>http://localhost:4000/cpp/EffectiveC++01</id><content type="html" xml:base="http://localhost:4000/cpp/EffectiveC++01/"><![CDATA[<p><br /></p>
<h1 id="1-c를-언어들의-연합체로-바라보는-안목을-갖자">1. C++를 언어들의 연합체로 바라보는 안목을 갖자</h1>
<p><br /></p>

<p>c++는 오늘날 <code class="language-plaintext highlighter-rouge">다중패러다임 프로그래밍 언어(multiparadigm programming language)</code>라고 불린다.절차적 프로그래밍을 기본으로 객체 지향, 함수식, 일반화, 메타 프로그래밍 개념까지 지원하고 있다. 이렇게 복잡한 c++를 제대로 이해하기 위해서는 시각을 바꿔 c++를 여러 언어들의 연합체로 바라봐야 한다. 즉, c++가 여러 개의 하위 언어를 제공한다는 점을 이해해야 한다.</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">C</code> : C++는 C를 기본으로 하고 있다. 블록, 문장, 선행 처리자 등 많은 것을 C에서 가져왔다.</li>
  <li>객체 지향 개념의 C++ : 이 부분에 ‘클래스를 쓰는 C’에 관한 모든 것이 해당된다. 클래스, 캡슐화, 상속, 다형성, 가상 함수(동적 바인딩) 등..</li>
  <li>템플릿 C++ : C++의 일반화 프로그래밍 부분이다. 오늘날 템플릿이 C++에 끼치는 영향은 매우 거대하며 이로 인해 <code class="language-plaintext highlighter-rouge">템플릿 메타프로그래밍(template metaprogramming: TMP</code>이라는 새로운 프로그래밍 패러다임이 파생되었다.</li>
  <li>STL : 이름에서 알 수 있듯 템플릿 라이브러리이다. STL은 <code class="language-plaintext highlighter-rouge">container</code>, <code class="language-plaintext highlighter-rouge">iterator</code>, <code class="language-plaintext highlighter-rouge">algorithm</code>, <code class="language-plaintext highlighter-rouge">function object</code>들이 얽혀 돌아가는 것을 규약으로 삼고 있으나, 템플릿과 라이브러리는 얼마든지 다른 아이디어를 중심으로 만들어질 수 있다. 또한 나름대로 독특한 사용규약이 있어서, STL을 써서 프로그래밍하려면 그 규약을 따라야 한다.</li>
</ol>

<p>위 네 가지의 하위 언어들이 C++을 이루고 있다는 점을 명심하고, 한 언어에서 다른 언어로 옮겨 가면서 대응 전략을 바꾸어야 하는 상황에서 이를 잘 활용해야 한다.</p>

<p>예를 들어, C 스타일로만 쓰고 있으면 기본제공 타입에 대해서는 “값 전달이 참조 전달보다 대개 효율이 더 좋다”라는 규칙이 통하지만, C++의 C 부분만 쓰다가 객체 지향 C++로 옮겨 가면 사용자 정의 생성자/소멸자 개념이 생기면서 상수 객체 참조자에 의한 전달(pass-by-reference-to-const) 방식이 더 좋은 효율을 보인다.</p>

<p>이런 현상은 템플릿 C++를 쓸 때 특히 두드러지는데, 왜냐하면 템플릿 C++의 세계에서는 우리가 손에 들고 있는 객체의 타입조차 알 수 없기 때문이다.</p>

<p>그러나 STL 쪽으로 넘어오면 전세가 또 바뀌게 된다. STL을 배우다 보면 iterator와 function object가 C의 포인터를 본떠 만든 것이란 점을 알게 되고, 그렇기 때문에 STL의 iterator 및 function object에 대해서는 값 전달에 대한 규칙이 다시 제 힘을 발휘하게 된다.</p>

<p>C++는 한 가지 프로그래밍 규칙 아래 똘똘 뭉친 통합 언어(unified language)가 아니라 네 가지 하위 언어들의 연합체이다. 즉, 각각의 하위 언어가 자신만의 규칙을 갖고 있다. “하위 언어들로 구성되어 있다”라는 점을 꼭 새겨두도록 하자.</p>

<p class="notice--primary">🔔 C++를 사용한 효과적인 프로그래밍 규칙은 경우에 따라 달라진다. 그 경우란, 바로 C++의 어떤 부분을 사용하느냐이다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Cpp" /><category term="C++" /><category term="Cpp" /><category term="EffectiveC++" /><summary type="html"><![CDATA[Effective C++ 항목 01 정리]]></summary></entry><entry><title type="html">\[Effective C++\] 낌새만 보이면 const를 들이대 보자!</title><link href="http://localhost:4000/cpp/EffectiveC++03/" rel="alternate" type="text/html" title="\[Effective C++\] 낌새만 보이면 const를 들이대 보자!" /><published>2024-07-09T00:00:00+09:00</published><updated>2024-07-09T00:00:00+09:00</updated><id>http://localhost:4000/cpp/EffectiveC++03</id><content type="html" xml:base="http://localhost:4000/cpp/EffectiveC++03/"><![CDATA[<p><br /></p>
<h1 id="1-const_iterator">1. const_iterator</h1>
<p><br /></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span> <span class="c1">//int 값이 const</span>
<span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">;</span> <span class="c1">//int 값이 const</span>
<span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span><span class="p">;</span> <span class="c1">//ptr이 const</span>
</code></pre></div></div>

<p>STL iterator는 포인터를 본뜬 것이기 때문에 기본 동작 원리가 T* 포인터와 매우 흡사하다. 변경이 불가능한 객체를 가리키는 iterator가 필요하다면, <code class="language-plaintext highlighter-rouge">const_iterator</code>를 사용하면 된다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span> <span class="c1">//iter가 const</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">cIter</span><span class="p">;</span> <span class="c1">//cIter가 가리키는 값이 const</span>
<span class="c1">//</span>
</code></pre></div></div>
<p><br /></p>
<h1 id="2-상수-멤버-함수">2. 상수 멤버 함수</h1>
<p><br />
멤버 함수 끝에 붙는 const 키워드의 역할은 “해당 멤버 함수가 상수 객체에 대해 호출될 수 있는 함수이다”라는 사실을 알려주는 것이다. C++ 프로그램의 실행 성능을 높이는 핵심 기법 중 하나는 객체 전달을 ‘상수 객체에 대한 참조자(reference-to-const)’로 진행하는 것이다. 이 기법이 제대로 동작하려면 const 멤버 함수가 존재해야 한다. const 키워드가 있고 없고의 차이만 있는 멤버 함수들은 오버로딩이 가능하다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TextBloack</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="p">...</span>

		<span class="c1">//상수 객체에 대한 operator[]</span>
		<span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="c1">//비상수 객체에 대한 operator[]</span>
		<span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
		<span class="p">}</span>

	<span class="k">private</span><span class="o">:</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">TextBlock</span> <span class="n">tb</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//비상수 멤버 함수를 호출한다.</span>

	<span class="k">const</span> <span class="n">TextBlock</span> <span class="n">ctb</span><span class="p">(</span><span class="s">"World"</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ctb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//상수 멤버 함수를 호출한다.</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>멤버 함수가 상수 멤버라는 것은 두가지 개념을 내포한다.</p>
<ol>
  <li>bitwise constness(physical constness) 비트수준 상수성</li>
  <li>logical constness 논리적 상수성</li>
</ol>

<p>비트수준 상수성은 어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야 그 멤버 함수가 ‘const’임을 인정하는 개념이다. 그런데, 애석하게도 ‘제대로 const’로 동작하지 않는데도 이 비트수준 상수성 검사를 통과하는 멤버 함수들이 존재한다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CTextBlock</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="p">...</span>

		<span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span> <span class="k">const</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">pText</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
		<span class="p">}</span>

	<span class="k">private</span><span class="o">:</span>
		<span class="kt">char</span><span class="o">*</span> <span class="n">pText</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>operator[]의 내부 코드만 보면 pText를 건드리지 않으므로 컴파일러는 operator[] 코드를 생성할 때 불평할 이유가 없다. 하지만 reference를 반환하고 있으므로 다른 코드에서 operater[]를 이용해 pText의 값을 바꿀 위험이 있다. 상수 멤버 함수를 사용했지만 비트수준 상수성이 깨질 가능성이 있다는 말이다.</p>

<p>논리적 상수성은 이런 황당한 상황을 보완하는 대체 개념으로 나오게 되었다.
상수 멤버 함수라고 해서 객체의 한 비트도 수정할 수 없는 것이 아니라 일부 몇 비트 정도는 바꿀 수 있되, 그것을 사용자(이 책에서는 이 코드를 사용하는 다른 프로그래머도 사용자라고 칭한다) 측에서 알아채지 못하게만 하면 상수 멤버 자격이 있다는 것이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CTextBlock</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="p">...</span>

		<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

	<span class="nl">private:</span>

		<span class="kt">char</span><span class="o">*</span> <span class="n">pText</span><span class="p">;</span>
		
		<span class="c1">//mutable은 non-static 데이터 멤버를 비트 수준 상수성의 족쇄에서 해방시켜준다.</span>
		<span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">textLength</span><span class="p">;</span>
		<span class="k">mutable</span> <span class="kt">bool</span> <span class="n">lengthIsValid</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">CTextBlock</span><span class="o">::</span><span class="n">length</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lengthIsValid</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">textLength</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">strlen</span><span class="p">(</span><span class="n">pText</span><span class="p">);</span>
		<span class="n">lengthIsValid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">textLength</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>
<h1 id="3-상수-멤버-및-비상수-멤버-함수에서-코드-중복-현상을-피하는-방법">3. 상수 멤버 및 비상수 멤버 함수에서 코드 중복 현상을 피하는 방법</h1>
<p><br />
단순히 문자를 리턴하는 것이 아니라 operator[] 내부에서 경계 검사, 자료 무결성 검증 등 다양한 일을 한다고 생각해보자.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TextBlock</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="p">...</span>

		<span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span>
		<span class="p">{</span>
			<span class="p">...</span> <span class="c1">//경계 검사</span>
			<span class="p">...</span> <span class="c1">//자료 무결성 검증</span>
			<span class="p">...</span> <span class="c1">//등등</span>
			<span class="p">...</span>
			<span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="p">...</span> <span class="c1">//경계 검사</span>
			<span class="p">...</span> <span class="c1">//자료 무결성 검증</span>
			<span class="p">...</span> <span class="c1">//등등</span>
			<span class="p">...</span>
			<span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
		<span class="p">}</span>

	<span class="k">private</span><span class="o">:</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>같은 기능을 하지만 const 때문에 코드 중복이 발생한다. 이 때 코드 중복을 피할 수 있는 방법이 있는데, 주의할 점이 있다. const가 아닌 것에 const를 붙이는 것은 안전하지만, 이미 const인 것에서 const를 떼어내는 것은 위험하다는 점을 생각하자.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TextBlock</span>
<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="p">...</span>

		<span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span> <span class="c1">//이전과 동일</span>
		<span class="p">{</span>
			<span class="p">...</span>
		<span class="p">}</span>

		<span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&amp;&gt;</span><span class="p">(</span>
						<span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">TextBlock</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">position</span><span class="p">]</span>
						<span class="p">);</span>
		<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p class="notice--primary">🔔 const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다. const는 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을 수 있고, 멤버 함수에도 붙을 수 있다.<br />
🔔 컴파일러 쪽에서 보면 비트 수준 상수성을 지켜야 하지만, 프로그래머는 논리적 상수성을 사용해서 프로그래밍하는 방법도 있다는 것을 알아두자.<br />
🔔 상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드 중복을 피하는 것이 좋은데, 이때 비상수 버전이 상수 버전을 호출하도록 만들어라.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Cpp" /><category term="C++" /><category term="Cpp" /><category term="EffectiveC++" /><summary type="html"><![CDATA[Effective C++ 항목 03 정리]]></summary></entry><entry><title type="html">뉴턴-랩슨 방법(Newton-Raphson method)</title><link href="http://localhost:4000/numerical-analysis/newton-raphson-method/" rel="alternate" type="text/html" title="뉴턴-랩슨 방법(Newton-Raphson method)" /><published>2024-07-01T00:00:00+09:00</published><updated>2024-07-01T00:00:00+09:00</updated><id>http://localhost:4000/numerical-analysis/newton-raphson-method</id><content type="html" xml:base="http://localhost:4000/numerical-analysis/newton-raphson-method/"><![CDATA[<h1 id="0-newtons-method-newton-raphson-method란">0. Newton’s method, Newton-Raphson method란?</h1>

<p>Newton’s method 및 Newton-Raphson method 라고 불리는 이 방법은 실숫값 함수의 영점을 근사하는 방법 중 하나이다.</p>

<h1 id="1-뉴턴-랩슨-방법의-이해">1. 뉴턴-랩슨 방법의 이해</h1>

<p>제곱근을 구하는 문제를 생각해보자.</p>

<p><img src="https://github.com/Hyun-Soon/Hyun-Soon.github.io/assets/66724166/4b50df00-cdbe-4552-80b6-1561a6176d63" alt="Newton-Raphson_Method1" /></p>

\[f(x)=x^2-N\]

<p>위의 방정식에서 $f(x) = 0$이 되는 $x$값을 구하면 N의 제곱근을 구할 수 있다.</p>

<p>답을 모르는 상황에서 임의의 $x = a_1$에 대해 $f(a_1)$와 $f’(a_1)$를 구해보자.</p>

<p><img src="https://github.com/Hyun-Soon/Hyun-Soon.github.io/assets/66724166/a4af5e61-ff9e-4166-bb0e-cccbbce52cc3" alt="Newton-Raphson_Method2" /></p>

<p>$f’(a)$이 $x = a$에서 $f(x)$의 기울기임을 생각해보자.
$f(a) &gt; 0$, $f’(a) &gt; 0$ 일 때 $f(x) = 0$이 되는 $x$값은 $a$보다 작다는 것을 알 수 있다.</p>

<p>위 그림에서 $a_1$을 통해 $a_2$를 찾을 수 있고, 이런 식으로 접선을 그려 반복하면 실제 해에 가까워지는 것을 확인할 수 있다.</p>

\[a_2=a_1-\frac{f(a_1)}{f'(a_1)}\]

\[(\because f'(a_1)=\frac{f(a_1)}{a_1-a_2})\]

<p><br />
이런 식으로 해에 가까운 $x$값을 찾다가 $x$의 변화량이 일정값 이하로 작아지면, 즉 $|a_1-a_2|$ &lt; value(매우 작은 값)이 되면 $a_2$을 해로 상정한다.</p>

<p>즉, 뉴턴 방법(Newton’s method)는 임의의 $x$값에서 접선을 그려 해당 접선과 $x$축이 만나는 곳으로 점점 x값을 옮기며 점진적으로 해를 찾는 방법이다.</p>

<h1 id="2-뉴턴-랩슨-방법의-제약">2. 뉴턴-랩슨 방법의 제약</h1>

<p>간단하지만 효과적인 이 방법에는 제약이 존재한다.</p>

<ul>
  <li>해가 없는 경우, 당연히 해를 찾을 수 없다.</li>
  <li>$f(x)$가 연속이고 미분 가능해야 한다.</li>
  <li>해가 여러개인 경우, 뉴턴-랩슨 방법은 그 중 하나의 해를 찾아줄 뿐이며 초기값 $a_1$을 어떻게 설정하느냐에 따라 해가 달라질 수 있다.</li>
</ul>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="numerical-analysis" /><category term="Newton-Method" /><category term="Newton-Raphson-Method" /><summary type="html"><![CDATA[뉴턴-랩슨 방법을 알아보자.]]></summary></entry><entry><title type="html">09.무선 랜</title><link href="http://localhost:4000/network/network09/" rel="alternate" type="text/html" title="09.무선 랜" /><published>2023-12-23T00:00:00+09:00</published><updated>2023-12-23T00:00:00+09:00</updated><id>http://localhost:4000/network/network09</id><content type="html" xml:base="http://localhost:4000/network/network09/"><![CDATA[<h1 id="1-무선-랜">1. 무선 랜</h1>

<p>무선 랜은 <code class="language-plaintext highlighter-rouge">WAP(Wireless Access Point)</code>와 <code class="language-plaintext highlighter-rouge">무선 클라이언트(컴퓨터나 스마트폰 등)</code>로 구성된다.
컴퓨터가 WAP(무선 공유기)와 통신하려면 무선 랜 칩(chip)과 무선 랜 어댑터(adapter)가 필요하다.
무선 랜 어댑터는 USB 메모리 방식과 컴퓨터 카드 방식이 있다.</p>

<h1 id="2-무선-랜-연결-방식">2. 무선 랜 연결 방식</h1>

<ol>
  <li>infrastructure : WAP를 통해 통신하는 방식</li>
  <li>Ad Hoc : 무선 클라이언트끼리 직접 통신하는 방식</li>
</ol>

<h1 id="3-ssid">3. SSID</h1>

<p>무선 액세스 포인트와 무선 클라이언트를 연결하려면 혼선을 피하기 위해 <code class="language-plaintext highlighter-rouge">SSID</code>라는 액세스 포인트의 고유 이름을 사용해야 한다. 또한 무선 클라이언트가 자동으로 무선 액세스 포인트를 찾아 통신할 수 있기 위해 네트워크 이름, 인증, 암호화, 암호화 키를 설정해야 한다.
무선 액세스 포인트는 <code class="language-plaintext highlighter-rouge">beacon</code>이라고 하는 자기를 알리는 신호를 네트워크에 있는 모든 기기에 주기적으로 전송한다. 무선 클라이언트는 이 신호를 받은 후 자신의 SSID와 같은지 WAP에 문의한다. 같은 SSID의 WAP이 응답을 하고 서로의 존재를 알게 되면, 인증 방식이 올바른지 확인하고 무선 클라이언트는 WAP에 연결을 요청한다. WAP으로 부터 승인을 받으면 연결하여 통신을 할 수 있게 된다.</p>

<h1 id="4-채널">4. 채널</h1>

<p>WAP과 무선 클라이언트 사이의 거리가 멀수록 전파가 약해져 접속이 잘 안되거나 통신 속도가 느려진다. 이러한 이유로 WAP을 여러 대 설치해야한다. 무선 랜은 여러 기기를 동시에 연결할 수 있도록 주파수 대역을 분할하는데, 그 주파수 대역을 <code class="language-plaintext highlighter-rouge">채널</code>이라고 부른다. 공유기와 컴퓨터가 연결되려면 두 기기 모두 같은 채널을 설정해야 한다. 반면 공유기끼리는 다른 채널을 설정해야 한다. 다른 채널끼리는 주파수가 서로 다르기 때문에 전파가 겹치더라도 서로 간섭이 일어나지 않고 통신 속도도 떨어지지 않는다.
전파가 겹치는 무선 공유기들이 같은 채널로 설정되어 있으면 주파수가 서로 겹치면서 <code class="language-plaintext highlighter-rouge">전파 간섭</code>이 생기고 통신 속도가 느려진다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Network" /><category term="LAN" /><category term="Push_Swap" /><category term="SSID" /><category term="Channel" /><category term="beacon" /><summary type="html"><![CDATA[무선 랜에 대해 알아보자.]]></summary></entry><entry><title type="html">07.응용 계층</title><link href="http://localhost:4000/network/network07/" rel="alternate" type="text/html" title="07.응용 계층" /><published>2023-12-23T00:00:00+09:00</published><updated>2023-12-23T00:00:00+09:00</updated><id>http://localhost:4000/network/network07</id><content type="html" xml:base="http://localhost:4000/network/network07/"><![CDATA[<h1 id="1-응용-계층의-역할">1. 응용 계층의 역할</h1>

<p>서비스를 제공하는 측을 <code class="language-plaintext highlighter-rouge">서버</code>, 서비스를 요청하는 측에서 사용하는 프로그램을 <code class="language-plaintext highlighter-rouge">클라이언트</code>라고 한다.
이런 어플리케이션은 응용 계층에서 동작한다(여기서 응용 계층은 5계층의 세션 계층과 6계층의 표현 계층을 포함하는 의미).
응용 계층에서는 클라이언트의 요청을 서버 프로그램이 이해할 수 있는 데이터로 변환하고 전송한다.
클라이언트 측 어플리케이션과 서버 측 어플리케이션이 통신해야 하기 때문에 여기서도 프로토콜이 필요하다.</p>

<p>응용 계층의 대표적인 프로토콜 종류</p>
<ol>
  <li>HTTP : 웹사이트 접속</li>
  <li>FTP : 파일 전송</li>
  <li>SMTP : 메일 송신</li>
  <li>POP3 : 메일 수신</li>
  <li>DNS : 이름 해석(컴퓨터나 네트워크 장비에 붙여진 이름을 기반으로 IP 주소를 알아내는 것)</li>
</ol>

<h1 id="2-world-wide-webwww">2. World Wide Web(www)</h1>

<p>W3나 Web이라고도 불린다.
www에는 다음 3가지 기술이 사용된다.</p>

<ol>
  <li>HTML : 
  웹 페이지에서 문장 구조나 문자를 꾸미는 태그를 사용하여 작성하는 마크업 언어. 하이퍼링크를 사용할 수 있다. 이동한 사이트에 글과 그림이 있다면, 클라이언트는 글과 그림을 따로 요청하기 때문에 가끔 글이 먼저 보이고 그림이 나중에 보이는 경우가 발생한다.</li>
  <li>URL :
인터넷에서 파일 위치를 지정하기 위해 기술된 주소. 웹 사이트 주소를 지정하기 위해 사용된다.</li>
  <li>HTTP : 
  클라이언트는 웹 사이트를 보기 위해 웹 서버의 80번 포트를 통해 HTTP 통신을 한다. 클라이언트에서 index.html을 달라는 HTTP 요청을 보내면, 서버에서 HTTP 응답을 반환하고 index.html을 클라이언트에게 보낸다. 이전에는 요청이 있을 때마다 연결을 수립하고 해당 요청 처리 후 바로 연결을 끊었지만, HTTP/1.1 버전부터 keepalive 기능이 추가되어서 한번 연결을 수립하면 필요한 모든 요청을 처리 후 연결을 끊을 수 있게 되었기 때문에 효율이 상승했다.</li>
</ol>

<h1 id="3-domain-name">3. Domain name</h1>

<p>일반적으로 서버 컴퓨터에 접속하려면 서버 컴퓨터의 IP 주소를 알아야 하는데, 우리는 웹 브라우저 주소창에 www.google.com을 입력해도 구글 서버 컴퓨터로부터 정보를 받아올 수 있다.
<code class="language-plaintext highlighter-rouge">DNS</code>는 이처럼 URL을 IP 주소로 변환(이름 해석)해주는 시스템이다.
www.google.com을 컴퓨터나 네트워크를 식별하기 위해 붙여진 이름 즉 <code class="language-plaintext highlighter-rouge">도메인 이름</code>이라고 한다. 도메인 이름 앞에 있는 www는 <code class="language-plaintext highlighter-rouge">호스트 이름(서버 이름)</code>이다.
컴퓨터에서 www.google.com에 접속하려고 하면 컴퓨터는 우선 DNS 서버에 가서 www.google.com의 IP 주소를 요청한다. 이후 DNS 서버에서 해당 IP 주소를 넘겨주면 컴퓨터는 해당 IP 주소로 접속한다.
DNS 서버는 전 세계에 계층적으로 연결되어 있기 때문에 만약 컴퓨터가 요청한 첫번째 DNS 서버가 IP 주소를 모른다면, 첫번째 DNS 서버가 두번째 DNS 서버에게 IP 주소를 요청해서 이를 사용자 컴퓨터에게 전달한다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Network" /><category term="HTTP" /><category term="DNS" /><category term="www" /><summary type="html"><![CDATA[OSI 모델의 응용 계층에 대해 알아 보자.]]></summary></entry><entry><title type="html">08.OSI 모델</title><link href="http://localhost:4000/network/network08/" rel="alternate" type="text/html" title="08.OSI 모델" /><published>2023-12-23T00:00:00+09:00</published><updated>2023-12-23T00:00:00+09:00</updated><id>http://localhost:4000/network/network08</id><content type="html" xml:base="http://localhost:4000/network/network08/"><![CDATA[<h1 id="1-osi-모델의-각-계층">1. OSI 모델의 각 계층</h1>

<ol>
  <li>응용 계층(세션 계층 + 표현 계층) : 어플리케이션 등에서 사용하는 데이터를 송수신하는 데 필요하다.</li>
  <li>전송 계층 : 목적지에 데이터를 정확하게 전달하는 데 필요하다.</li>
  <li>네트워크 계층 : 다른 네트워크에 있는 목적지에 데이터를 전달하는 데 필요하다.</li>
  <li>데이터 링크 계층 : 랜에서 데이터를 송수신하는 데 피룡하다.</li>
  <li>물리 계층 : 데이터를 전기 신호로 변환하는 데 필요하다.</li>
</ol>

<p>컴퓨터에서 데이터를 보낼 때, 7계층을 내려가며 캡슐화가 되고 목적지인 컴퓨터에 도착하면 7계층을 올라가며 역캡슐화가 된다.
스위치에서는 데이터 링크 계층까지, 라우터에서는 네트워크 계층까지 올라가며 역캡슐화가 됐다가 다시 내려오며 캡슐화가 된다.</p>

<h1 id="2-컴퓨터의-데이터가-전기-신호로-변환되는-과정">2. 컴퓨터의 데이터가 전기 신호로 변환되는 과정</h1>

<ol>
  <li><code class="language-plaintext highlighter-rouge">응용 계층</code>에서 3-way handshake로 connection이 확립된다.</li>
  <li>웹 브라우저에서 url을 입력하여 접속하면 html 데이터를 보내달라는 데이터(요청)가 생성된다.</li>
  <li><code class="language-plaintext highlighter-rouge">전송 계층</code>에서 TCP 헤더(출발지 포트 번호, 목적지 포트 번호가 들어 있다)가 붙는다. 즉, <strong>세그먼트</strong>가 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">네트워크 계층</code>에서 세그먼트에 IP 헤더(출발지 IP, 목적지 IP 주소가 붙어 있다)가 붙는다. 즉, <strong>IP 패킷</strong>이 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">데이터 링크 계층</code>에서 이더넷 헤더와 트레일러가 붙는다. 즉, <strong>이더넷 프레임</strong>이 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">물리 계층</code>에서 랜카드에 의해 <strong>전기 신호</strong>로 변환되어 네트워크로 전송된다.</li>
</ol>

<p>전기 신호를 받아 데이터로 변환하여 어플리케이션에 전달하는 과정은 위 과정의 역순이다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Network" /><category term="OSI" /><summary type="html"><![CDATA[OSI 모델의 전반적인 흐름에 대해 알아보자.]]></summary></entry><entry><title type="html">05.네트워크 계층</title><link href="http://localhost:4000/network/network05/" rel="alternate" type="text/html" title="05.네트워크 계층" /><published>2023-12-20T00:00:00+09:00</published><updated>2023-12-20T00:00:00+09:00</updated><id>http://localhost:4000/network/network05</id><content type="html" xml:base="http://localhost:4000/network/network05/"><![CDATA[<h1 id="1-다른-네트워크-간의-통신">1. 다른 네트워크 간의 통신</h1>

<p><code class="language-plaintext highlighter-rouge">네트워크 계층</code>에서는 네트워크 간의 통신을 가능하게 한다. 같은 네트워크 상의 컴퓨터로 정보를 전달할 때는 Ethernet과 스위치를 통해 소통이 가능했지만, 다른 네트워크 상의 컴퓨터로 데이터를 보내려면 MAC주소 외에 네트워크 주소가 추가로 필요하다.
네트워크를 식별하는 데 사용되는 주소를 <code class="language-plaintext highlighter-rouge">IP 주소</code>라고 한다. IP(Internet Protocol)는 네트워크 계층에서 사용되는 프로토콜이다. 네트워크 계층에서 다른 네트워크로 데이터를 전송하기 위해 <code class="language-plaintext highlighter-rouge">라우터(router)</code>라는 장비가 필요하다. 라우터는 데이터가 목적지까지 가는데 최적의 경로를 알려주는 역할을 한다. 이처럼 목적지 IP주소까지 어떤 경로로 데이터를 보낼지 결정하는 것을 <code class="language-plaintext highlighter-rouge">라우팅(routing)</code>이라고 한다. 라우터에는 <code class="language-plaintext highlighter-rouge">라우팅 테이블(routing table)</code>이 있어서 경로 정보를 등록하고 관리한다.
네트워크 계층에서 데이터를 캡슐화할 때, 데이터 앞에 IP 헤더를 붙인다.</p>

<p><code class="language-plaintext highlighter-rouge">라우터</code> : 서로 다른 네트워크를 연결해 주는 장치
<code class="language-plaintext highlighter-rouge">라우팅 테이블</code> : 컴퓨터 네트워크에서 목적지 주소를 목적지에 도달하기 위한 네트워크 노선으로 변환시킬 목적으로 사용되는 정보.
<code class="language-plaintext highlighter-rouge">라우팅</code> : 패킷을 목적지 컴퓨터까지 보낼 때 최적의 경로를 선택하여 전송하는 것
<code class="language-plaintext highlighter-rouge">정적 라우팅</code> : 관리자가 미리 라우팅 테이블에 경로를 수동으로 추가하는 방법. 목적지까지의 경로를 고정하거나 목적지까지의 경로가 하나로 한정되는 경우에 사용한다.
<code class="language-plaintext highlighter-rouge">동적 라우팅</code> : 네트워크 변경을 자동으로 감지하여 라우팅 테이블을 업데이트하거나 네트워크 장애가 발생했을 때 라우터끼리 정보를 교환하여 최적의 경로로 전환하는 방법이다. 관리자는 정적 라우팅처럼 라우팅 테이블에 경로를 수동으로 추가할 필요가 없다.</p>

<h1 id="2-ip-주소">2. IP 주소</h1>

<p>IP 주소는 ISP(인터넷 서비스 제공자)에게 받을 수 있다.</p>

<p>IP는 2가지 버전이 있다.</p>
<ul>
  <li>IPv4 : 32비트</li>
  <li>IPv6 : 128비트</li>
</ul>

<p>IPv4는 32비트이기 때문에 표현할 수 있는 주소에 한계가 있어서 IPv6가 등장하게 되었다.
IPv4로 표현할 수 있는 주소가 현재 필요로 하는 IP 주소의 수보다 부족하기 때문에 현재는 <code class="language-plaintext highlighter-rouge">공인 IP 주소</code>와 <code class="language-plaintext highlighter-rouge">사설 IP 주소</code>를 사용하고 있다.
참고로 공인 IP 주소는 ISP가 제공한다.</p>

<ul>
  <li>공인 IP 주소 : 인터넷에 직접 연결되는 컴퓨터나 라우터에 할당</li>
  <li>사설 IP 주소 : 회사나 가정의 랜에 있는 컴퓨터에 할당</li>
</ul>

<p>비트로 인한 IP 주소 수의 한계를 극복하기 위해 공인 IP는 라우터에 할당하고, 각 컴퓨터에는 랜의 네트워크 관리자가 자유롭게 사설 IP 주소를 할당하거나 라우터의 DHCP 기능을 사용하여 주소를 자동으로 할당한다.
이런 식으로 IP를 사용하면 공인 IP 주소를 절약할 수 있다. 사설 IP 주소는 한 네트워크 내에서 배정하는 주소기 때문에 서로 다른 네트워크 끼리는 중복이 될 수 있다.</p>

<p>IP 주소를 표시할 때, 사람이 읽기 편하도록 8비트 단위로 나눠서 표시하는데, 이를 <code class="language-plaintext highlighter-rouge">옥텟(octet)</code>이라고 한다.</p>

<p>ex. 11000100 11100100 000011000 00000010 -&gt; 4개의 옥텟
이를 더 읽기 편하도록 10진수로 변환하여 표시하기도 한다.
=&gt; 136.196.24.2</p>

<p>IP 주소는 <code class="language-plaintext highlighter-rouge">네트워크 주소</code>와 <code class="language-plaintext highlighter-rouge">호스트 주소</code>로 구성되어 있다.
네트워크 주소는 어떤 네트워크인지를 나타내며, 호스트 주소는 해당 네트워크의 어떤 컴퓨터인지를 나타낸다.</p>

<p>IP 주소는 A~E 클래스로 구분하며 일반적으로는 A~C 클래스를 사용한다.
A 클래스는 처음 1 옥텟을 네트워크 ID, 나머지 3 옥텟을 호스트 ID로 사용한다.
B 클래스는 처음 2 옥텟을 네트워크 ID, 나머지 2 옥텟을 호스트 ID로 사용하며
C 클래스는 처음 3 옥텟을 네트워크 ID, 나머지 1 옥텟을 호스트 ID로 사용한다.</p>

<p>A 클래스에서 네트워크 ID의 범위는 00000001 ~ 01111111이며,
B 클래스에서 네트워크 ID의 범위는 10000000 00000000 ~ 10111111 11111111,
C 클래스에서 네트워크 ID의 범위는 11000000 00000000 00000000 ~ 11011111 11111111 11111111이다.</p>

<p><code class="language-plaintext highlighter-rouge">네트워크 주소</code>를 표현할 때, 호스트 주소에 해당하는 비트는 0으로 채워 놓는다.
A 클래스 네트워크의 경우, 마지막 옥텟이 호스트 주소에 해당하므로 네트워크 주소가 192.168.1에 해당하는 경우를 예를 들면 다음과 같이 표현할 수 있다.
ex. 192.168.1.0</p>

<p><code class="language-plaintext highlighter-rouge">브로드캐스트 주소</code>는 해당 네트워크에 존재하는 모든 컴퓨터에 한번에 데이터를 전송할 때 사용하는 주소이다.
브로드 캐스트 주소는 호스트 주소에 해당하는 비트를 전부 1로 채워 놓는다.
192.168.1에 해당하는 네트워크의 경우, 다음과 같다.
ex. 192.168.1.255</p>

<h1 id="3-subnet">3. Subnet</h1>

<p>분할된 네트워크를 말하며, 네트워크를 분할하는 것을 subneting이라고 한다. 서브넷팅을 할 때, 호스트 ID에 해당하는 비트를 서브넷 ID로 사용한다. 따라서 “네트워크 ID + 호스트 ID”였던 구성이 “네트워크 ID + 서브넷 ID + 호스트 ID”로 바뀐다. 이렇게 서브넷 ID까지 사용하면 네트워크 ID가 어디까지인지 구분하기 힘들어진다. 이 때 이를 구분하기 위해 <code class="language-plaintext highlighter-rouge">Subnet Mask</code>라는 것을 사용한다.</p>

<p>서브넷 마스크는 네트워크 ID를 알아내기 위한 수단으로, A 클래스의 경우 처음 1옥텟이 네트워크 ID이므로 255.0.0.0, B 클래스의 경우 255.255.0.0, C 클래스의 경우 255.255.255.0이 된다. 이를 prefix 표기법으로도 표현할 수 있는데, 각각은 /8, /16, /24가 된다. 슬래쉬 이후에 몇 비트를 네트워크 ID로 표현하는 지를 나타낸다.</p>

<p>자신의 IP 주소와 서브넷 마스크를 &amp;연산(비트 연산)하면 네트워크 ID를 구할 수 있다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Network" /><category term="Network" /><category term="Subnet" /><category term="IP" /><summary type="html"><![CDATA[OSI 모델의 3계층인 네트워크 계층에 대해 알아보자.]]></summary></entry><entry><title type="html">04.데이터 링크 계층</title><link href="http://localhost:4000/network/network04/" rel="alternate" type="text/html" title="04.데이터 링크 계층" /><published>2023-12-20T00:00:00+09:00</published><updated>2023-12-20T00:00:00+09:00</updated><id>http://localhost:4000/network/network04</id><content type="html" xml:base="http://localhost:4000/network/network04/"><![CDATA[<h1 id="1-ethernet">1. Ethernet</h1>

<p>OSI 모델의 2계층인 데이터 링크 계층에서는 네트워크 장비 간에 신호를 주고 받는 규칙을 정한다. 이 때 가장 많이 사용되는 규칙이 <code class="language-plaintext highlighter-rouge">Ethernet</code>이다. 즉, LAN에서 데이터를 어떻게 주고받을 지에 대한 약속이다.
허브에 3개의 컴퓨터가 연결되어 있다고 가정하자. 만약 컴퓨터 1에서 컴퓨터 3에 데이터를 보내기 위해 허브에 데이터를 전달하면, 허브는 컴퓨터 2와 3 모두에 데이터를 보낸다.
이 때 데이터에는 목적지 주소가 포함되어 있어 목적지가 아닌 컴퓨터 2에서는 데이터를 받은 후 파기한다.</p>

<p>만약 컴퓨터 여러 대에서 동시에 데이터를 보내게 되면 충돌이 일어날 수 있다. 이를 방지하기 위해 Ethernet은 CSMA/CD 방법을 사용한다.</p>

<ul>
  <li>CS : 데이터를 보내려는 컴퓨터의 케이블에 전류가 흐르고 있는지 확인</li>
  <li>MA : 전류가 흐르고 있지 않다면 데이터를 송신</li>
  <li>CD : 충돌이 일어나는 지 확인</li>
</ul>

<p>현재는 효율이 좋지 않아 CSMA/CD 방식을 잘 사용하지 않고, 대신 <code class="language-plaintext highlighter-rouge">switch</code> 네트워크 장비를 사용한다.</p>

<h1 id="2-mac-주소">2. MAC 주소</h1>

<p>비트를 전기 신호로 변환하는 LAN 카드는 각각 고유한 <code class="language-plaintext highlighter-rouge">MAC 주소</code>를 가지고 있다. MAC 주소는 6바이트로 이루어져 있으며 앞의 3바이트는 제조사 번호, 뒤의 3바이트는 제조사에서 붙인 일련번호를 의미한다.
OSI 모델의 데이터 링크 계층, TCP/IP 모델의 네트워크 계층에서는 LAN 카드로 데이터를 전송하기 전에 <code class="language-plaintext highlighter-rouge">헤더</code>와 <code class="language-plaintext highlighter-rouge">트레일러</code>를 붙인다. 헤더는 총 14바이트로 목적지 MAC 주소(6바이트), 출발지 MAC주소(6바이트), Ethernet type(2바이트)로 이루어져 있다.
여기서 Ethernet type은 Ethernet으로 전송되는 상위 계층 프로토콜의 종류를 나타낸다. 트레일러는 FCS(Frame Check Sequence)라고도 불리며, 데이터 전송 도중 오류 발생 여부를 확인하는 용도이다.</p>

<p>헤더와 트레일러가 추가된 데이터를 <code class="language-plaintext highlighter-rouge">프레임(Frame)</code>이라고 한다. 즉, 네트워크를 통해 전송되는 것이 바로 프레임이다.</p>

<p>수신 측의 컴퓨터에서는 이 프레임을 받아서 목적지 주소가 자신과 일치하면 역캡슐화를 통해 데이터를 얻는다.</p>

<h1 id="3-switch">3. Switch</h1>

<p>Switch는 데이터 링크 계층에서 작동하며 Layer 2 Switch, Switching hub라고도 불린다. 스위치 내부에는 Switch의 포트 번호와 해당 포트에 연결되어 있는 컴퓨터의 MAC 주소가 등록되어 있는 데이터베이스인 <code class="language-plaintext highlighter-rouge">MAC address table</code>가 존재한다.
스위치가 처음 켜지면 Mac address table에는 아무런 정보가 없다. 이 때 컴퓨터 1에서 컴퓨터 5에 데이터를 전송하기 위해 프레임을 스위치로 보내면, MAC address table에 컴퓨터 1의 MAC 주소와 포트 번호 정보가 업데이트된다. 하지만 목적지인 컴퓨터 5에 대한 정보가 테이블에 없으므로 컴퓨터 1을 제외한 모든 포트에 프레임을 보낸다. 이를 <code class="language-plaintext highlighter-rouge">flooding</code>이라고 한다.
만약 컴퓨터 5의 정보가 테이블에 있었다면, 스위치는 프레임을 컴퓨터 5에 해당하는 포트로만 전달하며 이를 <code class="language-plaintext highlighter-rouge">MAC 주소 필터링</code>이라고 한다.</p>

<h1 id="4-통신-방식">4. 통신 방식</h1>

<ul>
  <li>전이중 통신 방식 : 각각 송신과 수신을 위한 회선이 존재해 데이터의 송수신이 동시에 가능한 방식</li>
  <li>반이중 통신 방식 : 회선 하나로 송신과 수신을 번갈아 가며 통신하는 방식</li>
</ul>

<p>허브는 회선 하나를 사용하기 때문에 반이중 통신 방식을 사용하며 충돌 도메인(충돌이 발생했을 때 영향을 미치는 범위)의 범위가 허브에 연결되어 있는 모든 컴퓨터가 된다. 반면 스위치는 송신과 수신을 위한 회선이 따로 존재하기 때문에 충돌이 발생할 확률이 적고 충돌 도메인 또한 충돌이 발생한 컴퓨터 하나로 제한된다.</p>]]></content><author><name>Hyunsoon Im</name><email>s7514036@naver.com</email></author><category term="Network" /><category term="Ethernet" /><category term="MacAddress" /><category term="Switch" /><summary type="html"><![CDATA[OSI 모델의 2계층인 데이터 링크 계층에 대해 알아보자.]]></summary></entry></feed>
---
title: \[Effective C++\] \#define을 쓰려거든 const, enum, inline을 떠올리자
excerpt: Effective C++ 항목 02 정리
categories:
  - Cpp
tags:
  - C++
  - Cpp
  - EffectiveC++
---
<br>
# 1. \#define을 쓰려거든 const, enum, inline을 떠올리자
<br>
다시 말하면 "가급적 선행 처리자보다 컴파일러를 더 가까이 하자"는 뜻이다.

```c++
#define ASPECT_RATIO 1.653

...
```

위와 같이 작성된 코드가 있다고 하자. 위 소스 코드는 컴파일러로 넘어가기 전에 선행 처리자가 ASPECT_RATIO라는 이름을 밀어버리고 숫자 상수(1.653)로 대체한다. 그 결과 ASPECT_RATIO는 컴파일러가 쓰는 기호 테이블에 들어가지 않고, 이는 컴파일 에러를 해결할 때 어려움을 겪게 할 수 있다. 특히, 코드를 작성하지 않은 다른 사람이 이를 해결하려고 하면 더욱 난감할 것이다.

이 문제의 해결법은 매크로 대신 상수를 쓰는 것이다.
```c++
const double AspectRatio = 1.653;
```
위의 AspectRatio는 언어 차원에서 지원하는 상수 타입의 데이터이기 때문에 당연히 컴파일러의 눈에도 보이며 기호 테이블에 들어간다.

또한 위의 예시처럼 작성할 경우, 컴파일을 거친 최종 코드의 크기가 `#define`을 썼을 때 보다 더 작을 수 있다. `#define`의 경우 선행 처리자가 코드 상의 ASPECT_RATIO를 1.653으로 바꾸는 만큼 1.653의 사본이 많이 생기는 반면, AspectRatio는 한 개의 변수만 존재하기 때문이다.

	상수 정의는 대개 헤더 파일에 넣는 것이 관례이다.

만약 클래스 멤버로 상수를 정의하는 경우, 그 상수의 사본 개수가 한 개를 넘지 못하게 하고 싶다면 `static` 멤버로 만들어야 한다.
```c++
class GamePlayer
{
	private:
		static const int c = 5;
		int scores[c];
		...
}
```

보통은 위와 같이 클래스 안에 선언하는 것이 문제가 되지 않지만, 클래스 상수의 주소를 구하거나 구식 컴파일러의 경우 정의를 구현 파일에서 제공해야 한다.

```c++
const int GamePlayer::c;
```

웬만한 경우에는 이것으로 해결이 되지만, GamePlayer::scores와 같이 배열을 선언할 때 컴파일러가 컴파일 과정에서 이 배열의 크기를 알아야 한다며 문제를 일으킬 수 있다. 이 경우에는 `enum hack` 기법을 떠올리자.

`enum hack`은 enumerator 타입의 값은 int가 놓일 곳에도 쓰일 수 있다는 사실을 활용하는 것이다.
```c++
class GamePlayer
{
	private:
		enum { c = 5 };

		int scores[c];
}
```

`enum hack`의 동작 방식은 `const`보다 `#define`에 더 가깝다. enum의 주소를 취하는 것은 불법이며 \#define의 주소를 얻는 것 역시 마찬가지다. 따라서 선언한 정수 상수를 가지고 다른 사람이 주소를 얻거나 참조자를 쓰는 것이 싫다면 enum은 아주 좋은 자물쇠가 될 수 있다.

\#define을 오용하는 또다른 사례로 매크로 함수가 있다. 함수 호출 오버헤드를 일으키지 않는다는 점에서 매크로 함수를 사용하지만 문제가 있다. 아래는 매크로 인자들 중 큰 것을 사용해 어떤 함수 f를 호출하는 매크로이다.
```c++
#define CALL_WITH_MAX(a, b) f((a) > (b) ? (a) : (b))
```

매크로를 작성할 때는 매크로 본문에 들어 있는 인자마다 반드시 괄호를 씌워줘야 한다. 하지만 이 부분을 제대로 처리했다고 해도 문제가 발생한다.

```c++
int a = 5, b = 0;

CALL_WITH_MAX(++a, b);  // a가 두 번 증가한다.
CALL_WITH_MAX(++a, b+10); // a가 한 번 증가한다.
```

비교의 결과로 어떤 인자를 가져오느냐에 따라 결과가 달라지는 문제가 발생한다.
함수 호출을 없애 주는 매크로의 효율을 그대로 유지하면서 정규 함수의 모든 동작방식 및 타입 안전성까지 완벽히 취할 수 있는 방법이 있다.
바로 "인라인 함수 템플릿"이다.

```c++
template <typename T>
inline void callWithMax(const T& a, const T& b)
{
	f(a > b ? a : b);
}
```

이 함수는 템플릿이기 때문에 동일 계열 함수군(family of functions)을 만들어낸다. 또한 진짜 함수이기 때문에 유효범위 및 접근 규칙을 그대로 따라간다.


🔔 단순한 상수를 쓸 때는, \#define보다 const 객체 혹은 enum을 우선 떠올리자.
🔔 함수처럼 쓰이는 매크로를 만들려면, \#define 매크로보다 인라인 함수를 우선 떠올리자.
{: .notice--primary}
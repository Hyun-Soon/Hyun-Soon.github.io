---
title: \[Effective C++\] 낌새만 보이면 const를 들이대 보자!
excerpt: Effective C++ 항목 03 정리
categories:
  - Cpp
tags:
  - C++
  - Cpp
  - EffectiveC++
---

<br>
# 1. const_iterator
<br>
```c++
const int* ptr; //int 값이 const
int const * ptr; //int 값이 const
int* const ptr; //ptr이 const
```

STL iterator는 포인터를 본뜬 것이기 때문에 기본 동작 원리가 T* 포인터와 매우 흡사하다. 변경이 불가능한 객체를 가리키는 iterator가 필요하다면, `const_iterator`를 사용하면 된다.

```c++
const std::vector<int>::iterator iter; //iter가 const
std::vector<int>::const_iterator cIter; //cIter가 가리키는 값이 const
//
```
<br>
# 2. 상수 멤버 함수
<br>
멤버 함수 끝에 붙는 const 키워드의 역할은 "해당 멤버 함수가 상수 객체에 대해 호출될 수 있는 함수이다"라는 사실을 알려주는 것이다. C++ 프로그램의 실행 성능을 높이는 핵심 기법 중 하나는 객체 전달을 '상수 객체에 대한 참조자(reference-to-const)'로 진행하는 것이다. 이 기법이 제대로 동작하려면 const 멤버 함수가 존재해야 한다. const 키워드가 있고 없고의 차이만 있는 멤버 함수들은 오버로딩이 가능하다.

```c++
class TextBloack
{
	public:
		...

		//상수 객체에 대한 operator[]
		const char& operator[] (std::size_t position) const
		{
			return text[position];
		}

		//비상수 객체에 대한 operator[]
		char& operator[] (std::size_t position)
		{
			return text[position];
		}

	private:
		std::string text;
};

int main()
{
	TextBlock tb("Hello");
	std::cout << tb[0] << std::endl; //비상수 멤버 함수를 호출한다.

	const TextBlock ctb("World");
	std::cout << ctb[0] << std::endl; //상수 멤버 함수를 호출한다.
	return 0;
}
```

멤버 함수가 상수 멤버라는 것은 두가지 개념을 내포한다.
1. bitwise constness(physical constness) 비트수준 상수성
2. logical constness 논리적 상수성

비트수준 상수성은 어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야 그 멤버 함수가 'const'임을 인정하는 개념이다. 그런데, 애석하게도 '제대로 const'로 동작하지 않는데도 이 비트수준 상수성 검사를 통과하는 멤버 함수들이 존재한다.

```c++
class CTextBlock
{
	public:
		...

		char& operator[] std::size_t position const
		{
			return pText[position];
		}

	private:
		char* pText;
}
```

operator[]의 내부 코드만 보면 pText를 건드리지 않으므로 컴파일러는 operator[] 코드를 생성할 때 불평할 이유가 없다. 하지만 reference를 반환하고 있으므로 다른 코드에서 operater[]를 이용해 pText의 값을 바꿀 위험이 있다. 상수 멤버 함수를 사용했지만 비트수준 상수성이 깨질 가능성이 있다는 말이다.

논리적 상수성은 이런 황당한 상황을 보완하는 대체 개념으로 나오게 되었다.
상수 멤버 함수라고 해서 객체의 한 비트도 수정할 수 없는 것이 아니라 일부 몇 비트 정도는 바꿀 수 있되, 그것을 사용자(이 책에서는 이 코드를 사용하는 다른 프로그래머도 사용자라고 칭한다) 측에서 알아채지 못하게만 하면 상수 멤버 자격이 있다는 것이다.

```c++
class CTextBlock
{
	public:
		...

		std::size_t length() const;

	private:

		char* pText;
		
		//mutable은 non-static 데이터 멤버를 비트 수준 상수성의 족쇄에서 해방시켜준다.
		mutable std::size_t textLength;
		mutable bool lengthIsValid;
};

std::size_t CTextBlock::length() const
{
	if (!lengthIsValid)
	{
		textLength = std::strlen(pText);
		lengthIsValid = true;
	}

	return textLength;
}
```

<br>
# 3. 상수 멤버 및 비상수 멤버 함수에서 코드 중복 현상을 피하는 방법
<br>
단순히 문자를 리턴하는 것이 아니라 operator[] 내부에서 경계 검사, 자료 무결성 검증 등 다양한 일을 한다고 생각해보자.

```c++
class TextBlock
{
	public:
		...

		const char& operator[] (std::size_t position) const
		{
			... //경계 검사
			... //자료 무결성 검증
			... //등등
			...
			return text[position];
		}

		char& operator[] (std::size_t position)
		{
			... //경계 검사
			... //자료 무결성 검증
			... //등등
			...
			return text[position];
		}

	private:
		std::string text;
}
```

같은 기능을 하지만 const 때문에 코드 중복이 발생한다. 이 때 코드 중복을 피할 수 있는 방법이 있는데, 주의할 점이 있다. const가 아닌 것에 const를 붙이는 것은 안전하지만, 이미 const인 것에서 const를 떼어내는 것은 위험하다는 점을 생각하자.

```c++
class TextBlock
{
	public:
		...

		const char& operator[] (std::size_t position) const //이전과 동일
		{
			...
		}

		char& operator[] (std::size_t position)
		{
			return const_cast<char&>(
						static_cast<const TextBlock&>(*this)[position]
						);
		}
}
```



🔔 const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다. const는 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을 수 있고, 멤버 함수에도 붙을 수 있다.<br>
🔔 컴파일러 쪽에서 보면 비트 수준 상수성을 지켜야 하지만, 프로그래머는 논리적 상수성을 사용해서 프로그래밍하는 방법도 있다는 것을 알아두자.<br>
🔔 상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드 중복을 피하는 것이 좋은데, 이때 비상수 버전이 상수 버전을 호출하도록 만들어라.
{: .notice--primary}
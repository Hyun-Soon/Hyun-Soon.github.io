---
title: \[Effective C++\] 객체를 사용하기 전에 반드시 그 객체를 초기화하자
excerpt: Effective C++ 항목 04 정리
categories:
  - Cpp
tags:
  - C++
  - Cpp
  - EffectiveC++
---

<br>
# 1. 객체를 사용하기 전에 반드시 그 객체를 초기화하자
<br>

초기화 리스트를 사용하면 멤버 데이터들의 복사 생성자를 사용하여, 멤버 데이터를 생성과 동시에 초기화할 수 있다.
```c++
class PhoneBook
{
	private:
		std::string name;
		std::string phoneNumber;

	public:
		...
		PhoneBook(const std::string& inputName, const std::string& inputPhoneNumber)
		: name(inputName), phoneNumber(inputPhoneNumber)
		{}
}
```

이떤 클래스의 멤버 데이터가 있다. 멤버 초기화 리스트에 들어있지 않더라도 그 데이터 타입이 사용자 정의 타입이면 컴파일러는 자동으로 그들 멤버에 대해 기본 생성자를 호출한다. 하지만 실수를 줄이기 위해 웬만하면 모든 데이터 멤버는 초기화 리스트에서 초기화 해주도록 하자.

기본 생성자로 초기화하고 싶은 경우에도 초기화 리스트에 명시해주는 습관을 들이자.
```c++
PhoneBook() : name(), phoneNumber() {}
```

c++의 기본 제공 타입(bool, char, ...)은 생성과 동시에 초기화하나, 생성 후에 대입을 하나 걸리는 시간이 똑같지만 가독성을 위해 초기화 리스트에 넣어주자. 기본 제공 타입을 반드시 초기화 리스트에 넣어야 할 경우가 있는데, 바로 `const` 또는 `reference`일 경우이다. const와 reference는 생성과 동시에 초기화되어야 한다.

C++에서 객체의 초기화 순서는 컴파일러를 막론하고 똑같다.
1. 기본 클래스는 파생 클래스보다 먼저 초기화된다.
2. 클래스 데이터 멤버는 그들이 선언된 순서대로 초기화된다.
멤버 초기화 리스트에 넣는 순서도 선언된 순서대로 넣어주도록 하자.

초기화 순서에 대한 하나의 문제가 남아있다.
"비지역 정적 객체(non-local static object)의 초기화 순서는 개별 번역 단위(translation unit)에서 정해진다"는 것이다.

`정적 객체(static object)`는 자신이 생성된 시점부터 프로그램이 끝날 때까지 살아 있는 객체를 일컫는다.
정적 객체의 범주에 들어가는 것은 5가지가 있다.
1. 전역 객체
2. 네임스페이스 유효범위에서 정의된 객체
3. 클래스 안에서 static으로 선언된 객체
4. 함수 안에서 static으로 선언된 객체
5. 파일 유효범위에서 static으로 정의된 객체

이들 중 함수 안에 있는 정적 객체는 지역 정적 객체(local static object)라 하고(함수에 대해 지역성을 가지므로), 나머지는 비지역 정적 객체(non-local static object)라 한다.

`번역 단위(translation unit)`는 컴파일을 통해 하나의 목적 파일(object file)을 만드는 바탕이 되는 소스 코드를 일컫는다. 여기서 번역은 소스의 언어를 기계어로 옮긴다는 의미다. 기본적으로는 소스 파일 하나가 되는데, 그 파일이 \#include하는 파일들까지 합쳐서 하나의 번역 단위가 된다.

즉 위에서 말한 문제는, 별도로 컴파일된 소스 파일이 두 개 이상 있으며 각 소스 파일에 비지역 정적 객체가 한 개 이상 들어 있는 경우에서, 한 쪽의 정적 객체가 초기화되지 않은 상황에 다른 쪽에서 이 객체를 사용할 때 발생하는 문제를 말한다.

예를 들어, 파일 시스템에 관한 라이브러리가 있고 사용자가 이를 이용해 디렉토리 클래스를 만든다고 하자.
```c++
//파일 시스템 라이브러리
class FileSystem //라이브러리에 포함된 클래스
{
	public:
		...
		std::stize_t numDisks() const; //많고 많은 멤버 함수들 중 하나
		...
};

extern FileSystem tfs; //사용자가 쓰게 될 객체
```


```c++
//사용자가 라이브러리를 이용해 만든 클래스
class Directory
{
	public:
		Directory( params );
		...
};

Directory::Directory ( params )
{
	...
	std::size_t disks = tfs.numDisks(); //tfs 객체를 여기서 사용함
	...
}


int main()
{
	Directory tempDir( params ); //임시 파일을 담는 디렉토리 //여기서 문제가 발생한다.
	...
	return 0;
}
```

정적 객체 tfs의 초기화 순서 때문에 이런 상황에서 문제가 발생한다. tfs가 tempDir보다 먼저 초기화되지 않으면, tempDir의 생성자는 tfs가 초기화되지 않았는데도 tfs를 사용하려고 시도한다.

non-local static object의 초기화 순서가 정해져 있지 않은 상황에서 이 문제를 어떻게 해결할까?
함수 안에 집어넣어 `Singleton pattern`을 활용하면 된다.

```c++
'''FileSystem'''

class FileSystem { ... };

FileSystem& tfs()
{
	static FileSystem fs;
	return fs;
}


'''Directory'''

...

Directory& tempDir()
{
	static Directory td;
	return td;
}
```

이런 식으로 함수의 return을 받아 사용하게 되면 초기화 문제를 해결할 수 있다.

정리하자면, 어떤 객체가 초기화되기 전에 그 객체를 사용하는 사용하는 일이 생기지 않도록 하려면 세가지를 기억하자.
1. 멤버가 아닌 기본제공 타입 객체는 직접 초기화 해야 한다.
2. 객체의 모든 부분에 대한 초기화에는 멤버 초기화 리스트를 사용한다.
3. 별개의 번역 단위에 정의된 비지역 정적 객체에 영향을 끼치는 불확실한 초기화 순서를 염두에 두고 이러한 불확실성을 피해서 프로그램을 설계해야 한다.


🔔 기본제공 타입의 객체는 직접 손으로 초기화한다.<br>
🔔 생성자에서는, 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방법으로 멤버를 초기화하지 말고 멤버 초기화 리스트를 사용하자. 이 때, 각 데이터 멤버가 선언된 순서와 똑같이 나열해야 한다.<br>
🔔 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제를 피해서 설계하자. 비지역 정적 객체를 지역 정적 객체로 바꾸면 된다.
{: .notice--primary}
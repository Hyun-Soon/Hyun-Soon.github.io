---
title: \[UE\] Unreal Engine 용어 정리
excerpt: 언리얼 엔진 공식 문서 용어 정리
categories:
  - UnrealEngine
tags:
  - UnrealEngine
---
# 언리얼 엔진 용어 정리

[언리얼 공식 문서](https://dev.epicgames.com/documentation/ko-kr/unreal-engine/unreal-engine-terminology)

0. **Blueprint**

	블루프린트 비주얼 스크립팅(Blueprint Visual Scripting) 시스템은 노드(Node) 기반의 인터페이스를 사용하여 언리얼 에디터 내의 게임플레이 엘리먼트를 생성하는, 게임플레이 스크립팅 시스템이다. 여러 일반적인 스크립팅 언어와 마찬가지로, 블루프린트도 엔진에서 Objec-Oriented 클래스 또는 오브젝트를 정의하기 위해 사용된다.

1. **Object**

	언리얼에서 가장 기본적인 클래스. 오브젝트는 구성단위 역할을 하며, 에셋에 필수적인 기능을 많이 포함하고 있다. 언리얼 엔진의 거의 모든 것이 오브젝트로부터 상속받거나 함수 기능을 사용한다.
	
	C++에서 `UObject`는 모든 오브젝트의 베이스 클래스이다. 가비지 컬렉션, 언리얼 에디터에 변수를 노출하기 위한 메타데이터(`UProperty`) 지원, 로딩 및 저장 직렬화 등의 기능을 구현한다.

2. **Actor**

	액터는 카메라, 스태틱 메시, 플레이어 스타트 위치 등과 같이 레벨에 배치할 수 있는 모든 오브젝트를 가리킨다. 액터는 이동, 회전, 스케일링 등의 3D 트랜스폼을 지원한다. 또한 C++ 또는 블루프린트 게임플레이 코드를 통해 생성(스폰) 및 소멸될 수 있다.
	
	C++에서 `AActor`는 모든 액터의 베이스 클래스이다.

3. **Pawn**

	폰은 액터의 서브클래스이며, 인게임 아바타 또는 페르소나(게임 안의 캐릭터 등)의 역할을 한다. 폰은 플레이어 또는 게임 AI로 제어되는 NPC(논플레이어 캐릭터) 등이 있다.
	
	인간이나 AI 플레이어가 폰을 제어하면, 그 폰은 `빙의된(Possessed) 상태`로 간주한다. 반대로 인간이나 AI 플레이어가 제어하지 않는 폰은 `빙의 해제된(Unpossessed)` 것으로 여겨진다.

4. **Character**

	캐릭터는 플레이어 캐릭터로 사용하기 위한 폰 액터의 서브클래스이다. 캐릭터 클래스에는 콜리전 설정, 바이페드(Biped) 움직임을 위한 입력 바인딩, 플레이어가 제어하는 움직임을 위한 추가 코드 등이 포함된다.
	
	기능이 많아서 리소스를 많이 사용하기 때문에, 조심해서 사용해야 한다.

5. **Player Controller**

	플레이어 컨트롤러는 플레이어의 입력을 게임 안의 상호작용으로 변환한다. 모든 게임에는 최소 하나의 플레이어 컨트롤러가 있다. 플레이어 컨트롤러는 게임 안에서 플레이어를 나타내는 폰이나 캐릭터에 빙의할 때가 많다.
	
	플레이어 컨트롤러는 또한 멀티플레이어 게임의 주요한 네트워크 상호작용 지점이다. 멀티플레이어 게임의 플레이 동안에는 서버가 각 플레이어에게 네트워크 함수 호출을 할 수 있어야 하기 때문에 게임 안의 모든 플레이어에 대해 하나의 플레이어 컨트롤러 인스턴스를 지닌다. 각 클라이언트는 자신의 플레이어에 해당하는 플레이어 컨트롤만을 가지고, 서버와 통신하는 용도로만 사용할 수 있다.
	
	연관된 C++ 클래스는 `APlayerController`이다.

6. **AI Controller**

	플레이어 컨트롤러가 게임 안에 플레이어를 나타내는 폰을 소유하듯이, AI 컨트롤러도 게임 안에 NPC를 나타내는 폰을 소유한다. 폰과 캐릭터는 특정 플레이어 컨트롤러가 빙의했거나 스스로 AI 컨트롤러를 생성하지 말라는 명령을 받지 않았다면 기본적으로 베이스 AI 컨트롤러에 빙의된다.
	
	 연관된 C++ 클래스는 `AAIConteroller`이다.

7. **Player State**

	플레이어 스테이트는 게임 참여자의 스테이트를 말한다.인간 플레이어 또는 플레이어를 시뮬레이션하는 봇 등이 있다. 게임 월드의 일부로 존재하는 논플레이어 AI의 경우 플레이어 스테이트가 없다.
	
	플레이어 스테이트에 포함되는 플레이어 정보의 예는 다음과 같다.
	- 이름
	- 현재 레벨
	- 체력
	- 점수
	- 깃발 뺏기(Capture the Flag) 게임에서 현재 깃발을 들고 있는지 여부
	
	멀리플레이어 게임의 경우 모든 컴퓨터에 모든 플레이어의 플레이어 스테이트가 존재하며, 동기화를 유지하기 위해 서버에서 클라이언트로 데이터를 리플리케이트할 수 있다. 이는 특정 플레이어 컨트롤러가 나타내는 플레이어의 컴퓨터에만 존재하는 플레이어 컨트롤러와는 다르다.
	
	연관된 C++ 클래스는 `APlayerState`이다.

8. **GameMode**

	게임 모드는 플레이 중인 게임의 규칙을 설정한다. 규칙에는 다음이 포함될 수 있다.
	- 플레이어가 게임에 참여하는 방법
	- 게임의 일시 정지 가능 여부
	- 승리 조건 등 특정 게임 전용 행동
	
	프로젝트 세팅에서 디폴트 게임 모드를 설정하고 레벨 별로 오버라이드할 수 있다. 어떤 방법으로 구현하든, 한 레벨에는 하나의 게임 모드만 존재할 수 있다.
	
	멀티플레이어 게임의 경우 게임 모드는 서버에만 존재하며, 연결된 각 클라이언트에 규칙이 복제(전송)된다. 따라서 UI 같은 작업을 게임 모드에서 하는 것을 삼가야 한다.
	
	연관된 C++ 클래스는 `AGameMode`이다.

9. **Game State**

	게임 스테이트는 게임 내의 모든 클라이언트에 복제할 정보가 들어 있는 컨테이너이다. 쉽게 말해 연결된 모든 사람에 대한 `게임의 스테이트`를 뜻한다.
	
	다음은 게임 스테이트의 몇 가지 예이다.
	- 게임 점수에 대한 정보
	- 대결이 시작됐는지 여부
	- 월드에 있는 플레이어 수를 기준으로 스폰할 AI 캐릭터의 수
	
	멀티플레이어 게임의 경우 게임 스테이트에 대한 로컬 인스턴스가 각 플레이어의 컴퓨터에 하나씩 있다. 로컬 게임 스테이트 인스턴스는 서버의 게임 스테이트 인스턴스에서 업데이트된 정보를 가져온다.
	
	연관된 C++ 클래스는 `AGameState`이다.

10. **Brush**

	브러시는 큐브, 구체와 같은 3D Shape를 묘사하는 액터이다. 레벨에 브러시를 배치하여 레벨 지오메트리를 정의할 수 있다. 이를 바이너리 스페이스 파티션(Binary Space Partition) 또는 BSP 브러시라고 한다 레벨의 윤곽 작업을 빠르게 하고 싶은 경우 등에 유용하다.

11. **Volume**

	볼륨은 연결된 효과에 따라 용도가 달라지는 바운드된 3D 공간이다. 예를 들면,
	- Blocking Volumes : 보이지 않으며 액터가 통과하지 못하게 막는다.
	- Pain Causing Volumes : 오버랩되는 액터에 시간이 지남에 따라 데미지를 준다.
	- Trigger Volumes : 액터가 들어오거나 나갈 때 이벤트를 유발하도록 프로그래밍된다.

12. **Level**

	레벨은 개발자가 정의하는 게임 플레이 영역이다. 레벨에는 지오메트리, 폰, 액터 등과 같이 플레이어가 보고 상호작용할 수 있는 모든 것이 포함된다.
	
	언리얼 엔진은 각 레벨을 별도의 `.umap`파일로 저장한다. 그래서 때로는 맵이라고 불리기도 한다.

13. **World**

	월드는 게임을 구성하는 모든 레벨이 담겨 있는 컨테이너다. 레벨의 스트리밍과 다이내믹 액터의 스폰(생성)을 처리한다.



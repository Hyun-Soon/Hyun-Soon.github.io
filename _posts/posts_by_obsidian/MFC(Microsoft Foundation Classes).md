---
title: \[Category\] MFC
excerpt:
categories:
tags:
---
# 0. MFC

Microsoft Foundation Classes, MFC  
  
Microsoft Windows 운영체제 환경에서 작동하는 GUI 응용프로그램을 개발하기 위해 Windows API의 C 언어 함수들을 Wrapping 하여 C++ 언어의 클래스화 한 GUI 프레임워크로, 1992년 발표되었다.  
  
윈도우 환경에서 COM(Component Object Model) 개발을 위한 라이브러리인 ATL과 CString 등의 기반 클래스를 공유하는 등 매우 밀접한 관련이 있다.

## 0-1. 사용 목적

Microsoft Windows용 GUI 응용프로그램을 개발하기 위해 별도의 라이브러리 없이 운영체제가 제공하는 C언어 기반의 Windows API를 직접 사용할 수도 있으나, Windows API는 단순히 운영체제의 여러 기능들을 노출시켜주는 함수들의 집합일 뿐이기 때문에 복잡한 UI를 작성하는 등의 고차원적인 작업을 할 때에는 필연적으로 코드 노가다가 수반되어 난이도가 높고 생산성이 떨어진다. 그리고 최신의 윈도 컨트롤과 같은 고차원적인 기능들은 Windows API가 아닌 COM 라이브러리로만 쓸 수 있기 때문에 Windows API만으로는 한계가 있다. 그래서 이걸 그나마 좀 편하게 C++ 클래스 형태로 쓸 수 있도록 해주는 것이 바로 MFC이다.

# MFC 1장

- MFC는 수많은 API 중 자주 사용되는 부분만 모아 C++ 라이브러리 형태로 제공하기 때문에 MFC를 이용하여 프로그램을 제작하더라도 API를 직접 호출하는 경우가 생긴다.
- **Message Handler** : 메시지를 받았을 때 동작을 결정하는 코드
- **Window Proceduer(WndProc)** : 메시지 핸들러의 집합
- 윈도우 운영체제가 제공하는 API는 DLL 형태로 제공되며, 프로그래머가 직접 필요한 기능을 DLL로 제작하기도 한다. 따라서 윈도우 응용 프로그램의 기능은 실행 파일 외에도 운영체제가 기본으로 제공하는 DLL과 사용자 정의 DLL에 분산되어 있다고 볼 수 있다.
- SDK : 개발 도구 모음. 컴파일러, 각종 개발 툴, 헤더 파일, 라이브러리 파일 등을 포함

- **HINSTANCE** : 실행 중인 프로그램의 인스턴스를 식별하는 핸들. 윈도우 클래스 등록(RegisterClassEX), 리소스 로딩(LoadIcon, LoadCursor등)에 사용
- **HDC(Handle to Device Context)** : 출력 장치(모니터, 프린터 등)에 대한 "그리기 환경"을 나타내는 핸들
- **WPARAM & LPARAM** : 메시지 처리(`WndProc`)에서 추가 정보를 담는 매개변수.

- `WPARAM`: 주로 **작은 값**(정수, 키보드 가상 키 코드, 컨트롤 ID 등)을 전달.
    
- `LPARAM`: 주로 **포인터 또는 큰 값**(좌표, 윈도우 핸들, 구조체 포인터 등)을 전달.
- **HWND** : 윈도우(창)를 식별하는 핸들. 특정 윈도우에 메시지를 보내거나 속성을 변경할 때 사용.

- **공유 DLL에서 MFC 사용**
	프로그램이 실행될 때, 운영체제에 있는 `MFCxxx.dll` (예: `MFC140.dll`, `MFC140U.dll`)을 로드해서 사용.
    
	실행 파일 자체는 비교적 **작아짐** (MFC 라이브러리를 포함하지 않으니까).
    
	하지만 실행 환경에 **해당 DLL이 반드시 설치**되어 있어야 함.
    
	여러 프로그램이 동시에 같은 MFC DLL을 공유 가능 → 메모리 절약.
![[Pasted image 20250922151337.png]]

# MFC 2장

- `framework.h`, `pch.h`, `pch.cpp` : 미리 컴파일된 헤더를 생성한다. MFC에서 사용하는 헤더 파일은 크기가 커서 컴파일하는 데 오래 걸린다. 사용할 헤더 파일을 framework.h에 선언해두면 컴파일러가 헤더를 미리 컴파일하여 \*.pch 파일(바이너리 포맷)로 저장해놓기 때문에 다음번에는 컴파일에 걸리는 시간을 훨씬 줄일 수 있다.
- MFC GUI 응용 프로그램은 CWinApp 클래스에서 파생 클래스를 만들고 이 파생 클래스를 이용하여 전역 객체를 생성한다. 하지만 MFC 콘솔 응용 프로그램은 윈도우를 갖지 않기 때문에 CWinApp 클래스를 그대로 이용하여 객체를 만든다.
- 리소스 스트링 편집
![[Pasted image 20250923111116.png]]

- `리소스 편하게 편집하기` : 리소스 뷰 클릭 -> 편집 -> 리소스 추가
- `Handle` : 운영체제가 관리하는 객체(윈도우, GDI 객체, 메뉴 등)에 접근하기 위한 간접적인 식별자. 즉, 직접 메모리 주소를 건드리지 않고, OS가 객체를 대신 관리해 주고 우리가 접근할 수 있도록 "자동차 핸들" 같은 것을 제공하는 것.

- `*.ipch` :  Microsoft Visual Studio에서 인텔리센스(IntelliSense) 기능을 위해 생성되는 파일
- `유니코드` vs `멀티바이트` vs `utf-8`?

•CWinApp(응용 프로그램 클래스)

Ø프로그램 전체를 대표하는 클래스(WinMain 대체)

Ø메시지 루프와 초기화 과정을 MFC가 제공

ØInitInstance()를 오버라이딩해서 윈도우를 생성해야 함

•CFrameWnd(프레임 윈도우)

Ø메뉴, 타이틀 바, 상태 표시줄 등을 포함하는 기본 윈도우 클래스

ØWinAPI의 `CreateWindow` + `DefWindowProc`을 캡슐화

ØMDI, SDI 같은 문서-뷰 구조도 프레임 윈도우를 기반으로 확장됨


- `문자 인코딩` : 문자의 집합을 나타내기 위해 각 문자를 숫자 값(부호)으로 변환하는 방식입니다. 예를 들어, '가'와 같은 한글 문자를 컴퓨터가 인식할 수 있는 숫자 값으로 바꾸는 것입니다.
- `Unicode` : 문자 집합(Character Set), 즉 "문자 -> 숫자 (Code Point)" 매핑 규격. 유니코드는 문자 집합일 뿐, 인코딩 방식이 아님.
ex. `A` -> U+0041, `가` -> U+AC00
- `Multibyte` : Windows에서 ANSI 문자 집합(1바이트) + 확장 문자(2바이트)를 섞어서 쓰는 방식. 대표적으로 한국어 윈도우에서는 CP949(완성형 한글), 일본어는 (Shift-JIS). 즉, 멀티바이트는 코드 페이지(Code Page) 기반 인코딩을 의미함.
- `UTF-8` : Unicode 문자를 저장하는 인코딩 방식 중 하나. 가변 길이(1~4바이트)라는 특징이 있으며, ASCII 범위(0~127)는 그대로 1바이트로 호환됨(인터넷 표준). 

# MFC 3장

![[Pasted image 20250924105703.png]]

- API를 기반으로 한 SDK 프로그램과 대등한 속도를 가짐. MFC는 내부적으로 인라인(Inline) 함수를 많이 사용하여 클래스 라이브러리가 제공하는 부가 코드로 인한 실행 속도 저하를 최소화함.

- `inline`을 짧게 작성해야 하는 이유 
1. **실행 파일 크기 증가 방지** : 인라인 함수는 호출될 때 함수 본문의 코드가 호출 지점에 복사됩니다. 만약 인라인 함수가 길면, 그 함수가 호출되는 모든 곳에 코드가 복사되어 전체 실행 파일의 크기가 불필요하게 커질 수 있습니다.
2. **성능 저하 방지:** 실행 파일 크기가 커지면 캐시(cache) 효율이 떨어져 오히려 성능이 저하될 수 있습니다. 짧은 함수에 인라인을 사용하면 함수 호출에 드는 오버헤드를 줄여 성능을 높일 수 있지만, 너무 길면 이러한 이점이 사라집니다.
3. **컴파일러의 판단:** 대부분의 컴파일러는 인라인 키워드를 '권장'으로만 받아들입니다. 함수가 너무 길다고 판단하면 컴파일러는 인라인 처리를 무시하고 일반 함수로 처리합니다.
4. **컴파일 시간 오버헤드:** 인라인 함수의 내용이 변경되면, 해당 함수가 사용된 모든 코드가 변경 사항을 반영하기 위해 다시 컴파일되어야 하므로 컴파일 시간이 길어집니다.

####  CObject에서 제공하는 굵직한 기능
1. RTCI
2. Dynamic Object Creation
3. Serialization
4. Validity Check
5. Container class와의 호환성

#### RTCI, Run-Time Class Information
IsKindOf()

#### CRuntimeClass
- `CRuntimeClass::CreateObject()` : MFC의 런타임 클래스 시스템을 이용할 때, 사용하는 동적 할당 함수. C++의 RTTI를 대체한다.
- CRuntimeClass는 `DECLARE_DYNAMIC`, `DECLARE_DYNCREATE`, `DECLARE_SERIAL` 매크로를 통해 CObject 파생 클래스 내부에 자동으로 정적 멤버 변수로 선언된다.
- MFC는 자체 RTTI 비슷한 메커니즘을 제공한다.
- 동작원리
	1. 클래스 선언 시 `DECLARE_DYNCREATE` 또는 `DECLARE_SERIAL` 매크로를 사용한다.
	2. cpp 파일에 `IMPLEMENT_DYNCREATE` 또는 `IMPLEMENT_SERIAL` 매크로를 사용한다.
	3. 그러면 MFC가 `CRuntimeClass` 정보 테이블에 이 클래스 정보를 등록한다.
	4. 이후 `CRuntimeClass::CreateObject()`를 호출하면, 등록된 생성자를 통해 객체를 new(동적 할당)하여 리턴한다.

#### MFC 주요 전역 함수

![[Pasted image 20250923174132.png]]

#### hInstance

윈도우 운영체제에서 실행 중인 프로그램을 식별하고 관리하는 데 사용되는 고유한 식별자. Win32 API에서 사용되며 애플리케이션의 인스턴스를 나타내는 핸들이다.

- **hInstance의 역할**
	- **프로그램 식별** : 윈도우는 멀티태스킹 운영체제로, 여러 개의 프로그램이 동시에 실행될 수 있다. 이 때, 각 프로그램을 구분하기 위해 인스턴스 핸들이 사용된다.
	- **리소스 로드** : 프로그램에 사용되는 아이콘, 메뉴, 커서, 문자열 테이블과 같은 리소스들은 실행 파일 내부에 저장되어 있다. 윈도우 API 함수들은 hInstance 값을 사용하여 어떤 프로그램의 리소스를 로드해야 하는지 결정한다.
	- **윈도우 클래스 등록** : 윈도우를 생성하기 전에 `WNDCLASS` 구조체를 채워 윈도우 클래스를 등록해야 한다. 이 때, `hInstance`를 지정하여 어떤 프로그램에 속하는 윈도우 클래스인지 운영체제에 알려주게 된다.
	- **모듈 관리** : hInstance는 프로그램 코드와 리소스를 포함하는 모듈의 시작 주소를 나타내기도 한다. 운영체제는 이 핸들을 통해 메모리에 로드된 모듈을 관리하고, 다른 API 함수들이 해당 모듈에 접근할 수 있도록 돕는다.
	- **핸들 계층 구조** : hInstance를 통해 프로그램의 윈도우 핸들(HWND)에 대한 정보를 얻을 수 있다. 즉, hInstance는 프로그램 자체를, HWND는 그 프로그램이 생성한 특정 윈도우 창을 식별하며, hInstance가 HWND보다 상위 개념으로 존재한다.

#### AfxGetApp() vs AfxGetInstanceHandle()

- AfxGetApp()
	- 정의 : 현재 실행 중인 MFC 애플리케이션 객체(`CWinApp*)`를 반환
	- 반환값 : `CWinApp*`
	- 의미 : MFC 애플리케이션은 반드시 `CWinApp`을 상속받은 클래스 하나를 가지고 있는데, 이 객체를 전역적으로 얻어올 수 있게 해준다.

- AfxGetInstanceHandle()
	- 정의 : 현재 애플리케이션 모듈의 인스턴스 핸들(`HINSTANCE`)을 반환
	- 반환값 : `HINSTANCE`(즉, 실행 파일이나 DLL 모듈을 나타내는 핸들. WinAPI에서 사용.)
	- 의미 : WinAPI 함수에서 리소스를 로드하거나 윈도우 클래스를 등록할 때 필요하다. 즉, 현재 코드 실행부가 실행 파일이면 실행 파일의 hInstance를 리턴하고, 현재 코드 실행부가 dll 코드라면 dll의 hInstance를 리턴한다.

#### FrameWindow와 View

MFC 프로그램은 최소 2개의 윈도우로 구성된다.

![[Pasted image 20250924091458.png]]


- MFC에는 프레임 윈도우와 뷰의 기능을 구현하는 두 개의 클래스가 각각 존재한다.
- 프레임 윈도우와 뷰는 부모-자식 관계이다.
- 프레임 윈도우 크기가 변하면 뷰 크기를 똑같이 변경해주므로 겉보기에는 한 개의 윈도우처럼 보이지만, 실제로는 두 개의 윈도우임을 인지해야 한다. 응용 프로그램에서 처리하려는 내용에 따라 코드를 추가하는 위치가 달라져야 하기 때문.

![[Pasted image 20250924100738.png]]

![[Pasted image 20250924101747.png]]

#### 윈도우의 부모-자식 관계 특징

- 자식 윈도우는 항상 부모 윈도우의 클라이언트 영역 내에 위치한다. 만약 클라이언트 영역을 벗어난다면 Clipping되어 보이지 않는다.
- 부모 윈도우가 움직이면 같이 움직인다. 즉, 상대 위치를 가진다.
- 부모 윈도우가 최소화되면 자식 윈도우도 숨겨진다. 또한 부모 윈도우가 파괴되면 자식 윈도우도 파괴된다. 즉, 특성이 상속된다.

#### MFC Document-View 구조

MFC는 **애플리케이션의 데이터와 사용자 인터페이스(UI)를 분리**하기 위해 Document-View 구조를 사용합니다.  
이는 **Model-View-Controller(MVC)** 패턴과 유사한 개념으로, 프로그램을 **데이터 관리 부분**과 **화면 표시 부분**으로 나누어 개발할 수 있게 합니다.

**구조 구성 요소**

1. **Document (CDocument 클래스 계열)**
    - 애플리케이션의 **데이터(모델)**를 관리하는 부분
    - 파일 입출력(저장/불러오기)과 같은 로직도 담당
    - View에서 사용자가 조작한 결과를 데이터에 반영하거나, 데이터를 View에 전달하는 역할
        
2. **View (CView, CScrollView, CFormView 등)**
    - **화면 표시 및 사용자 입력 처리** 담당
    - Document의 데이터를 가져와 화면에 렌더링
    - 마우스/키보드 입력을 받아 Document의 데이터를 수정하거나 갱신 요청을 보냄
        
3. **Frame (CFrameWnd, CMDIFrameWnd 등)**
    - View를 담는 **윈도우 틀** 역할
    - 메뉴, 툴바, 상태 표시줄 같은 UI 관리
    - View와 Document를 연결해주는 중간 관리자 역할
        
4. **Application (CWinApp)**
    - 프로그램 실행의 진입점
    - 문서-뷰 구조 초기화, 프레임 생성, 메시지 루프 관리

![[Pasted image 20250924103604.png]]


#### MFC 주요 함수 호출 순서

- **생성자 호출 순서**
![[Pasted image 20250924153335.png]]

CChildView의 생성자가 CMainFrame의 생성자보다 먼저 호출되는 이유는 CMainFrame이 멤버 변수로 CChildView를 가지고 있기 때문

- **소멸자 호출 순서**
![[Pasted image 20250924153456.png]]

![[Pasted image 20250924155848.png]]

![[Pasted image 20250924163558.png]]

![[Pasted image 20250924163602.png]]

# MFC 4장

#### GDI(Graphics Device Interface)

- **정의**:  Windows에서 제공하는 2D 그래픽 API 집합.
- **특징**
	- 장치 독립적
	- 소프트웨어 렌더링(CPU 기반) -> 성능 안좋음
	- 윈도우 컨트롤, 도형 등 단순한 UI 요소 그리기 용도

#### DC(Device Context)

- **정의** : 출력 장치와 GDI 사이의 연결(핸들 역할)
	- "이 DC에다 그려라"라고 지시하면, 해당 장치(화면/프린터)에 그림이 그려짐
- **형식**
	- `HDC`라는 핸들 타입으로 표현됨
	- DC에는 현재 선택된 펜, 브러시, 폰트, 비트맵 등의 정보가 포함됨(즉, 그리기 상태를 저장하는 컨테이너 역할)
- **흐름**
	1. `GetDC(hwnd)` -> 특정 윈도우의 DC를 얻음
	2. `SelectObject(hdc, pen/brush/font)` -> 원하는 그리기 도구 선택
	3. `TextOut`, `Rectangle`, `LineTo` 같은 GDI 함수로 그림
	4. `ReleaseDC(hwnd, hdc)` -> 사용 후 반환